TestCase subclass: #PPAbstractParserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Core'!!PPAbstractParserTest methodsFor: 'context'!context	^ PPContext new! !!PPAbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aParserObject toToken: aStartInteger stop: aStopInteger end: anEndInteger	| token |	token := self		assert: aParser		parse: aParserObject		to: nil		end: anEndInteger.	self assert: (token isKindOf: PPToken).	self assert: token start equals: aStartInteger.	self assert: token stop equals: aStopInteger.	^ token! !!PPAbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection toToken: aStartInteger stop: aStopInteger	^ self assert: aParser parse: aCollection toToken: aStartInteger stop: aStopInteger end: aCollection size! !!PPAbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection end: anInteger	^ self assert: aParser parse: aCollection to: nil end: anInteger! !!PPAbstractParserTest methodsFor: 'utilities'!assert: aParser fail: aCollection end: anInteger	| stream result context |	self 		assert: aParser isPetitParser		description: 'Parser invalid'.	stream := aCollection asPetitStream.	context := self context.			result := aParser parse: stream withContext: context.	self 		assert: result isPetitFailure		description: 'Parser did not fail'.	self		assert: context position = anInteger		description: 'Parser failed at wrong position'.	^ result! !!PPAbstractParserTest methodsFor: 'utilities'!assert: aParser fail: aCollection	^ self assert: aParser fail: aCollection end: 0! !!PPAbstractParserTest methodsFor: 'utilities'!assert: string1 includesSubstring: string2	"Support portability by using ANSI search method"	self assert: (string1 notEmpty and: [string2 notEmpty and: [0 < (string1 indexOfSubCollection: string2 startingAt: 1)]])! !!PPAbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection	^ self assert: aParser parse: aCollection to: nil end: aCollection size ! !!PPAbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection to: aTargetObject end: anInteger	| stream result context |	self assert: aParser isPetitParser description: 'Parser invalid'.	stream := aCollection asPetitStream.	context := self context.		result := aParser parse: stream withContext: context.	aTargetObject isNil		ifTrue: [ self deny: result isPetitFailure ]		ifFalse: [ self assert: result equals: aTargetObject ].	self assert: context position = anInteger description: 'Parser accepted at wrong position'.	^ result! !!PPAbstractParserTest methodsFor: 'utilities'!assert: aParser parse: aCollection to: anObject	^ self assert: aParser parse: aCollection to: anObject end: aCollection size ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPAbstractParserTest class	instanceVariableNames: ''!!PPAbstractParserTest class methodsFor: 'accessing'!packageNamesUnderTest	^ #('PetitParser' 'PetitTests')! !!PPAbstractParserTest class methodsFor: 'testing'!isAbstract	^ self name = #PPAbstractParserTest! !PPAbstractParserTest subclass: #PPCompositeParserTest	instanceVariableNames: 'parser result debugResult'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Core'!!PPCompositeParserTest methodsFor: 'parsing'!fail: aString rule: aSymbol 	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production end parse: aString withContext: context.		self		assert: result isPetitFailure		description: 'Able to parse ' , aString printString.	^ result! !!PPCompositeParserTest methodsFor: 'parsing'!debug: aString 	^ self debug: aString rule: #start! !!PPCompositeParserTest methodsFor: 'parsing'!debug: aString rule: aSymbol	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		debugResult := production end enableDebug parse: aString withContext: context.	result := debugResult children first result.		self		deny: result isPetitFailure		description: 'Unable to parse ' , aString printString.			^ debugResult! !!PPCompositeParserTest methodsFor: 'parsing'!parse: aString rule: aSymbol	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production end parse: aString withContext: context.	self		deny: result isPetitFailure		description: 'Unable to parse ' , aString printString.	^ result! !!PPCompositeParserTest methodsFor: 'parsing'!parse: aString rule: aSymbol to: expectedResult end: end	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production parse: aString withContext: context.	self		deny: result isPetitFailure		description: 'Unable to parse ' , aString printString.		self assert: expectedResult = result.	self assert: context position = end.	^ result! !!PPCompositeParserTest methodsFor: 'parsing'!parse: aString 	^ self parse: aString rule: #start! !!PPCompositeParserTest methodsFor: 'utilities'!assert: aCollection is: anObject	self parse: aCollection.	self		assert: result = anObject		description: 'Got: ' , result printString , '; Expected: ' , anObject printString		resumable: true! !!PPCompositeParserTest methodsFor: 'accessing'!parserClass	self subclassResponsibility! !!PPCompositeParserTest methodsFor: 'accessing'!parserInstance	^ PPParserResource current parserAt: self parserClass! !!PPCompositeParserTest methodsFor: 'accessing'!parserInstanceFor: aSymbol	^ aSymbol = #start		ifTrue: [ self parserInstance ]		ifFalse: [			self parserInstance				productionAt: aSymbol 				ifAbsent: [ self error: 'Production ' , self parserClass name , '>>' , aSymbol printString , ' not found.' ] ]! !!PPCompositeParserTest methodsFor: 'running'!setUp	super setUp.	parser := self parserInstance! !!PPCompositeParserTest methodsFor: 'running'!tearDown	parser := result := nil.	super tearDown.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPCompositeParserTest class	instanceVariableNames: ''!!PPCompositeParserTest class methodsFor: 'testing'!isAbstract	^ self name = #PPCompositeParserTest! !!PPCompositeParserTest class methodsFor: 'accessing'!resources	^ Array with: PPParserResource! !PPCompositeParserTest subclass: #CoPGrammerTest	instanceVariableNames: 'testBrackets testMul testNum testPro testSubt testTerm testVar'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Core'!!CoPGrammerTest commentStamp: 'MarkusKaleta 1/8/2020 04:20' prior: 0!by Markus KaletaTests for CoPGrammer methods!!CoPGrammerTest methodsFor: 'tests' stamp: 'MarkusKaleta 1/8/2020 04:15'!testNuumself parse: '1909' rule: #num.! !!CoPGrammerTest methodsFor: 'tests' stamp: 'MarkusKaleta 1/8/2020 11:59'!testOpenBracketsself parse: '4*(4' rule: #brackets.! !!CoPGrammerTest methodsFor: 'tests' stamp: 'MarkusKaleta 1/8/2020 12:02'!testCloseBracketsself parse: '4)*' rule: #brackets.! !!CoPGrammerTest methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:13'!testSubt self parse: '999-55' rule: #subt.! !!CoPGrammerTest methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:14'!parserClass ^ CoPGrammer ! !!CoPGrammerTest methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:25'!testTerm self parse: 'subt / pro' rule: #term. ! !!CoPGrammerTest methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:19'!testMul self parse: '17*39' rule: #mul.! !TestResource subclass: #PPParserResource	instanceVariableNames: 'parsers'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Core'!!PPParserResource methodsFor: 'accessing'!parserAt: aParserClass	"Answer a cached instance of aParserClass."		^ parsers at: aParserClass name ifAbsentPut: [ aParserClass new ]! !!PPParserResource methodsFor: 'running'!setUp	super setUp.	parsers := Dictionary new! !PPCompositeParserTest subclass: #PPArithmeticParserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPArithmeticParserTest methodsFor: 'accessing'!parserClass	^ PPArithmeticParser! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testMul	self assert: '2 * 3' is: 6.	self assert: '2 * -4' is: -8! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testDivMany	self assert: '100 / 2' is: 50.	self assert: '100 / 2 / 2' is: 25.	self assert: '100 / 2 / 2 / 5' is: 5.	self assert: '100 / 2 / 2 / 5 / 5' is: 1	! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testSubMany	self assert: '1' is: 1.	self assert: '1 - 2' is: -1.	self assert: '1 - 2 - 3' is: -4.	self assert: '1 - 2 - 3 - 4' is: -8.	self assert: '1 - 2 - 3 - 4 - 5' is: -13! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testAdd	self assert: '1 + 2' is: 3.	self assert: '2 + 1' is: 3.	self assert: '1 + 2.3' is: 3.3.	self assert: '2.3 + 1' is: 3.3.	self assert: '1 + -2' is: -1.	self assert: '-2 + 1' is: -1! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testSub	self assert: '1 - 2' is: -1.	self assert: '1.2 - 1.2' is: 0.	self assert: '1 - -2' is: 3.	self assert: '-1 - -2' is: 1! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testDiv	self assert: '12 / 3' is: 4.	self assert: '-16 / -4' is: 4! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testPow	self assert: '2 ^ 3' is: 8.	self assert: '-2 ^ 3' is: -8.	self assert: '-2 ^ -3' is: -0.125! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testMulMany	self assert: '1 * 2' is: 2.	self assert: '1 * 2 * 3' is: 6.	self assert: '1 * 2 * 3 * 4' is: 24.	self assert: '1 * 2 * 3 * 4 * 5' is: 120! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testAddMany	self assert: '1' is: 1.	self assert: '1 + 2' is: 3.	self assert: '1 + 2 + 3' is: 6.	self assert: '1 + 2 + 3 + 4' is: 10.	self assert: '1 + 2 + 3 + 4 + 5' is: 15! !!PPArithmeticParserTest methodsFor: 'testing-operations'!testPowMany	self assert: '4 ^ 3' is: 64.	self assert: '4 ^ 3 ^ 2' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1 ^ 0' is: 262144! !!PPArithmeticParserTest methodsFor: 'testing-expression'!testBrackets	self assert: '(1)' is: 1.	self assert: '(1 + 2)' is: 3.		self assert: '((1))' is: 1.	self assert: '((1 + 2))' is: 3.	self assert: '2 * (3 + 4)' is: 14.	self assert: '(2 + 3) * 4' is: 20.	self assert: '6 / (2 + 4)' is: 1.	self assert: '(2 + 6) / 2' is: 4! !!PPArithmeticParserTest methodsFor: 'testing-expression'!testPriority	self assert: '2 * 3 + 4' is: 10.	self assert: '2 + 3 * 4' is: 14.	self assert: '6 / 3 + 4' is: 6.	self assert: '2 + 6 / 2' is: 5! !!PPArithmeticParserTest methodsFor: 'testing'!testNum	self assert: '0' is: 0.	self assert: '0.0' is: 0.0.	self assert: '1' is: 1.	self assert: '1.2' is: 1.2.	self assert: '34' is: 34.	self assert: '56.78' is: 56.78.	self assert: '-9' is: -9.	self assert: '-9.9' is: -9.9! !PPAbstractParserTest subclass: #PPComposedTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPComposedTest methodsFor: 'testing-examples'!testComment	self assert: self comment parse: '""' to: '""'.	self assert: self comment parse: '"a"' to: '"a"'.	self assert: self comment parse: '"ab"' to: '"ab"'.	self assert: self comment parse: '"abc"' to: '"abc"'.	self assert: self comment parse: '""a' to: '""' end: 2.	self assert: self comment parse: '"a"a' to: '"a"' end: 3.	self assert: self comment parse: '"ab"a' to: '"ab"' end: 4.	self assert: self comment parse: '"abc"a' to: '"abc"' end: 5.	self assert: self comment fail: '"'.	self assert: self comment fail: '"a'.	self assert: self comment fail: '"aa'.	self assert: self comment fail: 'a"'.	self assert: self comment fail: 'aa"'! !!PPComposedTest methodsFor: 'testing-examples'!testNumber	self assert: self number parse: '1' to: '1'.	self assert: self number parse: '12' to: '12'.	self assert: self number parse: '12.3' to: '12.3'.	self assert: self number parse: '12.34' to: '12.34'.	self assert: self number parse: '1..' to: '1' end: 1.	self assert: self number parse: '12-' to: '12' end: 2.	self assert: self number parse: '12.3.' to: '12.3' end: 4.	self assert: self number parse: '12.34.' to: '12.34' end: 5.		self assert: self number parse: '-1' to: '-1'.	self assert: self number parse: '-12' to: '-12'.	self assert: self number parse: '-12.3' to: '-12.3'.	self assert: self number parse: '-12.34' to: '-12.34'.		self assert: self number fail: ''.	self assert: self number fail: '-'.	self assert: self number fail: '.'.	self assert: self number fail: '.1'! !!PPComposedTest methodsFor: 'testing-examples'!testIdentifier	self assert: self identifier parse: 'a' to: 'a'.	self assert: self identifier parse: 'a1' to: 'a1'.	self assert: self identifier parse: 'a12' to: 'a12'.	self assert: self identifier parse: 'ab' to: 'ab'.	self assert: self identifier parse: 'a1b' to: 'a1b'.	self assert: self identifier parse: 'a_' to: 'a' end: 1.	self assert: self identifier parse: 'a1-' to: 'a1' end: 2.	self assert: self identifier parse: 'a12+' to: 'a12' end: 3.	self assert: self identifier parse: 'ab^' to: 'ab' end: 2.	self assert: self identifier parse: 'a1b*' to: 'a1b' end: 3.	self assert: self identifier fail: ''.	self assert: self identifier fail: '1'.	self assert: self identifier fail: '1a'! !!PPComposedTest methodsFor: 'testing-examples'!testReturn	| number spaces return |	number := #digit asParser plus flatten.	spaces := #space asParser star.	return := (spaces , $^ asParser token , spaces , number)		==> [ :nodes | Array with: #return with: (nodes at: 4) ].	self assert: return parse: '^1' to: #(return '1').	self assert: return parse: '^12' to: #(return '12').	self assert: return parse: '^ 123' to: #(return '123').	self assert: return parse: '^  1234' to: #(return '1234').		self assert: return fail: '1'.	self assert: return fail: '^'! !!PPComposedTest methodsFor: 'accessing'!identifier	^ (#letter asParser , #word asParser star) flatten! !!PPComposedTest methodsFor: 'accessing'!comment	^ ($" asParser , $" asParser negate star , $" asParser) flatten! !!PPComposedTest methodsFor: 'accessing'!number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten! !!PPComposedTest methodsFor: 'testing'!testListOfIntegers	"S ::= S , number | number"		| number list parser |	number := #digit asParser plus flatten trim		==> [ :node | node asInteger ].	list := (number separatedBy: $, asParser token trim)		==> [ :node | node select: [ :each | each isKindOf: Integer ] ].	parser := list end.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1,2' to: (1 to: 2) asArray.	self assert: parser parse: '1,2,3' to: (1 to: 3) asArray.	self assert: parser parse: '1,2,3,4' to: (1 to: 4) asArray.	self assert: parser parse: '1,2,3,4,5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1, 2' to: (1 to: 2) asArray.	self assert: parser parse: '1, 2, 3' to: (1 to: 3) asArray.	self assert: parser parse: '1, 2, 3, 4' to: (1 to: 4) asArray.	self assert: parser parse: '1, 2, 3, 4, 5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1 ,2' to: (1 to: 2) asArray.	self assert: parser parse: '1 ,2 ,3' to: (1 to: 3) asArray.	self assert: parser parse: '1 ,2 ,3 ,4' to: (1 to: 4) asArray.	self assert: parser parse: '1 ,2 ,3 ,4 ,5' to: (1 to: 5) asArray.		self assert: parser fail: ''.	self assert: parser fail: ','.	self assert: parser fail: '1,'.	self assert: parser fail: '1,,2'! !!PPComposedTest methodsFor: 'testing'!testLeftRecursion	"S ::= S 'x' S / '1'"		| parser |	parser := PPDelegateParser new.	parser setParser: ((parser , $x asParser , parser) / $1 asParser) memoized flatten.	self assert: parser parse: '1' to: '1'.	self assert: parser parse: '1x1' to: '1x1'.	self assert: parser parse: '1x1x1' to: '1x1x1'.	self assert: parser parse: '1x1x1x1' to: '1x1x1x1'.	self assert: parser parse: '1x1x1x1x1' to: '1x1x1x1x1'.	self assert: parser parse: '1x1x1x1x1x1' to: '1x1x1x1x1x1'! !!PPComposedTest methodsFor: 'testing'!testParseAaaBbb	"S0 ::= a S1 b	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: $a asParser , s1 , $b asParser.	s1 setParser: s0 / nil asParser.	parser := s0 flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aabb' to: 'aabb'.	self assert: parser parse: 'aaabbb' to: 'aaabbb'.	self assert: parser parse: 'aaaabbbb' to: 'aaaabbbb'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'aabbb' to: 'aabb' end: 4.	self assert: parser parse: 'aaabbbb' to: 'aaabbb' end: 6.	self assert: parser parse: 'aaaabbbbb' to: 'aaaabbbb' end: 8.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'aaabb'! !!PPComposedTest methodsFor: 'testing'!testIfThenElse	"S ::= if C then S else S | if C then S | X"	| start if then else cond expr parser |	start := PPDelegateParser new.	if := 'if' asParser token trim.	then := 'then' asParser token trim.	else := 'else' asParser token trim.	cond := 'C' asParser token trim.	expr := 'X' asParser token trim.	start setParser: (if , cond , then , start , else , start) / (if , cond , then , start) / expr.	parser := start end.	self assert: parser parse: 'X'.	self assert: parser parse: 'if C then X'.	self assert: parser parse: 'if C then X else X'.	self assert: parser parse: 'if C then if C then X'.	self assert: parser parse: 'if C then if C then X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X else X'.	self assert: parser fail: 'if C'.	self assert: parser fail: 'if C else X'.	self assert: parser fail: 'if C then if C'! !!PPComposedTest methodsFor: 'testing'!testParseAbabbb	"S ::= (A | B)+"	| parser |	parser := ($a asParser / $b asParser) plus flatten.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'b' to: 'b'.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'ba' to: 'ba'.	self assert: parser parse: 'aaa' to: 'aaa'.	self assert: parser parse: 'aab' to: 'aab'.	self assert: parser parse: 'aba' to: 'aba'.	self assert: parser parse: 'baa' to: 'baa'.	self assert: parser parse: 'abb' to: 'abb'.	self assert: parser parse: 'bab' to: 'bab'.	self assert: parser parse: 'bba' to: 'bba'.	self assert: parser parse: 'bbb' to: 'bbb'.	self assert: parser parse: 'ac' to: 'a' end: 1.	self assert: parser parse: 'bc' to: 'b' end: 1.	self assert: parser parse: 'abc' to: 'ab' end: 2.	self assert: parser parse: 'bac' to: 'ba' end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!PPComposedTest methodsFor: 'testing'!testDoubledString	| parser |	parser := ($' asParser , (($' asParser , $' asParser) / $' asParser negate) star flatten , $' asParser) 		==> [ :nodes | nodes second copyReplaceAll: '''''' with: '''' ].	self assert: parser parse: '''''' to: ''.	self assert: parser parse: '''a''' to: 'a'.	self assert: parser parse: '''ab''' to: 'ab'.	self assert: parser parse: '''a''''b''' to: 'a''b'.	self assert: parser parse: '''a''''''''b''' to: 'a''''b'! !!PPComposedTest methodsFor: 'testing'!testNestedComments	"C ::= B I* E"	"I ::= !!E (C | T)"	"B ::= /*"	"E ::= */"	"T ::= ."		| begin end any inside parser |	begin := '/*' asParser.	end := '*/' asParser.	any := #any asParser.		parser := PPDelegateParser new.	inside := end not , (parser / any).	parser setParser: begin , inside star , end.		self assert: parser parse: '/*ab*/cd' end: 6.	self assert: parser parse: '/*a/*b*/c*/'.	self assert: parser fail: '/*a/*b*/c'! !!PPComposedTest methodsFor: 'testing'!testParseAbAbAb	"S ::= (A B)+"		| parser |	parser := ($a asParser , $b asParser) plus flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'abab' to: 'abab'.	self assert: parser parse: 'ababab' to: 'ababab'.	self assert: parser parse: 'abababab' to: 'abababab'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'ababa' to: 'abab' end: 4.	self assert: parser parse: 'abababb' to: 'ababab' end: 6.	self assert: parser parse: 'ababababa' to: 'abababab' end: 8.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'bab'! !!PPComposedTest methodsFor: 'testing'!testParseAaaaaa	"S ::= a a S | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := $a asParser , $a asParser , s0.	s0 setParser: s1 / nil asParser.	parser := s0 flatten.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'aaaa' to: 'aaaa'.	self assert: parser parse: 'aaaaaa' to: 'aaaaaa'.	self assert: parser parse: 'a' to: '' end: 0.	self assert: parser parse: 'aaa' to: 'aa' end: 2.	self assert: parser parse: 'aaaaa' to: 'aaaa' end: 4.	self assert: parser parse: 'aaaaaaa' to: 'aaaaaa' end: 6! !!PPComposedTest methodsFor: 'testing'!testEvenNumber	"Create a grammar that parses an even number of a's and b's."		| a as b bs s |	a := $a asParser ==> [ :char | as := as + 1 ].	b := $b asParser ==> [ :char | bs := bs + 1 ].	s := (a / b) star >=> [ :stream :cc |		as := bs := 0.		cc value.		(as even and: [ bs even ])			ifFalse: [ PPFailure message: 'Even number of a and b expected' context: stream at: 0 ] ].	self assert: s fail: 'a' end: 1.	self assert: s fail: 'b' end: 1.	self assert: s fail: 'ab' end: 2.	self assert: s fail: 'ba' end: 2.	self assert: s fail: 'aaa' end: 3.	self assert: s fail: 'bbb' end: 3.	self assert: s fail: 'aab' end: 3.	self assert: s fail: 'abb' end: 3.		self assert: s parse: ''.	self assert: s parse: 'aa'.	self assert: s parse: 'bb'.	self assert: s parse: 'aaaa'.	self assert: s parse: 'aabb'.	self assert: s parse: 'abab'.	self assert: s parse: 'baba'.	self assert: s parse: 'bbaa'.	self assert: s parse: 'bbbb'! !!PPComposedTest methodsFor: 'testing'!testPalindrome	"S0 ::= a S1 a | b S1 b | ...	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: ($a asParser , s1 , $a asParser)		/ ($b asParser , s1 , $b asParser)		/ ($c asParser , s1 , $c asParser).		s1 setParser: s0 / nil asParser.	parser := s0 flatten end.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'bb' to: 'bb'.	self assert: parser parse: 'cc' to: 'cc'.		self assert: parser parse: 'abba' to: 'abba'.	self assert: parser parse: 'baab' to: 'baab'.	self assert: parser parse: 'abccba' to: 'abccba'.	self assert: parser parse: 'abaaba' to: 'abaaba'.	self assert: parser parse: 'cbaabc' to: 'cbaabc'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'abccbb'! !!PPComposedTest methodsFor: 'testing'!testParseAnBnCn	"PEGs for a non context- free language: 				a^n , b^n , c^n			S <- &P1 P2 	P1 <- AB 'c' 	AB <- 'a' AB 'b' / epsilon	P2 <- 'a'* BC end	BC <- 'b' BC 'c' / epsilon"		| s p1 ab p2 bc |	s := PPDelegateParser new.	p1 := PPDelegateParser new.	ab := PPDelegateParser new.	p2 := PPDelegateParser new.	bc := PPDelegateParser new.		s setParser: (p1 and , p2 end) flatten.	p1 setParser: ab , $c asParser.	ab setParser: ($a asParser , ab , $b asParser) optional.	p2 setParser: $a asParser star , bc.	bc setParser: ($b asParser , bc , $c asParser) optional.		self assert: s parse: 'abc' to: 'abc'.	self assert: s parse: 'aabbcc' to: 'aabbcc'.	self assert: s parse: 'aaabbbccc' to: 'aaabbbccc'.	self assert: s fail: 'bc'.	self assert: s fail: 'ac'.	self assert: s fail: 'ab'.	self assert: s fail: 'abbcc'.	self assert: s fail: 'aabcc'.	self assert: s fail: 'aabbc'! !PPAbstractParserTest subclass: #PPConditionalParserTest	instanceVariableNames: 'context'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPConditionalParserTest methodsFor: 'running'!setUp	super setUp.	context := PPContext new! !!PPConditionalParserTest methodsFor: 'as yet unclassified'!testConditionFalse	| parser |	parser := ('a' asParser if: [ :ctx | false ]).		self assert: parser fail: 'a'.	self assert: parser fail: 'b'.! !!PPConditionalParserTest methodsFor: 'as yet unclassified'!testConditionCtxAccess	| parser |	parser := ('a' asParser if: [ :ctx | (ctx propertyAt: #foo) = #bar ]).		context propertyAt: #foo put: #bar.	self assert: parser parse: 'a' .	context propertyAt: #foo put: #zorg.	self assert: parser fail: 'a' .! !!PPConditionalParserTest methodsFor: 'as yet unclassified'!context	^ context! !!PPConditionalParserTest methodsFor: 'as yet unclassified'!testConditionTrue	| parser |	parser := ('a' asParser if: [ :ctx | true ]).		self assert: parser parse: 'a'.	self assert: parser fail: 'b'.! !PPAbstractParserTest subclass: #PPConditionalParserTests	instanceVariableNames: 'context'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPConditionalParserTests methodsFor: 'as yet unclassified'!testConditionFalse	| parser |	parser := ('a' asParser if: [ :ctx | false ]).		self assert: parser fail: 'a'.	self assert: parser fail: 'b'.! !!PPConditionalParserTests methodsFor: 'as yet unclassified'!testConditionCtxAccess	| parser |	parser := ('a' asParser if: [ :ctx | (ctx propertyAt: #foo) = #bar ]).		context propertyAt: #foo put: #bar.	self assert: parser parse: 'a' .	context propertyAt: #foo put: #zorg.	self assert: parser fail: 'a' .! !!PPConditionalParserTests methodsFor: 'as yet unclassified'!context	^ context! !!PPConditionalParserTests methodsFor: 'as yet unclassified'!testConditionTrue	| parser |	parser := ('a' asParser if: [ :ctx | true ]).		self assert: parser parse: 'a'.	self assert: parser fail: 'b'.! !!PPConditionalParserTests methodsFor: 'running'!setUp	super setUp.	context := PPContext new! !TestCase subclass: #PPContextMementoTest	instanceVariableNames: 'memento'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPContextMementoTest methodsFor: 'accessing'!memento	^ PPContextMemento new! !!PPContextMementoTest methodsFor: 'running'!setUp	super setUp.	memento := self memento.! !!PPContextMementoTest methodsFor: 'tests'!testEquality	| m1 m2  |	m1 := self memento.	m2 := self memento.		self assert: m1 = m2.		m1 propertyAt: #foo put: #bar.	self assert: (m1 = m2) not.		m2 propertyAt: #foo put: #bar.	self assert: m1 = m2.! !!PPContextMementoTest methodsFor: 'tests'!testPutProperty	| c retval  |	c := OrderedCollection new.	self assert: (memento hasProperty: #foo) not.	self assert: (memento hasProperty: #bar) not.			self should: [ memento propertyAt: #foo ] raise: Error.	self assert: (memento propertyAt: #foo ifAbsent: [ c ]) == c.		retval := memento propertyAt: #foo ifAbsentPut: [ c ].	self assert: retval size = c size.		self assert: (retval == c) not.	self assert: retval = c.	self assert: (memento hasProperty: #foo).		retval := memento propertyAt: #bar put: c.	self assert: retval size = c size.		self assert: (retval == c) not.	self assert: retval = c.	self assert: (memento hasProperty: #foo).	! !!PPContextMementoTest methodsFor: 'tests'!testEquality2	| m1 m2  |	m1 := self memento.	m2 := self memento.		self assert: m1 = m2.		m1 propertyAt: #foo put: #bar.	self assert: (m1 = m2) not.		m2 propertyAt: #bar put: #foo.	self assert: (m1 = m2) not.! !!PPContextMementoTest methodsFor: 'tests'!testKeysAndValuesDo	|   |	memento keysAndValuesDo: [ :key :value |		self signalFailure: 'Should not be called'	].! !!PPContextMementoTest methodsFor: 'tests'!testKeysAndValuesDo2	| c1 c2   |	c1 := OrderedCollection new.	c2 := OrderedCollection new.	memento propertyAt: #foo put: c1.	memento propertyAt: #bar put: c2.	memento keysAndValuesDo: [ :key :value |		self assert: (value == c1) not.		self assert: (value == c2) not.	].! !!PPContextMementoTest methodsFor: 'tests'!testGetProperty		| c retval retval2 |	c := OrderedCollection new.		memento propertyAt: #foo put: c.		retval := memento propertyAt: #foo.	self assert: retval size = c size.	self assert: (retval == c) not.	self assert: retval = c.		c add: #element.	self assert: (retval = c) not.	retval2 := memento propertyAt: #foo.	self assert: (retval = retval2).	self assert: (retval == retval2) not.		retval add: #element.	self assert: (retval = retval2) not.! !TestCase subclass: #PPContextTest	instanceVariableNames: 'context'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPContextTest methodsFor: 'as yet unclassified'!context	^ PPContext new! !!PPContextTest methodsFor: 'tests'!testRemoveGlobals	context globalAt: #foo put: #zorg.	context globalAt: #bar put: #qwark.		self assert: (context removeGlobal: #foo) = #zorg.	self assert: (context removeGlobal: #bar) = #qwark.		self should: [context removeGlobal: #foo] raise: Error.	self assert: (context removeGlobal: #bar ifAbsent: [ #foobar ]) = #foobar.! !!PPContextTest methodsFor: 'tests'!testMemoization2	| stream memento |	stream := 'abc' asPetitStream.	context := context stream: stream.		memento := context remember.		context next.	self assert: context position = 1.		context restore: memento.	self assert: context position = 0.! !!PPContextTest methodsFor: 'tests'!testFurthestFailure	| f1 f2 |		f1 := PPFailure message: #foo context: context at: 1.	self assert: context furthestFailure = f1.		f2 := PPFailure message: #foo context: context at: 1.	self assert: context furthestFailure = f1.		f2 := PPFailure message: #foo context: context at: 3.	self assert: context furthestFailure = f2.! !!PPContextTest methodsFor: 'tests'!testRemoveProperties	context propertyAt: #foo put: #zorg.	context propertyAt: #bar put: #qwark.		self assert: (context removeProperty: #foo) = #zorg.	self assert: (context removeProperty: #bar) = #qwark.		self should: [context removeProperty: #foo] raise: Error.	self assert: (context removeProperty: #bar ifAbsent: [ #foobar ]) = #foobar.! !!PPContextTest methodsFor: 'tests'!testStreamProtocol	context stream: 'hi there' asPetitStream.		self assert: context position = 0.	self assert: context peek = $h.	self assert: context uncheckedPeek = $h.	self assert: context next = $h.	self assert: context peek = $i.	self assert: context uncheckedPeek = $i.	self assert: context position = 1.		context skip: 2.	self assert: context position = 3.	self assert: context peek = $t.	self assert: context atEnd not.		self assert: (context next: 5) = 'there'.	self assert: context position = 8.	self assert: context atEnd.! !!PPContextTest methodsFor: 'tests'!testPutGlobals	self assert: (context hasGlobal: #foo) not.	self assert: (context hasGlobal: #bar) not.			self should: [ context globalAt: #foo ] raise: Error.	self assert: (context globalAt: #foo ifAbsent: [ #bar ]) = #bar.		self assert: (context globalAt: #foo ifAbsentPut: [ #bar ]) = #bar.		self assert: (context hasGlobal: #foo).	self assert: (context hasGlobal: #bar) not.		self assert: (context globalAt: #foo) = #bar.		self assert: (context globalAt: #foo ifAbsentPut: [ #zorg ]) = #bar.		self assert: (context hasGlobal: #foo).	self assert: (context hasGlobal: #bar) not.		self assert: (context globalAt: #foo) = #bar.		self assert: (context globalAt: #foo put: #zorg) = #zorg.		self assert: (context hasGlobal: #foo).	self assert: (context hasGlobal: #bar) not.		self assert: (context globalAt: #foo) = #zorg.		self should: [ context globalAt: #bar ] raise: Error.	self assert: (context globalAt: #bar put: #foo) = #foo.	self assert: (context globalAt: #foo) = #zorg.	self assert: (context globalAt: #bar) = #foo.! !!PPContextTest methodsFor: 'tests'!testMemoization3	| stream memento memento2 collection |	stream := 'abc' asPetitStream.	context := context stream: stream.	collection := OrderedCollection new.	memento := context remember.	context propertyAt: #foo put: collection.	memento2 := context remember.		context restore: memento.	self assert: (context hasProperty: #foo) not.		context restore: memento2.	self assert: (context hasProperty: #foo).! !!PPContextTest methodsFor: 'tests'!testPutProperties	self assert: (context hasProperty: #foo) not.	self assert: (context hasProperty: #bar) not.			self should: [ context propertyAt: #foo ] raise: Error.	self assert: (context propertyAt: #foo ifAbsent: [ #bar ]) = #bar.		self assert: (context propertyAt: #foo ifAbsentPut: [ #bar ]) = #bar.		self assert: (context hasProperty: #foo).	self assert: (context hasProperty: #bar) not.		self assert: (context propertyAt: #foo) = #bar.		self assert: (context propertyAt: #foo ifAbsentPut: [ #zorg ]) = #bar.		self assert: (context hasProperty: #foo).	self assert: (context hasProperty: #bar) not.		self assert: (context propertyAt: #foo) = #bar.		self assert: (context propertyAt: #foo put: #zorg) = #zorg.		self assert: (context hasProperty: #foo).	self assert: (context hasProperty: #bar) not.		self assert: (context propertyAt: #foo) = #zorg.		self should: [ context propertyAt: #bar ] raise: Error.	self assert: (context propertyAt: #bar put: #foo) = #foo.	self assert: (context propertyAt: #foo) = #zorg.	self assert: (context propertyAt: #bar) = #foo.! !!PPContextTest methodsFor: 'tests'!testMemoization	| stream memento memento2 collection |	stream := 'abc' asPetitStream.	context := context stream: stream.	collection := OrderedCollection new.	context propertyAt: #foo put: collection.		memento := context remember.		self assert: memento isNil not.		context next.	collection add: #element.	self assert: (context propertyAt: #foo) size = 1. 		memento2 := context remember.	context restore: memento.	self assert: (context propertyAt: #foo) size = 0. 	self assert: context position = 0.		context restore: memento2.	self assert: (context propertyAt: #foo) size = 1. 	self assert: context position = 1.! !!PPContextTest methodsFor: 'running'!setUp	super setUp.	context := self context.! !PPArithmeticParserTest subclass: #PPExpressionParserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPExpressionParserTest methodsFor: 'accessing'!parserInstance	| expression parens number |	expression := PPExpressionParser new.	parens := $( asParser trim , expression , $) asParser trim		==> [ :value | value second ].	number := (#digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten trim		==> [ :value | value asNumber ].	expression term: parens / number.	expression		group: [ :g |			g prefix: $- asParser trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser trim do: [ :a :op :b | a * b ].			g left: $/ asParser trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser trim do: [ :a :op :b | a + b ].			g left: $- asParser trim do: [ :a :op :b | a - b ] ].	^ expression end! !!PPExpressionParserTest methodsFor: 'testing'!testPostfixSub	self assert: '1--' is: 0.	self assert: '2----' is: 0.	self assert: '3------' is: 0.	self assert: '2---1' is: 0.	self assert: '3-----1' is: 0.	self assert: '4-------1' is: 0.! !!PPExpressionParserTest methodsFor: 'testing'!testPostfixAdd	self assert: '0++' is: 1.	self assert: '0++++' is: 2.	self assert: '0++++++' is: 3.	self assert: '0+++1' is: 2.	self assert: '0+++++1' is: 3.	self assert: '0+++++++1' is: 4! !!PPExpressionParserTest methodsFor: 'testing'!testPrefixNegate	self assert: '1' is: 1.	self assert: '-1' is: -1.	self assert: '--1' is: 1.	self assert: '---1' is: -1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPExpressionParserTest class	instanceVariableNames: ''!!PPExpressionParserTest class methodsFor: 'testing'!shouldInheritSelectors	^ true! !PPAbstractParserTest subclass: #PPExtensionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPExtensionTest methodsFor: 'testing-stream'!testText	| stream |	stream := 'abc' asText asPetitStream.	self assert: stream class equals: PPStream! !!PPExtensionTest methodsFor: 'testing-stream'!testStream	| dot stream |	dot := (Character codePoint: 183) asString.	stream := 'abc' readStream asPetitStream.	self assert: stream class equals: PPStream.	self assert: stream printString equals: dot , 'abc'.	self assert: stream peek equals: $a.	self assert: stream uncheckedPeek equals: $a.	self assert: stream next equals: $a.	self assert: stream printString equals: 'a' , dot , 'bc'.	self assert: stream asPetitStream equals: stream! !!PPExtensionTest methodsFor: 'testing-parser'!testEpsilon	| parser |	parser := nil asParser.	self assert: parser asParser equals: parser! !!PPExtensionTest methodsFor: 'testing-parser'!testSequence	| parser |	parser := #(1 2) asSequenceParser.	self assert: parser parse: #(1 2) to: #(1 2).	self assert: parser parse: #(1 2 3) to: #(1 2) end: 2.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 1).	self assert: parser fail: #(1 1 2)! !!PPExtensionTest methodsFor: 'testing-parser'!testRange	| parser |	parser := ($a to: $c) asParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser fail: 'd'! !!PPExtensionTest methodsFor: 'testing-parser'!testSymbol	| parser |	parser := #any asParser.	self assert: parser parse: 'a'.	self assert: parser fail: ''! !!PPExtensionTest methodsFor: 'testing-parser'!testString	| parser |	parser := 'ab' asParser.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aba' to: 'ab' end: 2.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser fail: 'a'.	self assert: parser fail: 'ac'! !!PPExtensionTest methodsFor: 'testing-parser'!testClosure	| parser |	parser := [ :stream | stream upTo: $s ] asParser.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 's' to: ''.	self assert: parser parse: 'as' to: 'a'.	self assert: parser parse: 'aas' to: 'aa'.	self assert: parser parse: 'sa' to: '' end: 1.	self assert: parser parse: 'saa' to: '' end: 1.		parser := [ :stream | stream upTo: $s. PPFailure message: 'stream' context: stream ] asParser.	self assert: parser fail: ''.	self assert: parser fail: 's'.	self assert: parser fail: 'as'	! !!PPExtensionTest methodsFor: 'testing-parser'!testCharacter	| parser |	parser := $a asParser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'! !!PPExtensionTest methodsFor: 'testing-parser'!testChoice	| parser |	parser := #(1 2) asChoiceParser.	self assert: parser parse: #(1) to: 1.	self assert: parser parse: #(2) to: 2.	self assert: parser parse: #(1 2) to: 1 end: 1.	self assert: parser parse: #(2 1) to: 2 end: 1.	self assert: parser fail: #().	self assert: parser fail: #(3)! !!PPExtensionTest methodsFor: 'testing-parser'!testParser	| parser |	parser := $a asParser.	self assert: parser asParser equals: parser! !PPCompositeParserTest subclass: #PPLambdaParserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPLambdaParserTest methodsFor: 'accessing'!parserClass	^ PPLambdaParser! !!PPLambdaParserTest methodsFor: 'testing-utilities'!testParseStartingAtOnError	| beenHere |	result := self parserClass parse: 'x' startingAt: #variable onError: [ self fail ].	self assert: result equals: 'x'.	beenHere := false.	result := self parserClass parse: '\' startingAt: #variable onError: [ beenHere := true ].	self assert: beenHere.	beenHere := false.	result := self parserClass		parse: '\ '		startingAt: #variable		onError: [ :fail | 			beenHere := true.			fail ].	self assert: beenHere.	self assert: result message equals: 'letter expected'.	self assert: result position equals: 0.	beenHere := false.	result := self parserClass		parse: '\ '		startingAt: #variable		onError: [ :msg :pos | 			self assert: msg equals: 'letter expected'.			self assert: pos equals: 0.			beenHere := true ].	self assert: beenHere! !!PPLambdaParserTest methodsFor: 'testing-utilities'!testProductionAt	self assert: (parser productionAt: #foo) isNil.	self assert: (parser productionAt: #foo ifAbsent: [ true ]).		self assert: (parser productionAt: #start) notNil.	self assert: (parser productionAt: #start ifAbsent: [ true ]) notNil.		self assert: (parser productionAt: #variable) notNil.	self assert: (parser productionAt: #variable ifAbsent: [ true ]) notNil! !!PPLambdaParserTest methodsFor: 'testing-utilities'!testParseOnError	| beenHere |	result := self parserClass parse: '\x. y' onError: [ self fail ].	self assert: result equals: #('x' 'y').	beenHere := false.	result := self parserClass parse: '\x.' onError: [ beenHere := true ].	self assert: beenHere.	beenHere := false.	result := self parserClass		parse: '\x. '		onError: [ :fail | 			beenHere := true.			fail ].	self assert: beenHere.	self assert: result message includesSubstring: 'letter'.	self assert: result message includesSubstring: 'expected'.	self assert: result position equals: 4.	beenHere := false.	result := self parserClass		parse: '\x. '		onError: [ :msg :pos | 			self assert: msg includesSubstring: 'letter'.			self assert: msg includesSubstring: 'expected'.			self assert: pos equals: 4.			beenHere := true ].	self assert: result.	self assert: beenHere! !!PPLambdaParserTest methodsFor: 'testing-curch'!testAnd	self assert: self parserClass and equals: #('p' #('q' #(#('p' 'q') 'p')))! !!PPLambdaParserTest methodsFor: 'testing-curch'!testOr	self assert: self parserClass or equals: #('p' #('q' #(#('p' 'p') 'q')))! !!PPLambdaParserTest methodsFor: 'testing-curch'!testTrue	self assert: self parserClass true equals: #('x' #('y' 'x'))! !!PPLambdaParserTest methodsFor: 'testing-curch'!testNot	self assert: self parserClass not equals: #('p' #('a' #('b' #(#('p' 'b') 'a'))))! !!PPLambdaParserTest methodsFor: 'testing-curch'!testFalse	self assert: self parserClass false equals: #('x' #('y' 'y'))! !!PPLambdaParserTest methodsFor: 'testing-curch'!testIfThenElse	self assert: self parserClass ifthenelse equals: #('p' 'p')! !!PPLambdaParserTest methodsFor: 'testing'!testVariable	self assert: 'x' is: 'x'.	self assert: 'xy' is: 'xy'.	self assert: 'x12' is: 'x12'! !!PPLambdaParserTest methodsFor: 'testing'!testApplication	self assert: '(x x)' is: #('x' 'x').	self assert: '(x y)' is: #('x' 'y').	self assert: '((x y) z)' is: #(('x' 'y') 'z').	self assert: '(x (y z))' is: #('x' ('y' 'z'))! !!PPLambdaParserTest methodsFor: 'testing'!testAbstraction	self assert: '\x.y' is: #('x' 'y').	self assert: '\x.\y.z' is: #('x' ('y' 'z'))! !PPAbstractParserTest subclass: #PPMappingTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPMappingTest methodsFor: 'as yet unclassified'!testFoldRight3	| parser |	parser := #any asParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #(a b (c d e))! !!PPMappingTest methodsFor: 'as yet unclassified'!testFoldRight2	| parser |	parser := #any asParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #(a (b c)).	self assert: parser parse: #(a b c d) to: #(a (b (c d))).	self assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))! !!PPMappingTest methodsFor: 'as yet unclassified'!testMap1	| parser |	parser := #any asParser 		map: [ :a | Array with: a ].	self assert: parser parse: #(a) to: #(a)! !!PPMappingTest methodsFor: 'as yet unclassified'!testFoldLeft2	| parser |	parser := #any asParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #((a b) c).	self assert: parser parse: #(a b c d) to: #(((a b) c) d).	self assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)! !!PPMappingTest methodsFor: 'as yet unclassified'!testFoldLeft3	| parser |	parser := #any asParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #((a b c) d e)! !!PPMappingTest methodsFor: 'as yet unclassified'!testMap2	| parser |	parser := (#any asParser , #any asParser) 		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: #(a b) to: #(b a)! !!PPMappingTest methodsFor: 'as yet unclassified'!testMap3	| parser |	parser := (#any asParser , #any asParser , #any asParser)		map: [ :a :b :c | Array with: c with: b with: a ].	self assert: parser parse: #(a b c) to: #(c b a)! !PPAbstractParserTest subclass: #PPObjectTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPObjectTest methodsFor: 'testing'!testInteger	self assert: self integer parse: #(123) to: 123.	self assert: self integer fail: #('abc')! !!PPObjectTest methodsFor: 'testing'!testString	self assert: self string parse: #('abc') to: 'abc'.	self assert: self string fail: #(123)! !!PPObjectTest methodsFor: 'testing-fancy'!testFibonacci	"This parser accepts fibonacci sequences with arbitrary start pairs."		| parser |	parser := ((self integer , self integer) end ==> [ :pair | pair first + pair last ])		/ (self integer , (self integer , self integer) and >=> [ :stream :continuation |			| result |			result := continuation value.			(result isPetitFailure or: [ result first + result last first ~= result last last ])				ifFalse: [ parser parseOn: stream ]				ifTrue: [ PPFailure message: 'invalid fibonacci sequence' context: stream ] ]).	self assert: parser parse: #(1 1) to: 2.	self assert: parser parse: #(1 1 2) to: 3.	self assert: parser parse: #(1 1 2 3) to: 5.	self assert: parser parse: #(1 1 2 3 5) to: 8.	self assert: parser parse: #(1 1 2 3 5 8) to: 13.	self assert: parser parse: #(1 1 2 3 5 8 13) to: 21.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 2 3 4) end: 2	! !!PPObjectTest methodsFor: 'testing-operators'!testSequence	| parser |	parser := self integer , self string.	self assert: parser parse: #(123 'abc') to: #(123 'abc').	self assert: parser fail: #(123 456).	self assert: parser fail: #('abc' 'def').	self assert: parser fail: #('abc' 123)	! !!PPObjectTest methodsFor: 'testing-operators'!testChoice	| parser |	parser := self integer / self string.	self assert: parser parse: #(123) to: 123.	self assert: parser parse: #('abc') to: 'abc'! !!PPObjectTest methodsFor: 'parsers'!string	^ PPPredicateObjectParser		on: [ :each | each isKindOf: String ]		message: 'string expected'! !!PPObjectTest methodsFor: 'parsers'!integer	^ PPPredicateObjectParser		on: [ :each | each isKindOf: Integer ]		message: 'integer expected'! !PPAbstractParserTest subclass: #PPParserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPParserTest methodsFor: 'testing-mapping'!testFoldLeft3	| parser |	parser := #any asParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #((a b c) d e)! !!PPParserTest methodsFor: 'testing-mapping'!testMap3	| parser |	parser := (#any asParser , #any asParser , #any asParser)		map: [ :a :b :c | Array with: c with: b with: a ].	self assert: parser parse: #(a b c) to: #(c b a)! !!PPParserTest methodsFor: 'testing-mapping'!testFoldLeft2	| parser |	parser := #any asParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #((a b) c).	self assert: parser parse: #(a b c d) to: #(((a b) c) d).	self assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)! !!PPParserTest methodsFor: 'testing-mapping'!testTrimCustom	| parser |	parser := $a asParser token trim: $b asParser.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1.	self assert: parser parse: 'abb' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ba' toToken: 2 stop: 2.	self assert: parser parse: 'bba' toToken: 3 stop: 3.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'abba' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping'!testAction	| block parser |	block := [ :char | char asUppercase ].	parser := #any asParser ==> block.	self assert: parser block equals: block.	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B! !!PPParserTest methodsFor: 'testing-mapping'!testFoldRight3	| parser |	parser := #any asParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #(a b (c d e))! !!PPParserTest methodsFor: 'testing-mapping'!testTrim	| parser |	parser := $a asParser token trim.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping'!testMapFail1	self		should: [ #any asParser map: [  ] ]		raise: Error.	self		should: [ #any asParser map: [ :a :b | ] ]		raise: Error! !!PPParserTest methodsFor: 'testing-mapping'!testAnswer	| parser |	parser := $a asParser answer: $b.		self assert: parser parse: 'a' to: $b.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping'!testFlatten	| parser |	parser := $a asParser flatten.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: #($a) to: #($a).		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping'!testToken	| parser |	parser := $a asParser token.	self assert: parser tokenClass equals: PPToken.	self		assert: parser		parse: 'a'		toToken: 1		stop: 1.	self assert: parser fail: 'b'.	self assert: parser fail: ''.	parser := $a asParser token: PPToken.	self assert: parser tokenClass equals: PPToken.	self		assert: parser		parse: 'a'		toToken: 1		stop: 1.	self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping'!testMap2	| parser |	parser := (#any asParser , #any asParser) 		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: #(a b) to: #(b a)! !!PPParserTest methodsFor: 'testing-mapping'!testMapFail2	self		should: [ (#any asParser , #any asParser) map: [ :a | ] ]		raise: Error.	self		should: [ (#any asParser , #any asParser) map: [ :a :b :c | ] ]		raise: Error! !!PPParserTest methodsFor: 'testing-mapping'!testFoldRight2	| parser |	parser := #any asParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #(a (b c)).	self assert: parser parse: #(a b c d) to: #(a (b (c d))).	self assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))! !!PPParserTest methodsFor: 'testing-mapping'!testWrapping	| parser result |	parser := #digit asParser plus >=> [ :stream :cc | Array with: stream position with: cc value with: stream position ].	self assert: parser parse: '1' to: #(0 #($1) 1).	self assert: parser parse: '12' to: #(0 #($1 $2) 2).	self assert: parser parse: '123' to: #(0 #($1 $2 $3) 3).	result := parser parse: 'a'.	self assert: result first equals: 0.	self assert: result second isPetitFailure.	self assert: result last equals: 0! !!PPParserTest methodsFor: 'testing-mapping'!testTrimSpaces	| parser |	parser := $a asParser token trimSpaces.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping'!testPermutation	| parser |	parser := #any asParser , #any asParser , #any asParser.	self assert: (parser permutation: #()) parse: '123' to: #().	self assert: (parser permutation: #(1)) parse: '123' to: #($1).	self assert: (parser permutation: #(1 3)) parse: '123' to: #($1 $3).	self assert: (parser permutation: #(3 1)) parse: '123' to: #($3 $1).	self assert: (parser permutation: #(2 2)) parse: '123' to: #($2 $2).	self assert: (parser permutation: #(3 2 1)) parse: '123' to: #($3 $2 $1).		self should: [ parser permutation: #(0) ] raise: Error.	self should: [ parser permutation: #(4) ] raise: Error.	self should: [ parser permutation: #($2) ] raise: Error! !!PPParserTest methodsFor: 'testing-mapping'!testMap1	| parser |	parser := #any asParser 		map: [ :a | Array with: a ].	self assert: parser parse: #(a) to: #(a)! !!PPParserTest methodsFor: 'testing-mapping'!testTrimBlanks	| parser |	parser := $a asParser token trimBlanks.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.! !!PPParserTest methodsFor: 'testing'!testStarGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser starGreedy: limit.	self assert: parser min equals: 0.	self assert: parser max > parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: '1'		to: #()		end: 0.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: '12'		to: #($1)		end: 1.	self		assert: parser		parse: 'a12'		to: #($a $1)		end: 2.	self		assert: parser		parse: 'ab12'		to: #($a $b $1)		end: 3.	self		assert: parser		parse: 'abc12'		to: #($a $b $c $1)		end: 4.	self		assert: parser		parse: '123'		to: #($1 $2)		end: 2.	self		assert: parser		parse: 'a123'		to: #($a $1 $2)		end: 3.	self		assert: parser		parse: 'ab123'		to: #($a $b $1 $2)		end: 4.	self		assert: parser		parse: 'abc123'		to: #($a $b $c $1 $2)		end: 5! !!PPParserTest methodsFor: 'testing'!testLiteralObjectCaseInsensitive	| parser |	parser := $a asParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'	! !!PPParserTest methodsFor: 'testing'!testWrapped	| parser |	parser := $a asParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.		parser := (($a asParser , $b asParser ) wrapped , $c asParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)! !!PPParserTest methodsFor: 'testing'!testMinMaxLazy	| parser |	parser := #word asParser min: 2 max: 4 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'! !!PPParserTest methodsFor: 'testing'!testOptional	| parser |	parser := $a asParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0! !!PPParserTest methodsFor: 'testing'!testMinMax	| parser printString suffix |	parser := $a asParser min: 2 max: 4.	self assert: parser min equals: 2.	self assert: parser max equals: 4.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).	self		assert: parser		parse: 'aaaaa'		to: #($a $a $a $a)		end: 4.	self		assert: parser		parse: 'aaaaaa'		to: #($a $a $a $a)		end: 4.	printString := parser printString.	suffix := printString copyFrom: printString size - 5 to: printString size.	self assert: suffix = '[2, 4]'! !!PPParserTest methodsFor: 'testing'!testXor	| parser |	parser := ($a asParser / $b asParser)			|  ($b asParser / $c asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'.		" truly symmetric "	parser := ($b asParser / $c asParser)			|  ($a asParser / $b asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'! !!PPParserTest methodsFor: 'testing'!testSeparatedByWithoutSeparators	| parser |	parser := ($a asParser separatedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing'!testSequence	| parser |	parser := $a asParser , $b asParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.	self assert: parser fail: 'ba'.	self assert: parser fail: 'bab'! !!PPParserTest methodsFor: 'testing'!testEndOfInputAfterMatch	| parser |	parser := 'stuff' asParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff'.	self assert: parser fail: 'fluff'! !!PPParserTest methodsFor: 'testing'!testTimes	| parser |	parser := $a asParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2! !!PPParserTest methodsFor: 'testing'!testEpsilon	| parser |	parser := nil asParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0! !!PPParserTest methodsFor: 'testing'!testMinMaxGreedy	| parser |	parser := #word asParser min: 2 max: 4 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc1234' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'! !!PPParserTest methodsFor: 'testing'!testSeparatedBy	| parser |	parser := $a asParser separatedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing'!testEndOfInput	| parser |	parser := PPEndOfInputParser on: $a asParser.	self assert: parser end equals: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa'! !!PPParserTest methodsFor: 'testing'!testMinGreedy	| parser |	parser := #word asParser min: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d $1) end: 5.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e $1) end: 6.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5.	self assert: parser parse: 'abcd123' to: #($a $b $c $d $1 $2) end: 6.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e $1 $2) end: 7.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2 $3) end: 5.	self assert: parser parse: 'abc1234' to: #($a $b $c $1 $2 $3) end: 6.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d $1 $2 $3) end: 7.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e $1 $2 $3) end: 8! !!PPParserTest methodsFor: 'testing'!testStar	| parser |	parser := $a asParser star.	self assert: parser min equals: 0.	self assert: parser max > parser min.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'b'		to: #()		end: 0.	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3! !!PPParserTest methodsFor: 'testing'!testMemoized	| count parser twice |	count := 0.	parser := [ :s | 	count := count + 1.	s next ] asParser memoized.	twice := parser and , parser.	count := 0.	self assert: parser parse: 'a' to: $a.	self assert: count equals: 1.	count := 0.	self assert: twice parse: 'a' to: #($a $a).	self assert: count equals: 1.	self assert: parser memoized equals: parser! !!PPParserTest methodsFor: 'testing'!testPluggable	| block parser |	block := [ :stream | stream position ].	parser := block asParser.	self assert: parser block equals: block! !!PPParserTest methodsFor: 'testing'!testMinLazy	| parser |	parser := #word asParser min: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e) end: 5! !!PPParserTest methodsFor: 'testing'!testAnd	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten and.	self		assert: parser		parse: 'foobar'		to: #('foo' 'bar')		end: 3.	self assert: parser fail: 'foobaz'.	parser := 'foo' asParser and.	self assert: parser and equals: parser! !!PPParserTest methodsFor: 'testing'!testPlus	| parser |	parser := $a asParser plus.	self assert: parser min equals: 1.	self assert: parser max > parser min.	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'! !!PPParserTest methodsFor: 'testing'!testLiteralObject	| parser |	parser := PPLiteralObjectParser on: $a message: 'letter "a" expected'.	self assert: parser literal equals: $a.	self assert: parser message equals: 'letter "a" expected'.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing'!testBlock	| parser |	parser := [ :s | s next ] asParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil! !!PPParserTest methodsFor: 'testing'!testMax	| parser printString suffix |	parser := $a asParser max: 2.	self assert: parser min equals: 0.	self assert: parser max equals: 2.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self		assert: parser		parse: 'aaa'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaaa'		to: #($a $a)		end: 2.	printString := parser printString.	suffix := printString copyFrom: printString size - 5 to: printString size.	self assert: suffix = '[0, 2]'! !!PPParserTest methodsFor: 'testing'!testDelimitedByWithoutSeparators	| parser |	parser := ($a asParser delimitedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).	self assert: parser parse: 'ab' to: #($a).	self assert: parser parse: 'abab' to: #($a $a).	self assert: parser parse: 'ababab' to: #($a $a $a).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a) end: 2.	self assert: parser parse: 'abac' to: #($a $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $a) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing'!testStarLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser starLazy: limit.	self assert: parser min equals: 0.	self assert: parser max > parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: '1'		to: #()		end: 0.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: '12'		to: #()		end: 0.	self		assert: parser		parse: 'a12'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab12'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc12'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: '123'		to: #()		end: 0.	self		assert: parser		parse: 'a123'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab123'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc123'		to: #($a $b $c)		end: 3! !!PPParserTest methodsFor: 'testing'!testFailing	| parser result |	parser := PPFailingParser message: 'Plonk'.	self assert: parser message equals: 'Plonk'.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.	result := parser parse: 'a'.	self assert: result message equals: 'Plonk'.	self assert: result printString equals: 'Plonk at 0'! !!PPParserTest methodsFor: 'testing'!testPlusLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusLazy: limit.	self assert: parser min equals: 1.	self assert: parser max > parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: 'a12'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab12'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc12'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: 'a123'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab123'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc123'		to: #($a $b $c)		end: 3! !!PPParserTest methodsFor: 'testing'!testDelimitedBy	| parser |	parser := $a asParser delimitedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing'!testMaxLazy	| parser |	parser := #word asParser max: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #() end: 0.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #() end: 0.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'! !!PPParserTest methodsFor: 'testing'!testPlusGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusGreedy: limit.	self assert: parser min equals: 1.	self assert: parser max > parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: 'a12'		to: #($a $1)		end: 2.	self		assert: parser		parse: 'ab12'		to: #($a $b $1)		end: 3.	self		assert: parser		parse: 'abc12'		to: #($a $b $c $1)		end: 4.	self		assert: parser		parse: 'a123'		to: #($a $1 $2)		end: 3.	self		assert: parser		parse: 'ab123'		to: #($a $b $1 $2)		end: 4.	self		assert: parser		parse: 'abc123'		to: #($a $b $c $1 $2)		end: 5! !!PPParserTest methodsFor: 'testing'!testChoice	| parser |	parser := $a asParser / $b asParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'! !!PPParserTest methodsFor: 'testing'!testNegate	| parser |	parser := 'foo' asParser negate.		self assert: parser parse: 'f' to: $f end: 1.	self assert: parser parse: 'fo' to: $f end: 1.	self assert: parser parse: 'fob' to: $f end: 1.	self assert: parser parse: 'ffoo' to: $f end: 1.		self assert: parser fail: ''.	self assert: parser fail: 'foo'! !!PPParserTest methodsFor: 'testing'!testNot	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar'! !!PPParserTest methodsFor: 'testing'!testMaxGreedy	| parser |	parser := #word asParser max: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #($1) end: 1.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'! !!PPParserTest methodsFor: 'testing'!testLiteralSequence	| parser |	parser := PPLiteralSequenceParser on: 'abc' message: 'sequence "abc" expected'.	self assert: parser size equals: 3.	self assert: parser literal equals: 'abc'.	self assert: parser message equals: 'sequence "abc" expected'.	self assert: parser parse: 'abc' to: 'abc'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!PPParserTest methodsFor: 'testing'!testMin	| parser printString suffix |	parser := $a asParser min: 2.	self assert: parser min equals: 2.	self assert: parser max > parser min.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).	printString := parser printString.	suffix := printString copyFrom: printString size - 5 to: printString size.	self assert: suffix = '[2, *]'! !!PPParserTest methodsFor: 'testing'!testUnresolved	| parser |	parser := PPUnresolvedParser new.		self assert: parser isUnresolved.	self should: [ parser parse: '' ] raise: Error.	self should: [ parser parse: 'a' ] raise: Error.	self should: [ parser parse: 'ab' ] raise: Error.		parser := nil asParser.	self deny: parser isUnresolved! !!PPParserTest methodsFor: 'testing'!testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!PPParserTest methodsFor: 'testing-fixtures'!testSideEffectListCopy	| old new |	old := $a asParser , $b asParser.	new := old copy.		self deny: old == new.	self deny: old children == new children.	self assert: old children first == new children first.	self assert: old children last == new children last! !!PPParserTest methodsFor: 'testing-fixtures'!testSideEffectSequence	"Adding another element to a sequence should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 , $b asParser.	p3 := p1 , $c asParser.		self assert: p1 parse: 'a'.		self assert: p1 parse: 'ab' end: 1.	self assert: p1 parse: 'ac' end: 1.		self assert: p2 fail: 'a'.		self assert: p2 parse: 'ab'.	self assert: p2 fail: 'ac'.	self assert: p3 fail: 'a'.		self assert: p3 fail: 'ab'.	self assert: p3 parse: 'ac'! !!PPParserTest methodsFor: 'testing-fixtures'!testSideEffectChoice	"Adding another element to a choice should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 / $b asParser.	p3 := p1 / $c asParser.		self assert: p1 parse: 'a'.	self assert: p1 fail: 'b'.	self assert: p1 fail: 'c'.		self assert: p2 parse: 'a'.	self assert: p2 parse: 'b'.	self assert: p2 fail: 'c'.		self assert: p3 parse: 'a'.	self assert: p3 fail: 'b'.	self assert: p3 parse: 'c'! !!PPParserTest methodsFor: 'testing-accessing'!testNamed	| parser |	parser := PPSequenceParser new.	self assert: parser name isNil.	parser := PPChoiceParser named: 'choice'.	self assert: parser name equals: 'choice'.	parser := $* asParser name: 'star'.	self assert: parser name equals: 'star'! !!PPParserTest methodsFor: 'testing-accessing'!testPrint	| parser |	parser := PPParser new.	self assert: parser printString includesSubstring: 'PPParser'.		parser := PPParser named: 'choice'.	self assert: parser printString includesSubstring: 'PPParser(choice'.		parser := PPLiteralObjectParser on: $a.	self assert: parser printString includesSubstring: $a printString.		parser := PPFailingParser message: 'error'.	self assert: parser printString includesSubstring: 'error'.		parser := PPPredicateObjectParser on: [ :c | true ] message: 'error'.	self assert: parser printString includesSubstring: 'error'! !!PPParserTest methodsFor: 'testing-utilities'!testMatchesIn	| parser result |	parser := $a asParser.	result := parser matchesIn: 'abba'.	self assert: result size equals: 2.	self assert: result first equals: $a.	self assert: result last equals: $a.	result := parser matchesIn: 'baaah'.	self assert: result size equals: 3.	self assert: result first equals: $a.	self assert: result last equals: $a! !!PPParserTest methodsFor: 'testing-utilities'!testListConstructor	| p1 p2 p3 |	p1 := PPChoiceParser with: $a asParser.	p2 := PPChoiceParser with: $a asParser with: $b asParser.	p3 := PPChoiceParser withAll: (Array with: $a asParser with: $b asParser with: $c asParser).	self assert: p1 children size equals: 1.	self assert: p2 children size equals: 2.	self assert: p3 children size equals: 3! !!PPParserTest methodsFor: 'testing-utilities'!testMatchingSkipRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingSkipRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size equals: 2.	self assert: result first equals: '12'.	self assert: result last equals: '3'! !!PPParserTest methodsFor: 'testing-utilities'!testMatchingRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size equals: 3.	self assert: result first equals: '12'.	self assert: result second equals: '2'.	self assert: result last equals: '3'! !!PPParserTest methodsFor: 'testing-utilities'!testParseOnError2	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result equals: $a.	result := parser		parse: 'b'		onError: [ :msg :pos | 			self assert: msg includesSubstring: $a printString.			self assert: msg includesSubstring: 'expected'.			self assert: pos equals: 0.			seen := true ].	self assert: result.	self assert: seen! !!PPParserTest methodsFor: 'testing-utilities'!testChildren	| p1 p2 p3 |	p1 := #lowercase asParser.	p2 := p1 ==> #asUppercase.	p3 := PPUnresolvedParser new.	p3 def: p2 / p3.	self assert: p1 children isEmpty.	self assert: p2 children size equals: 1.	self assert: p3 children size equals: 2! !!PPParserTest methodsFor: 'testing-utilities'!testMatchesSkipIn	| parser result |	parser := $a asParser.	result := parser matchesSkipIn: 'abba'.	self assert: result size equals: 2.	self assert: result first equals: $a.	self assert: result last equals: $a.	result := parser matchesSkipIn: 'baaah'.	self assert: result size equals: 3.	self assert: result first equals: $a.	self assert: result last equals: $a! !!PPParserTest methodsFor: 'testing-utilities'!testParse	| parser result |	parser := $a asParser.	self assert: (parser parse: 'a') equals: $a.	self assert: (result := parser parse: 'b') isPetitFailure.	self assert: result message includesSubstring: $a printString.	self assert: result message includesSubstring: 'expected'.	self assert: result position equals: 0.	self assert: (parser parse: 'a' readStream) equals: $a.	self assert: (result := parser parse: 'b' readStream) isPetitFailure.	self assert: result message includesSubstring: $a printString.	self assert: result message includesSubstring: 'expected'.	self assert: result position equals: 0! !!PPParserTest methodsFor: 'testing-utilities'!testParseOnError0	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result equals: $a.	result := parser parse: 'b' onError: [ seen := true ].	self assert: result.	self assert: seen! !!PPParserTest methodsFor: 'testing-utilities'!testParser	| parser |	parser := PPParser new.		self assert: parser isPetitParser.	self deny: 4 isPetitParser.	self deny: 'foo' isPetitParser! !!PPParserTest methodsFor: 'testing-utilities'!testMatchesSkipInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.	result := parser matchesSkipIn: 'a123b'.	self assert: result size equals: 1.	self assert: result first equals: #($1 $2)! !!PPParserTest methodsFor: 'testing-utilities'!testMatchesInEmpty	"Empty matches should properly advance and match at each position and at the end."	| parser result |	parser := [ :stream | stream position ] asParser.	result := parser matchesIn: '123'.	self assert: result asArray equals: #(0 1 2 3)! !!PPParserTest methodsFor: 'testing-utilities'!testParseOnError1	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result equals: $a.	result := parser		parse: 'b'		onError: [ :failure | 			self assert: failure position equals: 0.			self assert: failure message includesSubstring: $a printString.			self assert: failure message includesSubstring: 'expected'.			seen := true ].	self assert: result.	self assert: seen! !!PPParserTest methodsFor: 'testing-utilities'!testMatchesInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.	result := parser matchesIn: 'a123b'.	self assert: result size equals: 2.	self assert: result first equals: #($1 $2).	self assert: result last equals: #($2 $3)! !!PPParserTest methodsFor: 'testing-utilities'!testMatches	| parser |	parser := $a asParser.		self assert: (parser matches: 'a').	self deny: (parser matches: 'b').		self assert: (parser matches: 'a' readStream).	self deny: (parser matches: 'b' readStream)! !!PPParserTest methodsFor: 'testing-utilities'!testFailure	| failure |	failure := PPFailure message: 'Error' context: PPContext new at: 3.	self assert: failure message equals: 'Error'.	self assert: failure position equals: 3.	self assert: failure isPetitFailure.	self deny: 4 isPetitFailure.	self deny: 'foo' isPetitFailure! !!PPParserTest methodsFor: 'testing-properties'!testRemovePropertyIfAbsent	| parser |	parser := PPParser new.	self assert: (parser removeProperty: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo ifAbsent: [ false ])! !!PPParserTest methodsFor: 'testing-properties'!testPropertyAtIfAbsent	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo ifAbsent: [ false ])! !!PPParserTest methodsFor: 'testing-properties'!testPropertyAt	| parser |	parser := PPParser new.	self should: [ parser propertyAt: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo)! !!PPParserTest methodsFor: 'testing-properties'!testRemoveProperty	| parser |	parser := PPParser new.	self should: [ parser removeProperty: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo)! !!PPParserTest methodsFor: 'testing-properties'!testPropertyAtIfAbsentPut	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsentPut: [ true ]).	self assert: (parser propertyAt: #foo ifAbsentPut: [ false ])! !!PPParserTest methodsFor: 'testing-properties'!testPostCopy	| parser copy |	parser := PPParser new.	parser propertyAt: #foo put: true.	copy := parser copy.	copy propertyAt: #foo put: false.	self assert: (parser propertyAt: #foo).	self deny: (copy propertyAt: #foo)! !!PPParserTest methodsFor: 'testing-properties'!testHasProperty	| parser |	parser := PPParser new.	self deny: (parser hasProperty: #foo).	parser propertyAt: #foo put: 123.	self assert: (parser hasProperty: #foo)! !PPAbstractParserTest subclass: #PPPredicateTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPPredicateTest methodsFor: 'utilities'!parsedCharacterSet: aParser	| result |	result := WriteStream on: String new.	self charactersDo: [ :char |		(aParser matches: (char asString))			ifTrue: [ result nextPut: char ] ].	^ result contents! !!PPPredicateTest methodsFor: 'utilities'!assertCharacterSets: aParser	"Assert the character set of aParser does not overlap with the character set with the negated parser, and that they both cover the complete character space."	| positives negatives |	positives := self parsedCharacterSet: aParser.	negatives := self parsedCharacterSet: aParser negate.	self charactersDo: [ :char | 		| positive negative |		positive := positives includes: char.		negative := negatives includes: char.		self 			assert: ((positive and: [ negative not ])				or: [ positive not and: [ negative ] ])			description: char printString , ' should be in exactly one set' ]! !!PPPredicateTest methodsFor: 'testing-sequence'!testSequenceParser	| parser |	parser := PPPredicateSequenceParser		on: [ :value | value first isUppercase ]		message: 'uppercase 3 letter words'		size: 3.	self assert: parser size equals: 3.	self assert: parser parse: 'Abc'.	self assert: parser parse: 'ABc'.	self assert: parser parse: 'ABC'.	self assert: parser fail: 'abc'.	self assert: parser fail: 'aBC'.	self assert: parser fail: 'Ab'.	parser := parser negate.	self assert: parser size equals: 3.	self assert: parser fail: 'Abc'.	self assert: parser fail: 'ABc'.	self assert: parser fail: 'ABC'.	self assert: parser parse: 'abc'.	self assert: parser parse: 'aBC'.	self assert: parser fail: 'Ab'! !!PPPredicateTest methodsFor: 'testing'!testOnMessage	| block parser |	block := [ :char | char = $* ].	parser := PPPredicateObjectParser on: block message: 'starlet'.	self assert: parser block equals: block.	self assert: parser message equals: 'starlet'.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self		assert: parser		parse: '**'		to: $*		end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-objects'!testAnyOf	| parser |	parser := PPPredicateObjectParser anyOf: #($a $z).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: 'x'! !!PPPredicateTest methodsFor: 'testing-objects'!testAny	| parser |	parser := #any asParser.	self assertCharacterSets: parser.	self assert: parser parse: ' ' to: $ .	self assert: parser parse: '1' to: $1.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''! !!PPPredicateTest methodsFor: 'testing-objects'!testAnyExceptAnyOf	| parser |	parser := PPPredicateObjectParser anyExceptAnyOf: #($: $,).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ':'.	self assert: parser fail: ','! !!PPPredicateTest methodsFor: 'testing-objects'!testExpect	| parser |	parser := PPPredicateObjectParser expect: $a.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.	self assert: parser fail: ''! !!PPPredicateTest methodsFor: 'testing-objects'!testBetweenAnd	| parser |	parser := PPPredicateObjectParser between: $b and: $d.	self assertCharacterSets: parser.	self assert: parser fail: 'a'.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser parse: 'd' to: $d.	self assert: parser fail: 'e'! !!PPPredicateTest methodsFor: 'testing-chars'!testUppercase	| parser |	parser := #uppercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '0'! !!PPPredicateTest methodsFor: 'testing-chars'!testSpace	| parser |	parser := #space asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser parse: ' ' to: Character space.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars'!testCr	| parser |	parser := #cr asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: (Character codePoint: 13)) to: (Character codePoint: 13)! !!PPPredicateTest methodsFor: 'testing-chars'!testBlank	| parser |	parser := #blank asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character space) to: Character space.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: (String with: Character cr)! !!PPPredicateTest methodsFor: 'testing-chars'!testStartOfLine	| cr crlf lf parser |	cr := Character cr asString.	crlf := Character cr asString , Character lf asString.	lf := Character lf asString.	parser := #startOfLine asParser, #any asParser star.		self assert: parser parse: 'lorem ipsum'.		parser := #any asParser, #startOfLine asParser, #any asParser star.	self assert: parser fail: 'lorem ipsum'.		parser := #startOfLine asParser, #any asParser, #startOfLine asParser, #any asParser star.	self assert: parser parse: cr, 'lorem ipsum'.	self assert: parser parse: lf, 'lorem ipsum'.		self assert: parser fail: crlf, 'lorem ipsum'.			self assert: parser fail: crlf.	self assert: parser parse: cr.	self assert: parser parse: lf.		parser := #startOfLine asParser, #any asParser, #any asParser, #startOfLine asParser, #any asParser star.	self assert: parser parse: crlf, 'lorem ipsum'.	self assert: parser parse: crlf.! !!PPPredicateTest methodsFor: 'testing-chars'!testNewline	| parser |	parser := #newline asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character cr) to: Character cr.	self assert: parser parse: (String with: Character lf) to: Character lf.	self assert: parser fail: ' '! !!PPPredicateTest methodsFor: 'testing-chars'!testStartOfLogicalLine	| parser |	parser := #startOfLogicalLine asParser, #any asParser star.		self assert: parser parse: 'lorem'.	self assert: parser fail: ' lorem'.		parser := #any asParser, #startOfLogicalLine asParser, #any asParser star.	self assert: parser fail: 'lorem'.	self assert: parser fail: '        lorem'.	self assert: parser parse: ' lorem'.	self assert: parser parse: '	lorem'.! !!PPPredicateTest methodsFor: 'testing-chars'!testLf	| parser |	parser := #lf asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character lf) to: Character lf! !!PPPredicateTest methodsFor: 'testing-chars'!testLowercase	| parser |	parser := #lowercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.	self assert: parser fail: 'A'.	self assert: parser fail: '0'! !!PPPredicateTest methodsFor: 'testing-chars'!testStartOfWord	| parser |	parser := #startOfWord asParser, #word asParser plus.		self assert: parser parse: 'lorem'.		parser := #any asParser, #startOfWord asParser, #word asParser plus.	self assert: parser fail: 'lorem'.	self assert: parser fail: '1234'.		self assert: parser parse: ' lorem'.		self assert: parser parse: ' 123'.	self assert: parser parse: ')lorem'.	self assert: parser parse: ':lorem'.		parser := #startOfWord asParser, #any asParser optional.	self assert: parser fail: ''.	self assert: parser parse: 'a'.	self assert: parser fail: '.'.! !!PPPredicateTest methodsFor: 'testing-chars'!testEndOfFile	| parser |	parser := (#letter asParser / #blank asParser) star, #eof asParser.		self assert: parser parse: 'lorem ipsum'.		parser := #any asParser, #eof asParser, #any asParser star.	self assert: parser fail: 'a', Character cr asString, 'b'.	self assert: parser fail: Character cr asString , Character lf asString.	self assert: parser parse: 'a'.! !!PPPredicateTest methodsFor: 'testing-chars'!testLetter	| parser |	parser := #letter asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: '0'! !!PPPredicateTest methodsFor: 'testing-chars'!testTab	| parser |	parser := #tab asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab! !!PPPredicateTest methodsFor: 'testing-chars'!testHex	| parser |	parser := #hex asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '5' to: $5.	self assert: parser parse: '9' to: $9.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'D' to: $D.	self assert: parser parse: 'F' to: $F.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'e' to: $e.	self assert: parser parse: 'f' to: $f.	self assert: parser fail: ''.	self assert: parser fail: 'g'! !!PPPredicateTest methodsFor: 'testing-chars'!testChar	| parser |	parser := $* asParser.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars'!testDigit	| parser |	parser := #digit asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars'!testPunctuation	| parser |	parser := #punctuation asParser.	self assertCharacterSets: parser.	self assert: parser parse: '.' to: $..	self assert: parser parse: ',' to: $,.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '1'! !!PPPredicateTest methodsFor: 'testing-chars'!testEndOfLine	| cr crlf lf parser |	cr := Character cr asString.	crlf := Character cr asString , Character lf asString.	lf := Character lf asString.	parser := (#letter asParser / #blank asParser) star, #endOfLine asParser.		self assert: parser parse: 'lorem ipsum'.		parser := #any asParser, #endOfLine asParser, #any asParser star.	self assert: parser parse: 'a', cr, 'b'.	self assert: parser fail: crlf.	self assert: parser fail: 'lorem ipsum'.		parser := #endOfLine asParser, #any asParser, #endOfLine asParser negate star, #endOfLine asParser.	self assert: parser parse: cr, 'lorem ipsum'.	self assert: parser parse: lf, 'lorem ipsum'.		self assert: parser parse: crlf, 'lorem ipsum'.			self assert: parser parse: crlf.	self assert: parser parse: cr.	self assert: parser parse: lf.		parser := #endOfLine asParser negate star, #endOfLine asParser, #any asParser star.	self assert: parser parse: crlf, 'lorem ipsum'.	self assert: parser parse: crlf.! !!PPPredicateTest methodsFor: 'testing-chars'!testWord	| parser |	parser := #word asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: '0' to: $0.	self assert: parser fail: ''.	self assert: parser fail: '-'! !!PPPredicateTest methodsFor: 'private'!charactersDo: aBlock	1 to: 256 do: [ :index | aBlock value: (Character codePoint: index) ]! !PPAbstractParserTest subclass: #PPScriptingTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPScriptingTest commentStamp: '' prior: 0!These are some simple demo-scripts of parser combinators for the compiler construction course.http://www.iam.unibe.ch/~scg/Teaching/CC/index.html!!PPScriptingTest methodsFor: 'examples'!straightLineParser	| goal stm stmList id char dec exp expList mulExp primExp nonzero num lower upper |	goal := PPUnresolvedParser new.	stmList := PPUnresolvedParser new.	stm := PPUnresolvedParser new.	exp := PPUnresolvedParser new.	expList := PPUnresolvedParser new.	mulExp := PPUnresolvedParser new.	primExp := PPUnresolvedParser new.		lower := ($a to: $z) asParser.	upper := ($A to: $Z) asParser.	char := lower / upper.	nonzero := ($1 to: $9) asParser.	dec := ($0 to: $9) asParser.	id := char, ( char / dec ) star.	num := $0 asParser / ( nonzero, dec star).	goal def: stmList end.	stmList def: stm , ( $; asParser, stm ) star.	stm def: ( id, ':=' asParser, exp )		/ ( 'print' asParser, $( asParser, expList, $) asParser ). 	exp def: mulExp, ( ( $+ asParser / $- asParser ), mulExp ) star.	expList def: exp, ( $, asParser, exp ) star.	mulExp def: primExp, ( ( $* asParser / $/ asParser ), primExp ) star.	primExp def: id		/ num		/ ( $( asParser, stmList, $, asParser, exp, $) asParser ).	^ goal! !!PPScriptingTest methodsFor: 'examples'!expressionInterpreter	"Same as #expressionInterpreter but with semantic actions."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 to: $9) asParser ==> [ :token | token codePoint - $0 codePoint ].	add def: ((mul , $+ asParser , add) ==> [ :nodes | (nodes at: 1) + (nodes at: 3) ])		/ mul.	mul def: ((prim , $* asParser , mul) ==> [ :nodes | (nodes at: 1) * (nodes at: 3) ])		/ prim.	prim def: (($( asParser , add , $) asParser) ==> [ :nodes | nodes at: 2 ])		/ dec.	^ add end! !!PPScriptingTest methodsFor: 'examples'!expressionParser	"Simple demo of scripting an expression parser."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 to: $9) asParser.	add def: (mul , $+ asParser , add)		/ mul.	mul def: (prim , $* asParser , mul)		/ prim.	prim def: ($( asParser , add , $) asParser)		/ dec.	^ add end! !!PPScriptingTest methodsFor: 'tests'!testExpressionInterpreter	self 		assert: self expressionInterpreter		parse: '2*(3+4)'		to: 14! !!PPScriptingTest methodsFor: 'tests'!testSLassign		self assert: self straightLineParser		parse: 'abc:=1'		to: #(#($a #($b $c) ':=' #(#(#($1 #()) #()) #())) #())! !!PPScriptingTest methodsFor: 'tests'!testSLprint	self 		assert: self straightLineParser		parse: 'print(3,4)'		to: #(('print' $( ((($3 ()) ()) () (($, ((($4 ()) ()) ())))) $)) ())! !!PPScriptingTest methodsFor: 'tests'!testExpressionParser	self		assert: self expressionParser		parse: '2*(3+4)'		to: #($2 $* ($( ($3 $+ $4) $)))! !PPAbstractParserTest subclass: #PPTokenTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Tests'!!PPTokenTest methodsFor: 'testing-querying'!testColumn	| input parser result |	input := '1' , (String with: (Character codePoint: 13)) , '12' , (String with: (Character codePoint: 13) with: (Character codePoint: 10)) , '123'		, (String with: (Character codePoint: 10)) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result with: #(1 2 1 2 3 4 1 2 3 4 1 2 3 4) do: [ :token :line | self assert: token column equals: line ]! !!PPTokenTest methodsFor: 'testing-querying'!testLine	| input parser result |	input := '1' , (String with: (Character codePoint: 13)) , '12' , (String with: (Character codePoint: 13) with: (Character codePoint: 10)) , '123'		, (String with: (Character codePoint: 10)) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result with: #(1 1 2 2 2 2 3 3 3 3 4 4 4 4) do: [ :token :line | self assert: token line equals: line ]! !!PPTokenTest methodsFor: 'accessing'!identifier	^ #word asParser plus token! !!PPTokenTest methodsFor: 'testing'!testSize	| result |	result := self parse: 'foo' using: self identifier.	self assert: result size equals: 3! !!PPTokenTest methodsFor: 'testing'!testStart	| result |	result := self parse: 'foo' using: self identifier.	self assert: result start equals: 1! !!PPTokenTest methodsFor: 'testing'!testInitialize	PPToken initialize! !!PPTokenTest methodsFor: 'testing'!testStop	| result |	result := self parse: 'foo' using: self identifier.	self assert: result stop equals: 3! !!PPTokenTest methodsFor: 'testing'!testCollection	| input result |	input := 'foo    '.	result := self parse: input using: self identifier.	self assert: result collection equals: input.	self assert: result collection == input! !!PPTokenTest methodsFor: 'testing'!testNew	self should: [ PPToken new ] raise: Error.	! !!PPTokenTest methodsFor: 'testing'!testValue	| result |	result := PPToken on: 'var'.	self should: [ result value ] raise: Notification! !!PPTokenTest methodsFor: 'testing'!testPrinting	| result |	result := PPToken on: 'var'.	self assert: result printString includesSubstring: 'PPToken[1,3]'! !!PPTokenTest methodsFor: 'testing-comparing'!testEquality	| token1 token2 |	token1 := self parse: 'foo' using: self identifier.	token2 := self parse: 'foo' using: self identifier.	self deny: token1 == token2.	self assert: token1 equals: token2.	self assert: token1 hash equals: token2 hash! !!PPTokenTest methodsFor: 'testing-copying'!testCopyFromTo	| result other |	result := PPToken on: 'abc'.	other := result copyFrom: 2 to: 2.	self assert: other size equals: 1.	self assert: other start equals: 2.	self assert: other stop equals: 2.	self assert: other collection equals: result collection! !!PPTokenTest methodsFor: 'testing-values'!testInputValue	| input result |	input := 'foo'.	result := self parse: input using: self identifier.	self assert: result inputValue equals: input.	self deny: result inputValue == input! !!PPTokenTest methodsFor: 'testing-values'!testParsedValue	| input result |	input := 'foo'.	result := self parse: input using: self identifier.	self assert: result parsedValue equals: #($f $o $o)! !!PPTokenTest methodsFor: 'utilities'!parse: aString using: aParser	^ aParser parse: aString! !PPCompositeParser subclass: #PPArithmeticParser	instanceVariableNames: 'terms addition factors multiplication power primary parentheses number'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Examples'!!PPArithmeticParser methodsFor: 'grammar'!parentheses	^ $( asParser trim , terms , $) asParser trim		==> [ :nodes | nodes at: 2 ]! !!PPArithmeticParser methodsFor: 'grammar'!number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten trim 		==> [ :value | value asNumber ]! !!PPArithmeticParser methodsFor: 'grammar'!terms	^ addition / factors! !!PPArithmeticParser methodsFor: 'grammar'!multiplication	^ (power separatedBy: ($* asParser / $/ asParser) trim)		foldLeft: [ :a :op :b | a perform: op asSymbol with: b ]! !!PPArithmeticParser methodsFor: 'grammar'!power	^ (primary separatedBy: $^ asParser trim)		foldRight: [ :a :op :b | a raisedTo: b ]! !!PPArithmeticParser methodsFor: 'grammar'!addition	^ (factors separatedBy: ($+ asParser / $- asParser) trim) 		foldLeft: [ :a :op :b | a perform: op asSymbol with: b ]! !!PPArithmeticParser methodsFor: 'grammar'!primary	^ number / parentheses! !!PPArithmeticParser methodsFor: 'grammar'!factors	^ multiplication / power! !!PPArithmeticParser methodsFor: 'accessing'!start	^ terms end! !PPCompositeParser subclass: #PPLambdaParser	instanceVariableNames: 'expression abstraction application variable'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitTests-Examples'!!PPLambdaParser methodsFor: 'productions'!application	^ $( asParser trim , expression , expression , $) asParser trim 			==> [ :node | Array with: (node at: 2) with: (node at: 3) ]! !!PPLambdaParser methodsFor: 'productions'!abstraction	^ $\ asParser trim , variable , $. asParser trim , expression 		==> [ :node | Array with: (node at: 2) with: (node at: 4) ]! !!PPLambdaParser methodsFor: 'productions'!expression	^ variable / abstraction / application! !!PPLambdaParser methodsFor: 'productions'!variable	^ (#letter asParser , #word asParser star) flatten trim! !!PPLambdaParser methodsFor: 'accessing'!start	^ expression end! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPLambdaParser class	instanceVariableNames: ''!!PPLambdaParser class methodsFor: 'curch-booleans'!and	^ self parse: '\p.\q.((p q) p)'! !!PPLambdaParser class methodsFor: 'curch-booleans'!true	^ self parse: '\x.\y.x'! !!PPLambdaParser class methodsFor: 'curch-booleans'!not	^ self parse: '\p.\a.\b.((p b) a)'! !!PPLambdaParser class methodsFor: 'curch-booleans'!ifthenelse	^ self parse: '\p.p'! !!PPLambdaParser class methodsFor: 'curch-booleans'!false	^ self parse: '\x.\y.y'! !!PPLambdaParser class methodsFor: 'curch-booleans'!or	^ self parse: '\p.\q.((p p) q)'! !