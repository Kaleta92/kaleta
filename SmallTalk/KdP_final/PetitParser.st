Object subclass: #PPParser	instanceVariableNames: 'properties'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPParser commentStamp: '' prior: 0!An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.Instance Variables:	properties	<Dictionary>	Stores additional state in the parser object.!!PPParser methodsFor: 'context'!parseWithContext: context	| result |	context initializeFor: self.	result := self parseOn: context.		"Return the furthest failure, it gives better results than the last failure"	(result isPetitFailure and: [ context furthestFailure notNil]) 		ifTrue: [ ^ context furthestFailure ].	^ result	! !!PPParser methodsFor: 'context'!parse: anObject withContext: aPPContext	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."	aPPContext stream: anObject asPetitStream.	^ self parseWithContext: aPPContext.! !!PPParser methodsFor: 'converting'!asParser	"Answer the receiving parser."		^ self! !!PPParser methodsFor: 'parsing'!matchesSkipIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of the matched parse-trees. Skip over matches."	| result |	result := OrderedCollection new.	self 		matchesSkipIn: anObject		do: [ :each | result addLast: each ].	^ result! !!PPParser methodsFor: 'parsing'!matchingRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingRangesIn: anObject		do: [ :value | result addLast: value ].	^ result! !!PPParser methodsFor: 'parsing'!matchingSkipRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Evaluate aBlock with the range of each match (index of first character to: index of last character)."		self token		matchesSkipIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]! !!PPParser methodsFor: 'parsing'!matches: anObject	"Answer if anObject can be parsed by the receiver."		^ (self parse: anObject) isPetitFailure not! !!PPParser methodsFor: 'parsing'!matchingRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock with the range of each match (index of first character to: index of last character)."	self token		matchesIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]! !!PPParser methodsFor: 'parsing'!parse: anObject	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."	^ self parse: anObject withContext: PPContext new! !!PPParser methodsFor: 'parsing'!matchesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answered an OrderedCollection of the matched parse-trees."	| result |	result := OrderedCollection new.	self 		matchesIn: anObject		do: [ :each | result addLast: each ].	^ result! !!PPParser methodsFor: 'parsing'!matchesSkipIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Skip over matches."	(self ==> aBlock / #any asParser) star parse: anObject! !!PPParser methodsFor: 'parsing'!matchesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Make sure to always consume exactly one character with each step, to not miss any match."	((self and ==> aBlock , #any asParser) / #any asParser) star parse: anObject! !!PPParser methodsFor: 'parsing'!parse: anObject onError: aBlock	"Parse anObject with the receiving parser and answer the parse-result or answer the result of evaluating aBlock. Depending on the number of arguments of the block it is simply evaluated, evaluated with the failure object, or evaluated with the error message and position."		| result |	result := self parse: anObject.	result isPetitFailure		ifFalse: [ ^ result ].	aBlock numArgs = 0		ifTrue: [ ^ aBlock value ].	aBlock numArgs = 1		ifTrue: [ ^ aBlock value: result ].	^ aBlock value: result message value: result position! !!PPParser methodsFor: 'parsing'!parseOn: aPPContext	"Parse aStream with the receiving parser and answer the parse-result or an instance of PPFailure. Override this method in subclasses to specify custom parse behavior. Do not call this method from outside, instead use #parse:."		self subclassResponsibility! !!PPParser methodsFor: 'parsing'!matchingSkipRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingSkipRangesIn: anObject		do: [ :value | result addLast: value ].	^ result! !!PPParser methodsFor: 'printing'!printNameOn: aStream	self name isNil		ifTrue: [ aStream print: self hash ]		ifFalse: [ aStream nextPutAll: self name ]! !!PPParser methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameOn: aStream.	aStream nextPut: $)! !!PPParser methodsFor: '*PetitAnalyzer'!cycleSet	"Answer a set of all nodes that are within one or more cycles of left-recursion. This is generally not a problem if at least one of the nodes is memoized, but it might make the grammar very inefficient and should be avoided if possible."		| cycles |	cycles := IdentitySet new.	self cycleSet: OrderedCollection new firstSets: self firstSets into: cycles.	^ cycles! !!PPParser methodsFor: '*PetitAnalyzer'!followSets: aFollowDictionary firstSets: aFirstDictionary into: aSet	"PRIVATE: Try to add additional elements to the follow-set aSet of the receiver, use the incomplete aFollowDictionary and the complete aFirstDictionary."		self children do: [ :parser | (aFollowDictionary at: parser) addAll: aSet ]! !!PPParser methodsFor: '*PetitAnalyzer'!isTerminal	"Answer true if the receiver is a terminal or leaf parser, that means it does not delegate to any other parser."	^ self children isEmpty! !!PPParser methodsFor: '*PetitAnalyzer'!followSets	"Answer a dictionary with all the parsers reachable from the receiver as key and their follow-set as value. The follow-set of a parser is the list of terminal parsers that can appear immediately to the right of that parser."		| current previous continue firstSets followSets |	current := previous := 0.	firstSets := self firstSets.	followSets := IdentityDictionary new.	self allParsersDo: [ :each | followSets at: each put: IdentitySet new ].	(followSets at: self) add: PPSentinel instance.	[	followSets keysAndValuesDo: [ :parser :follow |			parser 				followSets: followSets				firstSets: firstSets				into: follow ].		current := followSets			inject: 0			into: [ :result :each | result + each size ].		continue := previous < current.		previous := current.		continue ] whileTrue.	^ followSets! !!PPParser methodsFor: '*PetitAnalyzer'!namedChildren	"Answer the named children of the receiver."	| result |	result := OrderedCollection new.	self namedChildrenDo: [ :parser | result addLast: parser ].	^ result! !!PPParser methodsFor: '*PetitAnalyzer'!allNamedParsersDo: aBlock	"Iterate over all the named parse nodes of the receiver."	self allParsersDo: [ :each | 		each name notNil			ifTrue: [ aBlock value: each ] ]! !!PPParser methodsFor: '*PetitAnalyzer'!firstSet	"Answer the first-set of the receiver. Note, this implementation is inefficient when called on different receivers of the same grammar, instead use #firstSets to calculate the first-sets at once."		^ self firstSets at: self! !!PPParser methodsFor: '*PetitAnalyzer'!copyInContext: aDictionary	^ self copyInContext: aDictionary seen: IdentityDictionary new! !!PPParser methodsFor: '*PetitAnalyzer'!cycleSet: aDictionary	"PRIVATE: Answer the children that could be part of a cycle-set with the receiver, subclasses might restrict the number of children returned. aDictionary is pre-calcualted first-sets."	^ self children! !!PPParser methodsFor: '*PetitAnalyzer'!innerChildren	"Answer the inner children of the receiver."	| result |	result := OrderedCollection new.	self innerChildrenDo: [ :parser | result addLast: parser ].	^ result! !!PPParser methodsFor: '*PetitAnalyzer'!innerChildrenDo: aBlock	"Iterate over the inner children of the receiver."	self innerChildrenDo: aBlock seen: IdentitySet new! !!PPParser methodsFor: '*PetitAnalyzer'!followSet	"Answer the follow-set of the receiver starting at the receiver. Note, this implementation is inefficient when called on different receivers of the same grammar, instead use #followSets to calculate the follow-sets at once."	^ self followSets at: self! !!PPParser methodsFor: '*PetitAnalyzer'!firstSets: aFirstDictionary into: aSet	"PRIVATE: Try to add additional elements to the first-set aSet of the receiver, use the incomplete aFirstDictionary."	self children do: [ :parser | aSet addAll: (aFirstDictionary at: parser) ]! !!PPParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary seen: anIdentitySet	"This is the default implementation to match two parsers. This code can properly handle recursion. This is code is supposed to be overridden in subclasses that add new state."	(self == aParser or: [ anIdentitySet includes: self ])		ifTrue: [ ^ true ].	anIdentitySet add: self.	^ self class = aParser class and: [ self matchList: self children against: aParser children inContext: aDictionary seen: anIdentitySet ]! !!PPParser methodsFor: '*PetitAnalyzer'!matchList: matchList against: parserList inContext: aDictionary seen: aSet	^ self matchList: matchList index: 1 against: parserList index: 1 inContext: aDictionary seen: aSet! !!PPParser methodsFor: '*PetitAnalyzer'!matchList: matchList index: matchIndex against: parserList index: parserIndex inContext: aDictionary seen: aSet	| parser currentIndex currentDictionary currentSeen parsers |	matchList size < matchIndex		ifTrue: [ ^ parserList size < parserIndex ].	parser := matchList at: matchIndex.	parser class = PPListPattern ifTrue: [		currentIndex := parserIndex - 1.		[ currentDictionary := aDictionary copy.		currentSeen := aSet copy.		parserList size < currentIndex or: [ 			parsers := parserList copyFrom: parserIndex to: currentIndex.			(currentDictionary at: parser ifAbsentPut: [ parsers ]) = parsers and: [ 				(self					matchList: matchList					index: matchIndex + 1					against: parserList					index: currentIndex + 1					inContext: currentDictionary					seen: currentSeen)					ifTrue: [ 						currentDictionary keysAndValuesDo: [ :key :value | aDictionary at: key put: value ].						^ true ].				false ] ] ] whileFalse: [ currentIndex := currentIndex + 1 ].		^ false ].	parserList size < parserIndex		ifTrue: [ ^ false ].	(parser match: (parserList at: parserIndex) inContext: aDictionary seen: aSet)		ifFalse: [ ^ false ].	^ self		matchList: matchList		index: matchIndex + 1		against: parserList		index: parserIndex + 1		inContext: aDictionary		seen: aSet! !!PPParser methodsFor: '*PetitAnalyzer'!copyInContext: aDictionary seen: aSeenDictionary	| copy |	aSeenDictionary 		at: self 		ifPresent: [ :value | ^ value ].	copy := aSeenDictionary		at: self		put: self copy.	copy children do: [ :each |		copy			replace: each			with: (each copyInContext: aDictionary seen: aSeenDictionary) ].	^ copy! !!PPParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary	^ self match: aParser inContext: aDictionary seen: IdentitySet new! !!PPParser methodsFor: '*PetitAnalyzer'!allNamedParsers	"Answer all the named parse nodes of the receiver."	| result |	result := OrderedCollection new.	self allNamedParsersDo: [ :parser | result addLast: parser ].	^ result! !!PPParser methodsFor: '*PetitAnalyzer'!namedChildrenDo: aBlock	"Iterate over the named children of the receiver."	self namedChildrenDo: aBlock seen: IdentitySet new! !!PPParser methodsFor: '*PetitAnalyzer'!namedChildrenDo: aBlock seen: aSet	"Iterate over the named children of the receiver."		self children do: [ :each |		(aSet includes: each)			ifTrue: [ ^ self ].		aSet add: each.		each name isNil			ifTrue: [ each namedChildrenDo: aBlock seen: aSet ]			ifFalse: [ aBlock value: each ] ]! !!PPParser methodsFor: '*PetitAnalyzer'!replace: aParser with: anotherParser	"Replace the references of the receiver pointing to aParser with anotherParser."! !!PPParser methodsFor: '*PetitAnalyzer'!cycleSet: aStack firstSets: aDictionary into: aSet	"PRIVATE: Try to find a cycle, where aStack contains the previously visited parsers. The method returns quickly when the receiver is a terminal, terminals cannot be part of a cycle. If aStack already contains the receiver, then we are in a cycle. In this case we don't process the children further and add the nodes to aSet."	| index |	self isTerminal		ifTrue: [ ^ self ].		(index := aStack indexOf: self) > 0		ifTrue: [ ^ aSet addAll: (aStack copyFrom: index to: aStack size) ].	aStack addLast: self.	(self cycleSet: aDictionary)		do: [ :each | each cycleSet: aStack firstSets: aDictionary into: aSet ].	aStack removeLast! !!PPParser methodsFor: '*PetitAnalyzer'!isNullable	"Answer true if the receiver is a nullable parser, e.g. it can successfully parse nothing."		^ false! !!PPParser methodsFor: '*PetitAnalyzer'!firstSets	"Answer a dictionary with all the parsers reachable from the receiver as key and their first-set as value. The first-set of a parser is the list of terminal parsers that begin the parser derivable from that parser."		| firstSets |	firstSets := IdentityDictionary new.	self allParsersDo: [ :each |		firstSets at: each put: (each isFirstSetTerminal			ifTrue: [ IdentitySet with: each ]			ifFalse: [ IdentitySet new ]).		each isNullable			ifTrue: [ (firstSets at: each) add: PPSentinel instance ] ].	[	| changed tally |		changed := false.		firstSets keysAndValuesDo: [ :parser :first |			tally := first size.			parser firstSets: firstSets into: first.			changed := changed or: [ tally ~= first size ] ].		changed ] whileTrue.	^ firstSets! !!PPParser methodsFor: '*PetitAnalyzer'!innerChildrenDo: aBlock seen: aSet	"Iterate over the inner children of the receiver."		self children do: [ :each |		(aSet includes: each)			ifTrue: [ ^ self ].		aSet add: each.		each name isNil ifTrue: [			aBlock value: each.			each innerChildrenDo: aBlock seen: aSet ] ]! !!PPParser methodsFor: '*PetitAnalyzer'!transform: aBlock	"Answer a copy of all parsers reachable from the receiver transformed using aBlock."	| mapping root |	mapping := IdentityDictionary new.	self allParsersDo: [ :each |		mapping			at: each			put: (aBlock value: each copy) ].	root := mapping at: self.	[	| changed |		changed := false.		root allParsersDo: [ :each |			each children do: [ :old |				mapping at: old ifPresent: [ :new |					each replace: old with: new.					changed := true ] ] ].		changed ] whileTrue.	^ root! !!PPParser methodsFor: '*PetitAnalyzer'!isFirstSetTerminal	"Answer true if the receiver is a terminal or leaf parser, that means it does not delegate to any other parser."	^ self children isEmpty! !!PPParser methodsFor: '*PetitGui'!newSpacerMorph	^ Morph new		color: Color transparent;		borderWidth: 0;		extent: 7 @ 7;		yourself! !!PPParser methodsFor: '*PetitGui'!enableDebug   | root newParser  |	root := PPParserDebuggerResult new.		"In order to debug island waters, we need to compute the island water..."	"self allParsers select: [ :p | p isKindOf: PPSea  ] thenDo: [ :island |		island createWaterForRoot: self		]."		newParser := self transform: [:each |		each >=> [:stream :continuation | 			| result child |			child := PPParserDebuggerResult new 					parser: each;					parent: root.			root := root children add: child. 			child start: stream position + 1.			result := continuation value.			child end: stream position.			root result: result.			root := root parent.			result 		]	].		^ PPDebugParser on: newParser root: root.! !!PPParser methodsFor: '*PetitGui'!namedParsersDo: aBlock    self namedParsersDo: aBlock seen: IdentitySet new! !!PPParser methodsFor: '*PetitGui'!viewAllNamedParsers	"	PPSmalltalkParser new viewAllNamedParsers	"	| view |	view := RTMondrian new.	self viewAllNamedParsersWithSelection: {} on: view.	^ view openWithToolbarEntitled: 'All named parsers'! !!PPParser methodsFor: '*PetitGui'!viewAllNamedParsersWithSelection: aCollectionOfNames on: view	self viewAllNamedParsersWithSelection: aCollectionOfNames previewing: [ :each | each name ] on: view! !!PPParser methodsFor: '*PetitGui'!viewAllParsers	"	PPSmalltalkParser new viewAllParsers	"	| view |	view := RTMondrian new.	self viewAllParsersOn: view.	view openWithToolbarEntitled: 'All parsers'.	^ view! !!PPParser methodsFor: '*PetitGui'!visualizationGraphType	^ nil! !!PPParser methodsFor: '*PetitGui'!exampleOn: aStream! !!PPParser methodsFor: '*PetitGui'!displayColor	^ self isTerminal		ifTrue: [ Color r: 0.5 g: 0.0 b: 0.5 ]		ifFalse: [ Color blue ]! !!PPParser methodsFor: '*PetitGui'!morphicShapeDefault	^ self newRowMorph		addMorphBack: (self newColumnMorph			addMorphBack: (self newSpacerMorph);			addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1)					makeForwardArrow;			yourself);		addMorphBack: (self newRowMorph			borderWidth: 1;			layoutInset: 3;			color: Color white;			addMorphBack: (StringMorph new				contents: self displayName;				color: self displayColor;				yourself);			yourself);		yourself! !!PPParser methodsFor: '*PetitGui'!example	^ String streamContents: [ :stream | self exampleOn: stream ] limitedTo: 1024! !!PPParser methodsFor: '*PetitGui'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeDefault! !!PPParser methodsFor: '*PetitGui'!debug: anObject	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."		^ self enableDebug parse: anObject asPetitStream! !!PPParser methodsFor: '*PetitGui'!newColumnMorph	^ AlignmentMorph newColumn		cellPositioning: #topLeft;		color: Color transparent;		listCentering: #topLeft;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		layoutInset: 0;		yourself! !!PPParser methodsFor: '*PetitGui'!morphicShapeSeen: aSet depth: anInteger do: aBlock	" avoid recursion "	(aSet includes: self)		ifTrue: [ ^ self morphicShapeDefault ].	" display nice name when possible "	(anInteger > 0 and: [ self name notNil ]) 		ifTrue: [ ^ self morphicShapeDefault ].	" don't do it too deep "	(anInteger > 10)		ifTrue: [ ^ self morphicShapeDefault ].	aSet add: self. 	^ aBlock value: [ :parser |		parser 			morphicShapeSeen: aSet 			depth: anInteger + 1 ]! !!PPParser methodsFor: '*PetitGui'!newRowMorph	^ AlignmentMorph newRow		cellPositioning: #topLeft;		color: Color transparent;		listCentering: #topLeft;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		layoutInset: 0;		yourself! !!PPParser methodsFor: '*PetitGui'!viewAllParsersOn: view	view shape label 		height: 10;		text: [ :each | 			| labels |			labels := OrderedCollection new.			each name notNil ifTrue: [ labels add: each name ].			each visualizationGraphType notNil ifTrue: [ labels add: each visualizationGraphType ].			labels asArray ];		if: [ :p | p name isNil ] fillColor: Color lightGray.	view nodes: self allParsers.	view edges connectToAll: #children.		view treeLayout! !!PPParser methodsFor: '*PetitGui'!gtNamedTreeViewIn: composite	<gtInspectorPresentationOrder: 40>	composite tree		title: 'Named Tree';		children: [:n | n namedChildren ];		format: [:n| n name ifNil: [ n asString ] ];		shouldExpandToLevel: 3! !!PPParser methodsFor: '*PetitGui'!gtInspectorParserInspectorIn: composite	<gtInspectorPresentationOrder: 30>	composite custom: (		PPVerticalParserInspector new 			title: 'Sampler';			startOn: self)! !!PPParser methodsFor: '*PetitGui'!backgroundForDepth: anInteger	^ Color gray: 1.0 - (anInteger / 20.0)! !!PPParser methodsFor: '*PetitGui'!viewAllNamedParsersWithSelection: aCollectionOfNames previewing: aBlock on: view	| l |	view shape label		color: [ :each | 					(aCollectionOfNames includes: each name)						ifFalse: [ Color black ]						ifTrue: [ Color red ] ];		text: [ :each | each displayName ].	view interaction popupText: aBlock.	view interaction item: 'Explore' action: #explore.	view nodes: (self allParsers reject: [ :each | each name isEmptyOrNil ]).	view edges		source: (self allParsers reject: [ :each | each name isEmptyOrNil ]) connectFrom: #yourself toAll: #namedParsers.	l := view layout horizontalDominanceTree.	l verticalGap: 10;		layered! !!PPParser methodsFor: '*PetitGui'!namedParsers    | result |    result := OrderedCollection new.    self namedParsersDo: [ :parser | result addLast: parser ].    ^ result! !!PPParser methodsFor: '*PetitGui'!displayName	^ self name isNil		ifFalse: [ self name asString ]		ifTrue: [ self class name asString ]! !!PPParser methodsFor: '*PetitGui'!gtTreeViewIn: composite	<gtInspectorPresentationOrder: 40>	composite tree			title: 'Tree';			children: [:n | n children ];			format: [:n| n name ifNil: [ n asString ] ifNotNil: [n name] ];			shouldExpandToLevel: 6! !!PPParser methodsFor: '*PetitGui'!namedParsersDo: aBlock seen: aSet    self children do: [ :each |         (aSet includes: each)            ifFalse: [		        aSet add: each.		        each name isEmptyOrNil		            ifFalse: [ aBlock value: each ]		            ifTrue: [ each namedParsersDo: aBlock seen: aSet ] ] ]! !!PPParser methodsFor: '*PetitGui'!gtAllParsersIn: composite	<gtInspectorPresentationOrder: 50>	composite roassal2		title: 'Graph'; 		initializeView: [ RTMondrian new ];		painting: [ :view |			self viewAllParsersOn: view.			].! !!PPParser methodsFor: '*PetitGui'!morphicProduction	^ self newRowMorph		layoutInset: 4;		addMorphBack: (self newRowMorph			layoutInset: 4;			addMorphBack: (StringMorph new				contents: self displayName;				emphasis: TextEmphasis bold emphasisCode;				yourself);			yourself);		addMorphBack: (self morphicShapeSeen: IdentitySet new depth: 0);		addMorphBack: (self newColumnMorph			addMorphBack: (self newSpacerMorph);			addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1)					makeForwardArrow;			yourself);		yourself! !!PPParser methodsFor: 'initialization'!initialize! !!PPParser methodsFor: 'operators'!def: aParser	"Redefine the receiver as the argument aParser. This method is useful when defining recursive parsers: instantiate a PPUnresolvedParser and later redefine it with another one."	^ self becomeForward: (aParser name: self name)! !!PPParser methodsFor: 'operators'!negate	"Answer a new parser consumes any input token but the receiver."		^ self not , #any asParser ==> #second! !!PPParser methodsFor: 'operators'!if: aBlock	^ PPConditionalParser on: self block: aBlock! !!PPParser methodsFor: 'operators'!memoized	"Answer a new memoized parser, for refraining redundant computations. This ensures polynomial time O(n^4) for left-recursive grammars and O(n^3) for non left-recursive grammars in the worst case. Not necessary for most grammars that are carefully written and in O(n) anyway."		^ PPMemoizedParser on: self! !!PPParser methodsFor: 'operators'!, aParser 	"Answer a new parser that parses the receiver followed by aParser."	^ PPSequenceParser with: self with: aParser! !!PPParser methodsFor: 'operators'!optional	"Answer a new parser that parses the receiver, if possible."	^ PPOptionalParser on: self! !!PPParser methodsFor: 'operators'!| aParser	"Answer a new parser that either parses the receiver or aParser. Fail if both pass or fail (exclusive choice, unordered choice)."	^ (self not , aParser) / (aParser not , self) ==> #second! !!PPParser methodsFor: 'operators'!wrapped	"Answer a new parser that is simply wrapped."		^ PPDelegateParser on: self! !!PPParser methodsFor: 'operators'!and	"Answer a new parser (logical and-predicate) that succeeds whenever the receiver does, but never consumes input."	^ PPAndParser on: self! !!PPParser methodsFor: 'operators'!/ aParser 	"Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice)."		^ PPChoiceParser with: self with: aParser! !!PPParser methodsFor: 'operators'!not	"Answer a new parser (logical not-predicate) that succeeds whenever the receiver fails, but never consumes input."	^ PPNotParser on: self! !!PPParser methodsFor: 'operators'!end	"Answer a new parser that succeeds at the end of the input and return the result of the receiver."	^ PPEndOfInputParser on: self! !!PPParser methodsFor: 'operators'!// aParser 	"		Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice).		If the receiver passes, limit must pass as well.	"		^ PPLimitedChoiceParser with: self with: aParser! !!PPParser methodsFor: 'operators'!nonMemoized	^ self! !!PPParser methodsFor: 'operators-convenience'!withoutSeparators	"Filters out the separators from a parse result produced by one of the productions #delimitedBy: or #separatedBy:."		^ self ==> [ :items |		| result |		result := Array new: items size + 1 // 2.		1 to: result size do: [ :index | result at: index put: (items at: 2 * index - 1) ].		result ]! !!PPParser methodsFor: 'operators-convenience'!delimitedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated and possibly ended by aParser."		^ (self separatedBy: aParser) , (aParser optional) ==> [ :node |		node second isNil			ifTrue: [ node first ]			ifFalse: [ node first copyWith: node second ] ]! !!PPParser methodsFor: 'operators-convenience'!separatedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated by aParser."		^ (PPSequenceParser with: self with: (PPSequenceParser with: aParser with: self) star) ==> [ :nodes |		| result |		result := Array new: 2 * nodes second size + 1.		result at: 1 put: nodes first.		nodes second 			keysAndValuesDo: [ :index :pair | result replaceFrom: 2 * index to: 2 * index + 1 with: pair startingAt: 1 ].		result ]! !!PPParser methodsFor: 'accessing-properties'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PPParser methodsFor: 'accessing-properties'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer! !!PPParser methodsFor: 'accessing-properties'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPParser methodsFor: 'accessing-properties'!properties	^ properties! !!PPParser methodsFor: 'accessing-properties'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PPParser methodsFor: 'accessing-properties'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]! !!PPParser methodsFor: 'accessing-properties'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject! !!PPParser methodsFor: 'accessing-properties'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPParser methodsFor: 'operators-repeating'!min: anInteger lazy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: anInteger! !!PPParser methodsFor: 'operators-repeating'!min: aMinInteger max: aMaxInteger	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times."		^ self star setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'operators-repeating'!max: anInteger lazy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMax: anInteger! !!PPParser methodsFor: 'operators-repeating'!plusLazy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ (self starLazy: aParser) setMin: 1! !!PPParser methodsFor: 'operators-repeating'!starLazy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ PPLazyRepeatingParser on: self limit: aParser! !!PPParser methodsFor: 'operators-repeating'!min: anInteger	"Answer a new parser that parses the receiver at least anInteger times."		^ self star setMin: anInteger! !!PPParser methodsFor: 'operators-repeating'!max: anInteger greedy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMax: anInteger! !!PPParser methodsFor: 'operators-repeating'!times: anInteger	"Answer a new parser that parses the receiver exactly anInteger times."		^ self min: anInteger max: anInteger! !!PPParser methodsFor: 'operators-repeating'!star	"Answer a new parser that parses the receiver zero or more times. This is a greedy and blind implementation that tries to consume as much input as possible and it does not consider what comes afterwards."	^ PPPossessiveRepeatingParser on: self! !!PPParser methodsFor: 'operators-repeating'!min: anInteger greedy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: anInteger! !!PPParser methodsFor: 'operators-repeating'!plusGreedy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ (self starGreedy: aParser) setMin: 1! !!PPParser methodsFor: 'operators-repeating'!min: aMinInteger max: aMaxInteger greedy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'operators-repeating'!starGreedy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ PPGreedyRepeatingParser on: self limit: aParser! !!PPParser methodsFor: 'operators-repeating'!max: anInteger	"Answer a new parser that parses the receiver at most anInteger times."		^ self star setMax: anInteger! !!PPParser methodsFor: 'operators-repeating'!plus	"Answer a new parser that parses the receiver one or more times."	^ self star setMin: 1! !!PPParser methodsFor: 'operators-repeating'!min: aMinInteger max: aMaxInteger lazy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'testing'!isUnresolved	^ false! !!PPParser methodsFor: 'testing'!isPetitParser	^ true! !!PPParser methodsFor: 'operators-mapping'!token: aTokenClass	"Answer a new parser that transforms the input to a token of class aTokenClass."		^ self token tokenClass: aTokenClass! !!PPParser methodsFor: 'operators-mapping'!flatten	"Answer a new parser that flattens the underlying collection."		^ PPFlattenParser on: self! !!PPParser methodsFor: 'operators-mapping'!trimSpaces	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #space asParser! !!PPParser methodsFor: 'operators-mapping'!>=> aBlock	"Answer a new parser that wraps the receiving parser with a two argument block. The first argument is the parsed stream, the second argument a continuation block on the delegate parser."	^ PPWrappingParser on: self block: aBlock! !!PPParser methodsFor: 'operators-mapping'!foldLeft: aBlock	"Answer a new parser that that folds the result of the receiver from left-to-right into aBlock. The argument aBlock must take two or more arguments."		| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: 1 put: nodes first.		2 to: nodes size by: size - 1 do: [ :index |			args				replaceFrom: 2 to: size with: nodes startingAt: index;				at: 1 put: (aBlock valueWithArguments: args) ].		args first ]! !!PPParser methodsFor: 'operators-mapping'!==> aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PPActionParser on: self block: aBlock! !!PPParser methodsFor: 'operators-mapping'!trimSpacesRight	"Answer a new parser that consumes spaces after the receiving parser."		^ (self, #space asParser star) ==> #first! !!PPParser methodsFor: 'operators-mapping'!map: aBlock	"Answer a new parser that works on the receiving sequence an passes in each element as a block argument."		^ aBlock numArgs = 1		ifTrue: [ self ==> aBlock ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]! !!PPParser methodsFor: 'operators-mapping'!token	"Answer a new parser that transforms the input to a token."		^ PPTokenParser on: self! !!PPParser methodsFor: 'operators-mapping'!answer: anObject	"Answer a new parser that always returns anObject from a successful parse."	^ self ==> [ :nodes | anObject ]! !!PPParser methodsFor: 'operators-mapping'!foldRight: aBlock	"Answer a new parser that that folds the result of the receiver from right-to-left into aBlock. The argument aBlock must take two or more arguments."	| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: size put: nodes last.		nodes size - size + 1 to: 1 by: 1 - size do: [ :index |			args				replaceFrom: 1 to: size - 1 with: nodes startingAt: index;				at: size put: (aBlock valueWithArguments: args) ].		args at: size ]! !!PPParser methodsFor: 'operators-mapping'!trimSpacesLeft	"Answer a new parser that consumes spaces before the receiving parser."		^ (#space asParser star, self) ==> #second! !!PPParser methodsFor: 'operators-mapping'!trimLeft	"Answer a new parser that consumes spaces before the receiving parser."		^ self trimSpacesLeft! !!PPParser methodsFor: 'operators-mapping'!trimBlanks	"Answer a new parser that consumes blanks before and after the receiving parser."		^ self trim: #blank asParser! !!PPParser methodsFor: 'operators-mapping'!trim: aParser	"Answer a new parser that consumes and ignores aParser repeatedly before and after the receiving parser."		^ PPTrimmingParser on: self trimmer: aParser! !!PPParser methodsFor: 'operators-mapping'!trimRight	"Answer a new parser that consumes spaces after the receiving parser."		^ self trimSpacesRight! !!PPParser methodsFor: 'operators-mapping'!trim	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpaces! !!PPParser methodsFor: 'operators-mapping'!trimRight: trimmer	"Answer a new parser that consumes spaces after the receiving parser."		^ (self, trimmer star) ==> #first! !!PPParser methodsFor: 'enumerating'!allParsersDo: aBlock	"Iterate over all the parse nodes of the receiver."	self allParsersDo: aBlock seen: IdentitySet new! !!PPParser methodsFor: 'enumerating'!allParsers	"Answer all the parse nodes of the receiver."	| result |	result := OrderedCollection new.	self allParsersDo: [ :parser | result addLast: parser ].	^ result! !!PPParser methodsFor: 'enumerating'!allParsersDo: aBlock seen: aSet	"Iterate over all the parse nodes of the receiver, do not visit and follow the ones contained in aSet."	(aSet includes: self)		ifTrue: [ ^ self ].	aSet add: self.	aBlock value: self.	self children		do: [ :each | each allParsersDo: aBlock seen: aSet ]! !!PPParser methodsFor: 'accessing'!name	"Answer the production name of the receiver."		^ self propertyAt: #name ifAbsent: [ nil ]! !!PPParser methodsFor: 'accessing'!name: aString	self propertyAt: #name put: aString! !!PPParser methodsFor: 'accessing'!child	self assert: (self children size == 1).	^ self children first! !!PPParser methodsFor: 'accessing'!children	"Answer a set of child parsers that could follow the receiver."	^ #()! !!PPParser methodsFor: 'copying'!postCopy	super postCopy.	properties := properties copy! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPParser class	instanceVariableNames: ''!!PPParser class methodsFor: '*PetitGui'!gtExampleEmptyParser	<gtExample>	<label: 'Empty parser'>		^ self new! !!PPParser class methodsFor: '*PetitGui'!gtExampleCharactersParser	<gtExample>	<label: 'Characters parser'>		^ ($a to: $z) asParser! !!PPParser class methodsFor: 'instance creation'!named: aString	^ self new name: aString! !!PPParser class methodsFor: 'instance creation'!new	^ self basicNew initialize! !PPParser subclass: #PPDelegateParser	instanceVariableNames: 'parser'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPDelegateParser commentStamp: '' prior: 0!A parser that delegates to another parser.Instance Variables:	parser	<PPParser>	The parser to delegate to.!!PPDelegateParser methodsFor: 'accessing'!children	^ Array with: parser! !!PPDelegateParser methodsFor: '*PetitAnalyzer'!replace: aParser with: anotherParser	super replace: aParser with: anotherParser.	parser == aParser ifTrue: [ parser := anotherParser ]! !!PPDelegateParser methodsFor: '*PetitGui'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeSeen: aSet depth: anInteger do: [ :cc |		self displayDescription isNil			ifTrue: [ cc value: parser ]			ifFalse: [				self newRowMorph					addMorphBack: (self newColumnMorph						addMorphBack: (self newSpacerMorph height: 10);						addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1);						yourself);					addMorphBack: (self newRowMorph						color: (self backgroundForDepth: anInteger);						addMorphBack: (self newColumnMorph							addMorphBack: (cc value: parser);							addMorphBack: (self newRowMorph								hResizing: #spaceFill;								addMorphBack: (self newSpacerMorph									width: 20;									yourself);								addMorphBack: (self newColumnMorph									hResizing: #spaceFill;									listCentering: #center;									addMorphBack: (self newSpacerMorph);									addMorphBack: (StringMorph new										contents: self displayDescription;										yourself);									yourself);								yourself);							yourself);								addMorphBack: (self newColumnMorph							addMorphBack: (self newSpacerMorph height: 10);							addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1);							yourself);						yourself);					yourself ] ]! !!PPDelegateParser methodsFor: '*PetitGui'!displayDescription	^ nil! !!PPDelegateParser methodsFor: '*PetitGui'!exampleOn: aStream	parser exampleOn: aStream! !!PPDelegateParser methodsFor: 'parsing'!parseOn: aPPContext	^ parser parseOn: aPPContext! !!PPDelegateParser methodsFor: 'initialization'!setParser: aParser	parser := aParser! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPDelegateParser class	instanceVariableNames: ''!!PPDelegateParser class methodsFor: 'instance creation'!on: aParser	^ self new setParser: aParser! !PPDelegateParser subclass: #PPActionParser	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPActionParser commentStamp: '' prior: 0!A parser that performs an action block with the successful parse result of the delegate.Instance Variables:	block	<BlockClosure>	The action block to be executed.!!PPActionParser methodsFor: '*PetitGui'!visualizationGraphType	^ '[]'! !!PPActionParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self block = aParser block ]! !!PPActionParser methodsFor: 'accessing'!block	"Answer the action block of the receiver."	^ block! !!PPActionParser methodsFor: 'parsing'!parseOn: aPPContext	| element |	^ (element := parser parseOn: aPPContext) isPetitFailure		ifFalse: [ block value: element ]		ifTrue: [ element ]! !!PPActionParser methodsFor: 'initialization'!setBlock: aBlock	block := aBlock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPActionParser class	instanceVariableNames: ''!!PPActionParser class methodsFor: 'instance creation'!on: aParser block: aBlock	^ (self on: aParser) setBlock: aBlock! !PPDelegateParser subclass: #PPAndParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPAndParser commentStamp: '' prior: 0!The and-predicate, a parser that succeeds whenever its delegate does, but does not consume the input stream [Parr 1994, 1995].!!PPAndParser methodsFor: 'parsing'!parseOn: aPPContext	| element memento |	memento := aPPContext remember.	element := parser parseOn: aPPContext.	aPPContext restore: memento.	^ element! !!PPAndParser methodsFor: '*PetitGui'!displayDescription	^ 'and'! !!PPAndParser methodsFor: '*PetitGui'!exampleOn: aStream! !!PPAndParser methodsFor: 'operators'!and	^ self! !PPDelegateParser subclass: #PPConditionalParser	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPConditionalParser commentStamp: '' prior: 0!A PPConditionalParser is a delegate parser that evaluates a block and if that returns true, the delegate parser is invoked and its result returned. If the block evaluates to false, the PPFailure is returned.The block accepts one argument, context.E.g.    ('a' asParser if: [ :ctx | (ctx propertyAt: #myProperty) isNotNil ]) parse: 'a'!!PPConditionalParser methodsFor: 'parsing'!parseOn: aPPContext	^ (block value: aPPContext) 		ifTrue: [ parser parseOn: aPPContext ]		ifFalse: [ PPFailure message: block asString, ' was not evaluated to true.' context: aPPContext ]! !!PPConditionalParser methodsFor: 'accessing'!block: aBlock	block := aBlock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPConditionalParser class	instanceVariableNames: ''!!PPConditionalParser class methodsFor: 'as yet unclassified'!on: aPPParser block: block	^ (PPConditionalParser on: aPPParser)		block: block;		yourself! !PPParser subclass: #PPEndOfFileParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPEndOfFileParser commentStamp: '' prior: 0!A PPEndOfFileParser is parser that will will return true if the stream position is at the end, returns failure otherwise.The diffirenece between PPEndOfFIleParser and PPEndOfInputParser is: - PPEndOfFileParser can be created using #eof asParser - PPEndOfInputParser can be created by using parser end - PPEndOfFileParser does not delegate to any other parser - PPEndOfInputParser parsers its delegate and then decides if the input is at the end.The PPEndOfFileParser can be used to accept some input only if it is at the end of the input, e.g:   ('a' asParser, #eof asParser) parse: 'a'   ('a' asParser, #eof asParser) parse: 'aa'!!PPEndOfFileParser methodsFor: '*PetitAnalyzer'!isNullable 	^ true! !!PPEndOfFileParser methodsFor: '*PetitGui'!exampleOn: aStream 	aStream nextPutAll: #'end-of-input'! !!PPEndOfFileParser methodsFor: 'parsing'!parseOn: aPPContext	(aPPContext atEnd) ifFalse:	[		^ PPFailure message: 'end of input expected' context: aPPContext.	].	^ #'end-of-input'! !PPDelegateParser subclass: #PPEndOfInputParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPEndOfInputParser commentStamp: '' prior: 0!A parser that succeeds only at the end of the input stream.!!PPEndOfInputParser methodsFor: 'operators'!end	^ self! !!PPEndOfInputParser methodsFor: 'parsing'!parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := parser parseOn: aPPContext.	(result isPetitFailure or: [ aPPContext stream atEnd ])		ifTrue: [ ^ result ].	result := PPFailure		message: 'end of input expected'		context: aPPContext.	aPPContext restore: memento.	^ result! !!PPEndOfInputParser methodsFor: '*PetitGui'!displayDescription	^ 'end of input'! !PPParser subclass: #PPEndOfLineParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPEndOfLineParser commentStamp: '' prior: 0!A PPEndOfLineParser is a parser that does not fail, if the stream position is at the end of a line. It does not consume anything.!!PPEndOfLineParser methodsFor: 'parsing'!parseOn: aPPContext	(aPPContext isEndOfLine) ifTrue: [ 		^ #endOfLine	].	^ PPFailure message: 'End of line expected' context: aPPContext at: aPPContext position! !PPParser subclass: #PPEpsilonParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPEpsilonParser commentStamp: '' prior: 0!A parser that consumes nothing and always succeeds.!!PPEpsilonParser methodsFor: 'parsing'!parseOn: aStream	^ nil! !!PPEpsilonParser methodsFor: '*PetitAnalyzer'!isNullable	^ true! !!PPEpsilonParser methodsFor: '*PetitGui'!displayName	^ 'epsilon'! !!PPEpsilonParser methodsFor: '*PetitGui'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeSeen: aSet depth: anInteger do: [ :cc |		self newRowMorph			addMorphBack: (self newColumnMorph				addMorphBack: (self newSpacerMorph height: 10);				addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1);				yourself);			yourself ]! !PPParser subclass: #PPFailingParser	instanceVariableNames: 'message'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPFailingParser commentStamp: '' prior: 0!A parser that consumes nothing and always fails.Instance Variables:	message <String>	The failure message.!!PPFailingParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self message = aParser message ]! !!PPFailingParser methodsFor: 'printing'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: message! !!PPFailingParser methodsFor: '*PetitGui'!displayName	^ message! !!PPFailingParser methodsFor: '*PetitGui'!displayColor	^ Color red! !!PPFailingParser methodsFor: 'accessing'!message	"Answer the error message of the receiving parser."	^ message! !!PPFailingParser methodsFor: 'pp-context'!parseOn: aPPContext	^ PPFailure message: message context: aPPContext! !!PPFailingParser methodsFor: 'initialization'!setMessage: aString	message := aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPFailingParser class	instanceVariableNames: ''!!PPFailingParser class methodsFor: 'instance creation'!message: aString	^ self new setMessage: aString! !PPDelegateParser subclass: #PPFlattenParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPFlattenParser commentStamp: '' prior: 0!A parser that answers a flat copy of the range my delegate parses.!!PPFlattenParser methodsFor: 'parsing'!parseOn: aPPContext	| start element |	start := aPPContext position.	element := parser parseOn: aPPContext.	element isPetitFailure ifTrue: [ ^ element ].	^ self on: aPPContext stream collection start: start + 1 stop: aPPContext position value: element! !!PPFlattenParser methodsFor: 'private'!on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ aCollection copyFrom: aStartInteger to: aStopInteger! !PPParser subclass: #PPListParser	instanceVariableNames: 'parsers'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPListParser commentStamp: '' prior: 0!Abstract parser that parses a list of things in some way (to be specified by the subclasses).Instance Variables:	parsers	<SequenceableCollection of: PPParser>	A sequence of other parsers to delegate to.!!PPListParser methodsFor: 'copying'!postCopy	super postCopy.	parsers := parsers copy! !!PPListParser methodsFor: 'copying'!copyWith: aParser	^ self species withAll: (parsers copyWith: aParser)! !!PPListParser methodsFor: 'initialization'!setParsers: aCollection	parsers := aCollection asArray! !!PPListParser methodsFor: 'initialization'!initialize	super initialize.	self setParsers: #()! !!PPListParser methodsFor: '*PetitAnalyzer'!copyInContext: aDictionary seen: aSeenDictionary	| copy copies |	aSeenDictionary at: self ifPresent: [ :value | ^ value ].	copy := aSeenDictionary at: self put: self copy.	copies := OrderedCollection new.	parsers do: [ :each |		| result |		result := each 			copyInContext: aDictionary			seen: aSeenDictionary.		result isCollection			ifTrue: [ copies addAll: result ]			ifFalse: [ copies add: result ] ].	^ copy		setParsers: copies;		yourself! !!PPListParser methodsFor: '*PetitAnalyzer'!replace: aParser with: anotherParser	super replace: aParser with: anotherParser.	parsers keysAndValuesDo: [ :index :parser |		parser == aParser			ifTrue: [ parsers at: index put: anotherParser ] ]! !!PPListParser methodsFor: 'accessing'!children	^ parsers! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPListParser class	instanceVariableNames: ''!!PPListParser class methodsFor: 'instance creation'!with: aParser	^ self withAll: (Array with: aParser)! !!PPListParser class methodsFor: 'instance creation'!with: aFirstParser with: aSecondParser	^ self withAll: (Array with: aFirstParser with: aSecondParser)! !!PPListParser class methodsFor: 'instance creation'!withAll: aCollection	^ self basicNew initialize;		setParsers: aCollection! !PPListParser subclass: #PPChoiceParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPChoiceParser commentStamp: '' prior: 0!A parser that uses the first parser that succeeds.!!PPChoiceParser methodsFor: '*PetitGui'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeSeen: aSet depth: anInteger do: [ :cc |		| morph |		morph := self newColumnMorph 			cellInset: 5;			yourself.		self children do: [ :each | 			morph addMorphBack: (self newRowMorph				hResizing: #spaceFill;				addMorphBack: (cc value: each);				addMorphBack: (self newColumnMorph					hResizing: #spaceFill;					addMorphBack: (self newSpacerMorph height: 10);					addMorphBack: ((LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1)						hResizing: #spaceFill;						minWidth: 20;						yourself);					yourself);				yourself) ].		morph fullBounds.		self newRowMorph			addMorphBack: (self newColumnMorph				addMorphBack: (self newSpacerMorph height: 10);				addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1);				yourself);			addMorphBack: (self newColumnMorph				addMorphBack: (self newSpacerMorph width: 1; height: 10);				addMorphBack: (LineMorph from: 0 @ 0 to: 0 @ (morph height - 23) color: Color black width: 1);				yourself);			addMorphBack: morph;			addMorphBack: (self newColumnMorph				addMorphBack: (self newSpacerMorph width: 1; height: 10);				addMorphBack: (LineMorph from: 0 @ (morph height - 23) to: 0 @ 0 color: Color black width: 1)					makeForwardArrow;					width: 1;				yourself);			yourself ]! !!PPChoiceParser methodsFor: '*PetitGui'!visualizationGraphType	^ '/'! !!PPChoiceParser methodsFor: '*PetitGui'!exampleOn: aStream	"If there is already a lot written, try to pick an empty possiblity."		aStream position > 512 ifTrue: [		(parsers anySatisfy: [ :each | each isNullable ])			ifTrue: [ ^ self ] ].	parsers atRandom exampleOn: aStream! !!PPChoiceParser methodsFor: 'operators'!/ aRule 	^ self copyWith: aRule! !!PPChoiceParser methodsFor: 'parsing'!parseOn: aPPContext	"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."	| element |	1 to: parsers size do: [ :index |		element := (parsers at: index)			parseOn: aPPContext.		element isPetitFailure			ifFalse: [ ^ element ] ].	^ element! !PPChoiceParser subclass: #PPLimitedChoiceParser	instanceVariableNames: 'limit'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLimitedChoiceParser commentStamp: '' prior: 0!A PPLimitedChoiceParser is similar to the choice parser except for the fact, that limit must pass if one of the choices passes. This is similar strategy as with the PPLimitedRepeatingParsers.This way, one can implement choices that successfully parse this (if limit is filled with 'a'):('aa' // 'a') 'a' parse: 'aa'The limit can be automatically filled using elements from either follow or next set (see methods  PPParser>>followSets or PPParser>>nextSets).Limit is by default epsilon and therefore it behaves as an ordinary ordered choice.Instance Variables	limit:		<Object>limit	- xxxxx!!PPLimitedChoiceParser methodsFor: 'accessing'!limit		^ limit! !!PPLimitedChoiceParser methodsFor: 'accessing'!limit: anObject		limit := anObject! !!PPLimitedChoiceParser methodsFor: 'as yet unclassified'!parseOn: aPPContext	"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."	| element limitResult memento |	"self halt."	1 to: parsers size do: [ :index |		memento := aPPContext remember.				element := (parsers at: index)			parseOn: aPPContext.				(element isPetitFailure not) ifTrue: [ 			"check limit"			limitResult := limit parseOn: aPPContext.			limitResult isPetitFailure ifTrue: [ 				element := PPFailure message: 'limit failed' at: aPPContext position .				aPPContext restore: memento.			] ifFalse: [ ^ element ].		].	].		^ element! !!PPLimitedChoiceParser methodsFor: 'as yet unclassified'!initialize	limit := nil asParser! !!PPLimitedChoiceParser methodsFor: 'as yet unclassified'!// aRule 	^ self copyWith: aRule! !PPParser subclass: #PPLiteralParser	instanceVariableNames: 'literal message'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLiteralParser commentStamp: '' prior: 0!Abstract literal parser that parses some kind of literal type (to be specified by subclasses).Instance Variables:	literal	<Object>	The literal object to be parsed.	message	<String>	The error message to be generated.!!PPLiteralParser methodsFor: 'operators'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		self subclassResponsibility! !!PPLiteralParser methodsFor: 'initialization'!initializeOn: anObject message: aString	literal := anObject.	message := aString! !!PPLiteralParser methodsFor: 'accessing'!literal	"Answer the parsed literal."	^ literal! !!PPLiteralParser methodsFor: 'accessing'!message	"Answer the failure message."		^ message! !!PPLiteralParser methodsFor: 'printing'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: literal! !!PPLiteralParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self literal = aParser literal and: [ self message = aParser message ] ]! !!PPLiteralParser methodsFor: '*PetitGui'!visualizationGraphType	^ literal printString! !!PPLiteralParser methodsFor: '*PetitGui'!displayName	^ literal printString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPLiteralParser class	instanceVariableNames: ''!!PPLiteralParser class methodsFor: 'instance creation'!on: anObject message: aString	^ self new initializeOn: anObject message: aString! !!PPLiteralParser class methodsFor: 'instance creation'!on: anObject	^ self on: anObject message: anObject printString , ' expected'! !PPLiteralParser subclass: #PPLiteralObjectParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLiteralObjectParser commentStamp: '' prior: 0!A parser that accepts a single literal object, such as a character. This is the same as the predicate parser 'PPPredicateParser expect: literal' but slightly more efficient.!!PPLiteralObjectParser methodsFor: 'operators'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateObjectParser on: [ :value | literal sameAs: value ] message: message! !!PPLiteralObjectParser methodsFor: 'operators'!negate	^ (PPPredicateObjectParser expect: literal message: message) negate! !!PPLiteralObjectParser methodsFor: 'parsing'!parseOn: aPPContext	^ (aPPContext stream atEnd not and: [ literal = aPPContext stream uncheckedPeek ])		ifFalse: [ PPFailure message: message context: aPPContext ]		ifTrue: [ aPPContext next ]! !!PPLiteralObjectParser methodsFor: '*PetitGui'!exampleOn: aStream	aStream nextPut: literal! !PPLiteralParser subclass: #PPLiteralSequenceParser	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLiteralSequenceParser commentStamp: '' prior: 0!A parser accepts a sequence of literal objects, such as a String. This is an optimization to avoid having to compose longer sequences from PPSequenceParser.!!PPLiteralSequenceParser methodsFor: 'accessing'!size	"Answer the sequence size of the receiver."	^ size! !!PPLiteralSequenceParser methodsFor: 'initialization'!initializeOn: anObject message: aString	super initializeOn: anObject message: aString.	size := literal size! !!PPLiteralSequenceParser methodsFor: '*PetitGui'!exampleOn: aStream	aStream nextPutAll: literal! !!PPLiteralSequenceParser methodsFor: 'operators'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateSequenceParser on: [ :value | literal sameAs: value ] message: message size: size! !!PPLiteralSequenceParser methodsFor: 'parsing'!parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := aPPContext next: size.	literal = result ifTrue: [ ^ result ].	aPPContext restore: memento.	^ PPFailure message: message context: aPPContext! !PPDelegateParser subclass: #PPMemoizedParser	instanceVariableNames: 'buffer identifier'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPMemoizedParser commentStamp: '' prior: 0!A memoized parser, for refraining redundant computations.Instance Variables:	stream	<PositionableStream>	The stream of the associated memento objects.	buffer	<Array of: PPMemento>	The buffer of memento objects.!!PPMemoizedParser methodsFor: 'parsing'!check: aPPContext	(identifier == aPPContext identifier)		ifFalse: [ self reset: aPPContext ].! !!PPMemoizedParser methodsFor: 'parsing'!parseOn: aPPContext	| memento contextMemento  aStream |	"TODO: JK memoizing needs review!!"	self check: aPPContext.	contextMemento := aPPContext remember.	memento := (buffer at: contextMemento ifAbsentPut: [ PPMemento new ]).		memento contextMemento isNil		ifTrue: [			aStream := aPPContext stream.			memento result: (aStream size - aStream position + 2 < memento count				ifTrue: [ PPFailure message: 'overflow' context: aPPContext ]				ifFalse: [ memento increment. parser parseOn: aPPContext ]).			memento contextMemento: aPPContext remember ]		ifFalse: [ aPPContext restore: memento contextMemento ].	^ memento result.! !!PPMemoizedParser methodsFor: 'parsing'!reset: aPPContext	buffer := Dictionary new.	identifier := aPPContext identifier.! !!PPMemoizedParser methodsFor: 'operators'!memoized	"Ther is no point in memoizing more than once."	^ self! !!PPMemoizedParser methodsFor: 'operators'!nonMemoized	^ parser! !PPDelegateParser subclass: #PPNotParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPNotParser commentStamp: '' prior: 0!The not-predicate, a parser that succeeds whenever its delegate does not, but consumes no input [Parr 1994, 1995].!!PPNotParser methodsFor: 'parsing'!parseOn: aPPContext	| element memento |	memento := aPPContext remember.	element := parser parseOn: aPPContext.	aPPContext restore: memento.	^ element isPetitFailure		ifFalse: [ PPFailure message: '' context: aPPContext ]! !!PPNotParser methodsFor: '*PetitAnalyzer'!isFirstSetTerminal	^ true! !!PPNotParser methodsFor: '*PetitAnalyzer'!firstSets: aFirstDictionary into: aSet	! !!PPNotParser methodsFor: '*PetitGui'!displayDescription	^ 'not'! !!PPNotParser methodsFor: '*PetitGui'!exampleOn: aStream! !PPDelegateParser subclass: #PPOptionalParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPOptionalParser commentStamp: '' prior: 0!A parser that optionally parsers its delegate, or answers nil.!!PPOptionalParser methodsFor: 'parsing'!parseOn: aPPContext	| element |	element := parser parseOn: aPPContext.	^ element isPetitFailure ifFalse: [ element ]! !!PPOptionalParser methodsFor: '*PetitGui'!visualizationGraphType	^ '?'! !!PPOptionalParser methodsFor: '*PetitAnalyzer'!isNullable	^ true! !PPParser subclass: #PPPluggableParser	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPluggableParser commentStamp: '' prior: 0!A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.Instance Variables:	block	<BlockClosure>	The pluggable one-argument block.!!PPPluggableParser methodsFor: 'accessing'!block	"Answer the pluggable block."	^ block! !!PPPluggableParser methodsFor: 'initialization'!initializeOn: aBlock	block := aBlock! !!PPPluggableParser methodsFor: '*PetitGui'!displayName	^ String streamContents: [ :stream | block sourceNode printOn: stream ]! !!PPPluggableParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self block = aParser block ]! !!PPPluggableParser methodsFor: 'parsing'!parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := block value: aPPContext.	result isPetitFailure		ifTrue: [ aPPContext restore: memento ].	^ result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPPluggableParser class	instanceVariableNames: ''!!PPPluggableParser class methodsFor: 'instance creation'!on: aBlock	^ self new initializeOn: aBlock! !PPParser subclass: #PPPredicateParser	instanceVariableNames: 'predicate predicateMessage negated negatedMessage'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPredicateParser commentStamp: '' prior: 0!An abstract parser that accepts if a given predicate holds.Instance Variables:	predicate	<BlockClosure>	The block testing for the predicate.	predicateMessage	<String>	The error message of the predicate.	negated	<BlockClosure>	The block testing for the negation of the predicate.	negatedMessage	<String>	The error message of the negated predicate.!!PPPredicateParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self block = aParser block and: [ self message = aParser message ] ]! !!PPPredicateParser methodsFor: 'accessing'!block	"Answer the predicate block of the receiver."		^ predicate! !!PPPredicateParser methodsFor: 'accessing'!message	"Answer the failure message."		^ predicateMessage! !!PPPredicateParser methodsFor: '*PetitGui'!displayName	^ predicateMessage! !!PPPredicateParser methodsFor: '*PetitGui'!exampleOn: aStream	"Produce a random character that is valid. If there are characters in the alpha-numeric range prefer those over all others."	| valid normal |	valid := Character allCharacters		select: [ :char | self matches: (String with: char) ].	normal := valid		select: [ :char | char asInteger < 127 and: [ char isAlphaNumeric ] ].	aStream nextPut: (normal isEmpty		ifTrue: [ valid atRandom ]		ifFalse: [ normal atRandom ])! !!PPPredicateParser methodsFor: 'printing'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: predicateMessage! !PPPredicateParser subclass: #PPPredicateObjectParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPredicateObjectParser commentStamp: '' prior: 0!A parser that accepts if a given predicate on one element of the input sequence holds.!!PPPredicateObjectParser methodsFor: 'parsing'!parseOn: aPPContext	^ (aPPContext atEnd not and: [ predicate value: aPPContext uncheckedPeek ])		ifFalse: [ PPFailure message: predicateMessage context: aPPContext ]		ifTrue: [ aPPContext next ]! !!PPPredicateObjectParser methodsFor: 'operators'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage 		negated: predicate message: predicateMessage! !!PPPredicateObjectParser methodsFor: 'initialization'!initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPPredicateObjectParser class	instanceVariableNames: 'cache'!!PPPredicateObjectParser class methodsFor: 'factory-chars'!lf	^self		cacheAt: #'lf'		ifAbsentPut: [ self char: (Character codePoint: 10) ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!char: aCharacter message: aString	^ self expect: aCharacter message: aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!blank	^self		cacheAt: #'blank'		ifAbsentPut: [ self			chars: (String with: Character space with: Character tab) message: 'blank expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!newline	^self		cacheAt: #'newline'		ifAbsentPut: [ self chars: (String with: (Character codePoint: 13) with: (Character codePoint: 10)) message: 'newline expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!punctuation	^self		cacheAt: #'punctuation'		ifAbsentPut: [ self chars: '.,"''?!!;:#$%&()*+-/<>=@[]\^_{}|~' message: 'punctuation expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!space	^self		cacheAt: #'space'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isSeparator ]) message: 'separator expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!tab	^self		cacheAt: #'tab'		ifAbsentPut: [ self char: Character tab message: 'tab expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!word	^self		cacheAt: #'word'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isAlphaNumeric ]) message: 'letter or digit expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!uppercase	^self		cacheAt: #'uppercase'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isUppercase ]) message: 'uppercase letter expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!letter	^self		cacheAt: #'letter'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isLetter ]) message: 'letter expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!lowercase	^self		cacheAt: #'lowercase'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isLowercase ]) message: 'lowercase letter expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!hex	^self		cacheAt: #'hex'		ifAbsentPut: [ self		on: (PPCharSetPredicate on: [ :char | 			(char between: $0 and: $9) 				or: [ (char between: $a and: $f) 				or: [ (char between: $A and: $F) ] ] ])		message: 'hex digit expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!chars: aCollection message: aString	^ self on: (PPCharSetPredicate on: [ :char | aCollection includes: char ]) message: aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!digit	^self		cacheAt: #'digit'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isDigit ]) message: 'digit expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!char: aCharacter	^ self expect: aCharacter message: (String with: $" with: aCharacter with: $") , ' expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars'!cr	^self		cacheAt: #'cr'		ifAbsentPut: [ self char: (Character codePoint: 13) message: 'carriage return expected' ]! !!PPPredicateObjectParser class methodsFor: 'cache'!cacheAt: aSymbol ifAbsentPut: aBlock	cache ifNil: [ cache := Dictionary new ].	^(cache		at: aSymbol		ifAbsentPut: aBlock) copy! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!startOfLine		^ PPStartOfLineParser new.! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!any	^self		cacheAt: #'any'		ifAbsentPut: [ self			on: [ :each | true ] message: 'input expected'			negated: [ :each | false ] message: 'no input expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!between: min and: max	^ self		on: [ :each | each >= min and: [ each <= max ] ] message: min printString , '..' , max printString , ' expected'		negated: [ :each | each < min or: [ each > max ] ] message: min printString , '..' , max printString , ' not expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!expect: anObject	^ self expect: anObject message: anObject printString , ' expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!endOfLine		^ PPEndOfLineParser new.! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!eof		^ PPEndOfFileParser new! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!startOfWord		^ PPStartOfWordParser new.! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!anyExceptAnyOf: aCollection	^ self		on: [ :each | (aCollection includes: each) not ] message: 'any except ' , aCollection printString , ' expected'		negated: [ :each | aCollection includes: each ] message: aCollection printString ,  ' not expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!startOfLogicalLine		^ PPStartOfLogicalLineParser new.! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!expect: anObject message: aString	^ self 		on: [ :each | each = anObject ] message: aString		negated: [ :each | each ~= anObject ] message: 'no ' , aString! !!PPPredicateObjectParser class methodsFor: 'factory-objects'!anyOf: aCollection	^ self		on: [ :each | aCollection includes: each ] message: 'any of ' , aCollection printString , ' expected'		negated: [ :each | (aCollection includes: each) not ] message: 'none of ' , aCollection printString ,  'expected'! !!PPPredicateObjectParser class methodsFor: 'instance creation'!on: aBlock message: aString	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString! !!PPPredicateObjectParser class methodsFor: 'instance creation'!on: aBlock message: aString negated: aNegatedBlock message: aNegatedString	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString! !PPPredicateParser subclass: #PPPredicateSequenceParser	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPredicateSequenceParser commentStamp: '' prior: 0!A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.Instance Variables:	size	<Integer>	The number of elements to consume.!!PPPredicateSequenceParser methodsFor: 'accessing'!size	"Answer the sequence size of the receiver."	^ size! !!PPPredicateSequenceParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self size = aParser size ]! !!PPPredicateSequenceParser methodsFor: 'operators'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage		negated: predicate message: predicateMessage		size: size! !!PPPredicateSequenceParser methodsFor: 'initialization'!initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString.	size := anInteger ! !!PPPredicateSequenceParser methodsFor: 'parsing'!parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := aPPContext stream next: size.	(result size = size and: [ predicate value: result ])		ifTrue: [ ^ result ].	aPPContext restore: memento.	^ PPFailure message: predicateMessage context: aPPContext! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPPredicateSequenceParser class	instanceVariableNames: ''!!PPPredicateSequenceParser class methodsFor: 'instance creation'!on: aBlock message: aString size: anInteger	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString size: anInteger ! !!PPPredicateSequenceParser class methodsFor: 'instance creation'!on: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger 	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger! !PPDelegateParser subclass: #PPRepeatingParser	instanceVariableNames: 'min max'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPRepeatingParser commentStamp: '' prior: 0!An abstract parser that repeatedly parses between 'min' and 'max' instances of its delegate. The default configuration parses an infinite number of elements, as 'min' is set to 0 and 'max' to infinity (SmallInteger maxVal).Instance Variables:	min	<Integer>	The minimum number of repetitions.	max	<Integer>	The maximum number of repetitions.!!PPRepeatingParser methodsFor: '*PetitAnalyzer'!followSets: aFollowDictionary firstSets: aFirstDictionary into: aSet	| firstSet |	super followSets: aFollowDictionary firstSets:  aFirstDictionary into: aSet.		firstSet := aFirstDictionary at: self.	self children do: [:p | (aFollowDictionary at: p) addAll: (firstSet reject: [:each | each isNullable]) ]! !!PPRepeatingParser methodsFor: '*PetitAnalyzer'!isNullable	^ min = 0! !!PPRepeatingParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self min = aParser min and: [ self max = aParser max ] ]! !!PPRepeatingParser methodsFor: '*PetitGui'!visualizationGraphType	^ '*'! !!PPRepeatingParser methodsFor: '*PetitGui'!displayDescription	^ String streamContents: [ :stream |		min = 0 			ifFalse: [ stream print: min; nextPutAll: '..' ].		max = SmallInteger maxVal			ifTrue: [ stream nextPut: $* ]			ifFalse: [ stream print: max ] ]! !!PPRepeatingParser methodsFor: '*PetitGui'!exampleOn: aStream	"Perform the minimal repeatitions required, and a random amount of more if possible and if not that much output has been produced yet."		min timesRepeat: [ 		super exampleOn: aStream ].	(max - min min: 5) atRandom timesRepeat: [		aStream position > 512			ifTrue: [ ^ self ].		super exampleOn: aStream ]! !!PPRepeatingParser methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ['; print: min; nextPutAll: ', '; nextPutAll: (max = SmallInteger maxVal		ifTrue: [ '*' ] ifFalse: [ max printString ]); nextPut: $]! !!PPRepeatingParser methodsFor: 'accessing'!max	"Answer the maximum number of repetitions."	^ max! !!PPRepeatingParser methodsFor: 'accessing'!min	"Answer the minimum number of repetitions."		^ min! !!PPRepeatingParser methodsFor: 'initialization'!setMin: anInteger	min := anInteger! !!PPRepeatingParser methodsFor: 'initialization'!initialize	super initialize.	self setMin: 0; setMax: SmallInteger maxVal! !!PPRepeatingParser methodsFor: 'initialization'!setMax: anInteger	max := anInteger! !PPRepeatingParser subclass: #PPLimitedRepeatingParser	instanceVariableNames: 'limit'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLimitedRepeatingParser commentStamp: '' prior: 0!An abstract parser that repeatedly parses between 'min' and 'max' instances of my delegate and that requires the input to be completed with a specified parser 'limit'. Subclasses provide repeating behavior as typically seen in regular expression implementations (non-blind).Instance Variables:	limit	<PPParser>	The parser to complete the input with.!!PPLimitedRepeatingParser methodsFor: 'accessing'!limit	"Answer the parser that limits (or ends) this repetition."		^ limit! !!PPLimitedRepeatingParser methodsFor: 'accessing'!children	^ Array with: parser with: limit! !!PPLimitedRepeatingParser methodsFor: 'initialization'!setLimit: aParser	limit := aParser! !!PPLimitedRepeatingParser methodsFor: '*PetitAnalyzer'!replace: aParser with: anotherParser	super replace: aParser with: anotherParser.	limit == aParser ifTrue: [ limit := anotherParser ]! !!PPLimitedRepeatingParser methodsFor: 'parsing'!matchesLimitOn: aPPContext	| element position |	position := aPPContext remember.	element := limit parseOn: aPPContext.	aPPContext restore: position.	^ element isPetitFailure not! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPLimitedRepeatingParser class	instanceVariableNames: ''!!PPLimitedRepeatingParser class methodsFor: 'instance creation'!on: aParser limit: aLimitParser	^ (self on: aParser) setLimit: aLimitParser! !PPLimitedRepeatingParser subclass: #PPGreedyRepeatingParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPGreedyRepeatingParser commentStamp: '' prior: 0!A greedy repeating parser, commonly seen in regular expression implementations. It aggressively consumes as much input as possible and then backtracks to meet the 'limit' condition.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])		with: (limit and ==> [ :each | OrderedCollection new ])).	^ parser ==> [ :rest | rest asArray ]!!PPGreedyRepeatingParser methodsFor: 'parsing'!parseOn: aPPContext	| memento element elements positions |	memento := aPPContext remember.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [ 		(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [ 			aPPContext restore: memento.			^ element ].		elements addLast: element ].	positions := OrderedCollection with: aPPContext remember.	[ elements size < max and: [ (element := parser parseOn: aPPContext) isPetitFailure not ] ] whileTrue: [		elements addLast: element.		positions addLast: aPPContext remember ].	[ positions isEmpty ] whileFalse: [		aPPContext restore: positions last.		element := limit parseOn: aPPContext.		element isPetitFailure ifFalse: [			aPPContext restore: positions last.			^ elements asArray ].		elements isEmpty ifTrue: [			aPPContext restore: memento.			^ element ].		elements removeLast.		positions removeLast ].	aPPContext restore: memento.	^ PPFailure message: 'overflow' context: aPPContext at: memento position! !PPLimitedRepeatingParser subclass: #PPLazyRepeatingParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLazyRepeatingParser commentStamp: '' prior: 0!A lazy repeating parser, commonly seen in regular expression implementations. It limits its consumption to meet the 'limit' condition as early as possible.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (limit and ==> [ :each | OrderedCollection new ])		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])).	^ parser ==> [ :rest | rest asArray ]!!PPLazyRepeatingParser methodsFor: 'parsing'!parseOn: aPPContext	| memento element elements |	memento := aPPContext remember.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [		(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements addLast: element ].	[ self matchesLimitOn: aPPContext ] whileFalse: [		elements size < max ifFalse: [			aPPContext restore: memento.			^ PPFailure message: 'overflow' context: aPPContext at: memento position ].		element := parser parseOn: aPPContext.		element isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements addLast: element ].	^ elements asArray! !PPRepeatingParser subclass: #PPPossessiveRepeatingParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPossessiveRepeatingParser commentStamp: '' prior: 0!The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager).!!PPPossessiveRepeatingParser methodsFor: 'parsing'!parseOn: aPPContext	| memento element elements |	memento := aPPContext remember.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [		(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements addLast: element ].	[ elements size < max ] whileTrue: [	 	(element := parser parseOn: aPPContext) isPetitFailure			ifTrue: [ ^ elements asArray ].		elements addLast: element ].	^ elements asArray! !PPListParser subclass: #PPSequenceParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPSequenceParser commentStamp: '' prior: 0!A parser that parses a sequence of parsers.!!PPSequenceParser methodsFor: '*PetitGui'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeSeen: aSet depth: anInteger do: [ :cc |		self children			inject: self newRowMorph			into: [ :result :each | 				result 					addMorphBack: (cc value: each);					yourself ] ]! !!PPSequenceParser methodsFor: '*PetitGui'!visualizationGraphType	^ ','! !!PPSequenceParser methodsFor: '*PetitGui'!exampleOn: aStream	parsers do: [ :each | each exampleOn: aStream ]! !!PPSequenceParser methodsFor: '*PetitAnalyzer'!followSets: aFollowDictionary firstSets: aFirstDictionary into: aSet	parsers keysAndValuesDo: [ :index :parser |		| followSet firstSet |		followSet := aFollowDictionary at: parser.		index = parsers size			ifTrue: [ followSet addAll: aSet ]			ifFalse: [				(self class withAll: (parsers 					copyFrom: index + 1 to: parsers size))						firstSets: aFirstDictionary						into: (firstSet := IdentitySet new).				(firstSet anySatisfy: [ :each | each isNullable ])					ifTrue: [ followSet addAll: aSet ].				followSet addAll: (firstSet 					reject: [ :each | each isNullable ]) ] ]! !!PPSequenceParser methodsFor: '*PetitAnalyzer'!firstSets: aFirstDictionary into: aSet	| nullable |	parsers do: [ :parser |		nullable := false.		(aFirstDictionary at: parser) do: [ :each |			each isNullable				ifTrue: [ nullable := true ]				ifFalse: [ aSet add: each ] ].		nullable			ifFalse: [ ^ self ] ].	aSet add: PPSentinel instance! !!PPSequenceParser methodsFor: '*PetitAnalyzer'!cycleSet: aDictionary	| firstSet |	1 to: parsers size do: [ :index |		firstSet := aDictionary at: (parsers at: index).		(firstSet anySatisfy: [ :each | each isNullable ])			ifFalse: [ ^ parsers copyFrom: 1 to: index ] ].	^ parsers! !!PPSequenceParser methodsFor: 'operators'!, aRule	^ self copyWith: aRule! !!PPSequenceParser methodsFor: 'operators-mapping'!map: aBlock	^ aBlock numArgs = self children size		ifTrue: [ self ==> [ :nodes | aBlock valueWithArguments: nodes ] ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]! !!PPSequenceParser methodsFor: 'operators-mapping'!permutation: anArrayOfIntegers	"Answer a permutation of the receivers sequence."		anArrayOfIntegers do: [ :index |		(index isInteger and: [ index between: 1 and: parsers size ])			ifFalse: [ self error: 'Invalid permutation index: ' , index printString ] ].	^ self ==> [ :nodes | anArrayOfIntegers collect: [ :index | nodes at: index ] ]! !!PPSequenceParser methodsFor: 'parsing'!parseOn: aPPContext	"This is optimized code that avoids unnecessary block activations, do not change."		| memento elements element |	memento := aPPContext remember.	elements := Array new: parsers size.	1 to: parsers size do: [ :index |		element := (parsers at: index) 			parseOn: aPPContext.		element isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements at: index put: element ].	^ elements! !PPParser subclass: #PPStartOfLineParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPStartOfLineParser commentStamp: '' prior: 0!A PPStartOfLineParser is that does not fail, if the stream position is at the beginning of a line. It does not consume anything.!!PPStartOfLineParser methodsFor: 'parsing'!parseOn: aPPContext	(aPPContext isStartOfLine) ifTrue: [ 		^ #startOfLine	].	^ PPFailure message: 'Start of line expected' context: aPPContext at: aPPContext position! !PPParser subclass: #PPStartOfLogicalLineParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPStartOfLogicalLineParser commentStamp: '' prior: 0!A PPStartOfLogicalLineParser is that does not fail, if the stream position is at the first non-blank character of a line. It does not consume anything.!!PPStartOfLogicalLineParser methodsFor: 'as yet unclassified'!isBlank: character	^ (character == Character space or: [character == Character tab])! !!PPStartOfLogicalLineParser methodsFor: 'as yet unclassified'!parseOn: aPPContext	aPPContext peek isAlphaNumeric ifFalse: [ 		^ PPFailure message: 'Start of logical line expected' context: aPPContext 	].	aPPContext isStartOfLine ifTrue: [ ^ #startOfLogicalLine ].			[ aPPContext position ~= 0 ] whileTrue: [  		aPPContext back.		(self isBlank: aPPContext peek) ifFalse: [ 			^ PPFailure message: 'Start of logical line expected' context: aPPContext		].		aPPContext isStartOfLine ifTrue: [ ^ #startOfLogicalLine ].	]! !PPParser subclass: #PPStartOfWordParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPStartOfWordParser commentStamp: '' prior: 0!A PPStartOfWordParser is that matches a word boundary.I return success if no word character preceeds my position and if word chracter succeeds my position.Word characters are any alphanumeric characters.!!PPStartOfWordParser methodsFor: 'as yet unclassified'!acceptsEpsilon	^ false! !!PPStartOfWordParser methodsFor: 'as yet unclassified'!parseOn: aPPContext	aPPContext atEnd ifTrue: [  		^ PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	].	(aPPContext position == 0) ifTrue: [ 		(aPPContext peek isAlphaNumeric) ifTrue: [ 			^ #startOfWord		] ifFalse: [ 			^ PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	 	]	].	aPPContext back.	aPPContext peek isAlphaNumeric ifTrue: [		^ PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	].	aPPContext next.		^ aPPContext peek isAlphaNumeric ifTrue: [ #startOfWord ] ifFalse: [ 		PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	]	! !PPFlattenParser subclass: #PPTokenParser	instanceVariableNames: 'tokenClass'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPTokenParser commentStamp: '' prior: 0!A parser that answers a token with the value of my delegate parses.Instance Variables:	tokenClass	<PPToken class>	The token sub-class to be used.!!PPTokenParser methodsFor: 'private'!defaultTokenClass	^ PPToken! !!PPTokenParser methodsFor: 'private'!on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ self tokenClass on: aCollection start: aStartInteger stop: aStopInteger value: anObject! !!PPTokenParser methodsFor: 'initialization'!initialize	tokenClass := self defaultTokenClass	! !!PPTokenParser methodsFor: '*PetitAnalyzer'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self tokenClass = aParser tokenClass ]! !!PPTokenParser methodsFor: 'accessing'!tokenClass	^ tokenClass! !!PPTokenParser methodsFor: 'accessing'!tokenClass: aTokenClass	tokenClass := aTokenClass! !PPDelegateParser subclass: #PPTrimmingParser	instanceVariableNames: 'trimmer'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPTrimmingParser commentStamp: '' prior: 0!A parser that silently consumes spaces before and after the delegate parser.!!PPTrimmingParser methodsFor: '*PetitGui'!exampleOn: aStream	super exampleOn: aStream.	aStream nextPut: Character space! !!PPTrimmingParser methodsFor: 'parsing'!parseOn: aPPContext	| memento element trimContext |	memento := aPPContext remember.	trimContext := aPPContext copy.	[ (trimmer parseOn: trimContext) isPetitFailure ]		whileFalse.	element := parser parseOn: aPPContext.	element isPetitFailure ifTrue: [		aPPContext restore: memento.		^ element ].	[ (trimmer parseOn: trimContext) isPetitFailure ]		whileFalse.	^ element! !!PPTrimmingParser methodsFor: 'initialization'!setTrimmer: aParser	trimmer := aParser! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPTrimmingParser class	instanceVariableNames: ''!!PPTrimmingParser class methodsFor: 'instance creation'!on: aParser trimmer: aTrimParser	^ self new		setParser: aParser;		setTrimmer: aTrimParser;		yourself! !PPActionParser subclass: #PPWrappingParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPWrappingParser commentStamp: '' prior: 0!A parser that performs an action block upon activation with the stream and a continuation block.!!PPWrappingParser methodsFor: 'parsing'!parseOn: aPPContext	^ block value: aPPContext value: [ parser parseOn: aPPContext ]! !Object subclass: #PPContext	instanceVariableNames: 'stream root properties globals furthestFailure'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Core'!!PPContext commentStamp: '' prior: 0!A PPContext is provides contextual information to the parsing function.Instance Variables	globals:		<Dictionary>	properties:		<Dictionar>	root:		<PPParser>	stream:		<PPStream>globals	- properties that are not restored after backtrackingproperties	- properties that are restored after backtrackingroot	- the root parserstream	- input stream!!PPContext methodsFor: 'memoization'!restoreProperties: aPPContextMemento	aPPContextMemento stream == stream ifFalse: [ self error: 'Oops!!' ].		properties ifNil: [ ^ self ].		properties keysDo: [ :key |		(aPPContextMemento hasProperty: key)			ifTrue: [ properties at: key put: (aPPContextMemento propertyAt: key) ]			ifFalse: [ properties removeKey: key  ]. 	].	aPPContextMemento keysAndValuesDo: [ :key :value |		properties at: key put: value	]! !!PPContext methodsFor: 'memoization'!restore: aPPContextMemento	aPPContextMemento stream == stream ifFalse: [ self error: 'Oops!!' ].	stream position: aPPContextMemento position.	self restoreProperties: aPPContextMemento.! !!PPContext methodsFor: 'memoization'!remember	| memento |	memento := PPContextMemento new		stream: stream;		position: stream position;		yourself.			self rememberProperties: memento.	^ memento! !!PPContext methodsFor: 'memoization'!size	^ stream size! !!PPContext methodsFor: 'memoization'!identifier	"		I provide an identifier that is used by memoizing parser to figure out if the		cache should be flushed or not.	"	^ stream! !!PPContext methodsFor: 'memoization'!rememberProperties: aPPContextMemento	properties ifNil: [ ^ self ].		properties keysAndValuesDo: [ :key :value |		aPPContextMemento propertyAt: key put: value	].! !!PPContext methodsFor: 'initialization'!initializeFor: parser	root := parser.! !!PPContext methodsFor: 'initialization'!initialize	stream := nil.! !!PPContext methodsFor: 'initialization'!reset	properties := nil.	globals := nil.! !!PPContext methodsFor: 'failures'!furthestFailure	" the furthest failure encountered while parsing the input stream "		"^ self globalAt: #furthestFailure ifAbsent: [ nil ]"	"performance optimization:"	^ furthestFailure! !!PPContext methodsFor: 'failures'!noteFailure: aPPFailure	"record the furthest failure encountered while parsing the input stream "	( furthestFailure isNil or: [ aPPFailure position > furthestFailure position ]) 		ifTrue: [ furthestFailure := aPPFailure ].! !!PPContext methodsFor: 'accessing-globals'!globalAt: aKey ifAbsent: aBlock	"Answer the global property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ globals isNil		ifTrue: [ aBlock value ]		ifFalse: [ globals at: aKey ifAbsent: aBlock ]! !!PPContext methodsFor: 'accessing-globals'!removeGlobal: aKey ifAbsent: aBlock	"Remove the global property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	globals isNil ifTrue: [ ^ aBlock value ].	answer := globals removeKey: aKey ifAbsent: aBlock.	globals isEmpty ifTrue: [ globals := nil ].	^ answer! !!PPContext methodsFor: 'accessing-globals'!globals	^ globals! !!PPContext methodsFor: 'accessing-globals'!globalAt: aKey put: anObject	"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (globals ifNil: [ globals := Dictionary new: 1 ])		at: aKey put: anObject! !!PPContext methodsFor: 'accessing-globals'!globalAt: aKey	"Answer the global property value associated with aKey."		^ self globalAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContext methodsFor: 'accessing-globals'!removeGlobal: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeGlobal: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContext methodsFor: 'accessing-globals'!hasGlobal: aKey	"Test if the global property aKey is present."		^ globals notNil and: [ globals includesKey: aKey ]! !!PPContext methodsFor: 'accessing-globals'!globalAt: aKey ifAbsentPut: aBlock	"Answer the global property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]! !!PPContext methodsFor: 'accessing-properties'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PPContext methodsFor: 'accessing-properties'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer! !!PPContext methodsFor: 'accessing-properties'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContext methodsFor: 'accessing-properties'!properties	^ properties ! !!PPContext methodsFor: 'accessing-properties'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PPContext methodsFor: 'accessing-properties'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]! !!PPContext methodsFor: 'accessing-properties'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject! !!PPContext methodsFor: 'accessing-properties'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContext methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $:.	aStream nextPut: $ .	stream printOn: aStream! !!PPContext methodsFor: 'stream mimicry'!collection	^ stream collection  ! !!PPContext methodsFor: 'stream mimicry'!skipTo: anObject 	^ stream skipTo: anObject ! !!PPContext methodsFor: 'stream mimicry'!back	^ stream back! !!PPContext methodsFor: 'stream mimicry'!skipToAnyOf: aCharacterSet 	"Set the access position of the receiver to be past the next occurrence of	a character in the character set. Answer whether a fitting character is found."	[stream atEnd]		whileFalse: [ (aCharacterSet includes: stream next) ifTrue: [^true]].	^false! !!PPContext methodsFor: 'stream mimicry'!isEndOfLine	^ stream isEndOfLine! !!PPContext methodsFor: 'stream mimicry'!position	^ stream position! !!PPContext methodsFor: 'stream mimicry'!next: anInteger	^ stream next: anInteger! !!PPContext methodsFor: 'stream mimicry'!next	^ stream next! !!PPContext methodsFor: 'stream mimicry'!peek	^ stream peek! !!PPContext methodsFor: 'stream mimicry'!contents 	^ stream contents! !!PPContext methodsFor: 'stream mimicry'!skipToAll: aString	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern := aString readStream.	startMatch := nil.	[ pattern atEnd ] whileFalse: 		[ stream atEnd ifTrue: [ ^ false ].		stream next = pattern next 			ifTrue: [ pattern position = 1 ifTrue: [ startMatch := stream position ] ]			ifFalse: 				[ pattern position: 0.				startMatch ifNotNil: 					[ stream position: startMatch.					startMatch := nil ] ] ].	^ true! !!PPContext methodsFor: 'stream mimicry'!upToAll: whatever	^ stream upToAll: whatever! !!PPContext methodsFor: 'stream mimicry'!position: anInteger	^ stream position: anInteger! !!PPContext methodsFor: 'stream mimicry'!atEnd	^ stream atEnd! !!PPContext methodsFor: 'stream mimicry'!isStartOfLine	^ stream isStartOfLine! !!PPContext methodsFor: 'stream mimicry'!peekTwice	^ stream peekTwice! !!PPContext methodsFor: 'stream mimicry'!upTo: anObject	^ stream upTo: anObject! !!PPContext methodsFor: 'stream mimicry'!skip: anInteger 	^ stream skip: anInteger ! !!PPContext methodsFor: 'stream mimicry'!upToAnyOf: whatever	^ stream upToAnyOf: whatever! !!PPContext methodsFor: 'stream mimicry'!uncheckedPeek	^ stream uncheckedPeek! !!PPContext methodsFor: '*PetitGui'!gtGlobals: composite	<gtInspectorPresentationOrder: 50>		composite table		title: 'Globals';		column: 'Key' evaluated: [ :each | each key printString ];		column: 'Value' evaluated: [ :each | each value printString ];		display: [ :context |  (context globals ifNil: [ Dictionary new ]) associations ]! !!PPContext methodsFor: '*PetitGui'!gtIndentStack: composite	<gtInspectorPresentationOrder: 40>			composite list		title: 'Indent Stack';		display: [ :context | context indentStack contents ]! !!PPContext methodsFor: '*PetitGui'!gtProperties: composite	<gtInspectorPresentationOrder: 40>		composite table		title: 'Properties';		column: 'Key' evaluated: [ :each | each key printString ];		column: 'Value' evaluated: [ :each | each value printString ];		display: [ :context |  (context properties ifNil: [ Dictionary new ]) associations ]! !!PPContext methodsFor: '*PetitGui'!gtStream: composite	<gtInspectorPresentationOrder: 40>		composite text		title: 'Text';		display: [ :context | context stream printOn: (WriteStream on: String new) ]! !!PPContext methodsFor: 'copying'!postCopy	super postCopy.	globals := globals copy.	! !!PPContext methodsFor: 'acessing'!stream	^ stream! !!PPContext methodsFor: 'acessing'!root	^ root ! !!PPContext methodsFor: 'acessing'!stream: aStream	stream := aStream.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPContext class	instanceVariableNames: ''!!PPContext class methodsFor: 'as yet unclassified'!on: aPPParser stream: aStream	^ self basicNew 		initialize;		root: aPPParser;		stream: aStream asPetitStream;		yourself! !Object subclass: #PPContextMemento	instanceVariableNames: 'stream position properties'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Core'!!PPContextMemento methodsFor: 'comparing'!= anObject		(self == anObject) ifTrue: [ ^ true ].	(anObject class = PPContextMemento) ifFalse: [ ^ false ].		(anObject stream == stream) ifFalse: [ ^ false ].	(anObject position == position) ifFalse: [ ^ false ].		(self propertiesSize == anObject propertiesSize) ifFalse: [ ^ false ].	self keysAndValuesDo: [ :key :value |		(anObject hasProperty: key) ifFalse: [ ^ false ].		((anObject propertyAt: key) = value) ifFalse: [ ^ false ].  	].		^ true.! !!PPContextMemento methodsFor: 'comparing'!hash	^ (position hash bitXor: stream hash) bitXor: properties hash.! !!PPContextMemento methodsFor: 'accessing - properties'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PPContextMemento methodsFor: 'accessing - properties'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer! !!PPContextMemento methodsFor: 'accessing - properties'!keysAndValuesDo: aBlock	properties ifNil: [ ^ self ].	properties keysAndValuesDo: [ :key :value | aBlock value: key value: value copy ] ! !!PPContextMemento methodsFor: 'accessing - properties'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContextMemento methodsFor: 'accessing - properties'!propertiesSize	properties ifNil: [ ^ 0 ].	^ properties size.! !!PPContextMemento methodsFor: 'accessing - properties'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PPContextMemento methodsFor: 'accessing - properties'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		properties isNil		ifTrue: [ ^ aBlock value ]		ifFalse: [ 			(properties includesKey: aKey) ifTrue: [ 				^ (properties at: aKey) copy			].			^ aBlock value		]! !!PPContextMemento methodsFor: 'accessing - properties'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: (anObject copy)! !!PPContextMemento methodsFor: 'accessing - properties'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContextMemento methodsFor: 'accessing'!position	^ position! !!PPContextMemento methodsFor: 'accessing'!stream	^ stream! !!PPContextMemento methodsFor: 'accessing'!stream: aStream	stream := aStream! !!PPContextMemento methodsFor: 'accessing'!position: anInteger	position := anInteger ! !Object subclass: #PPFailure	instanceVariableNames: 'message context position'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Core'!!PPFailure commentStamp: '' prior: 0!The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.Instance Variables:	message	<String>	The error message of this failure.	position	<Integer>	The position of this failure in the input stream.!!PPFailure methodsFor: 'printing'!printOn: aStream	aStream 		nextPutAll: (self message ifNil: ['<message not specified>']); 		nextPutAll: ' at '; print: self position! !!PPFailure methodsFor: 'testing'!isPetitFailure	"I am the only class that should implement this method to return true."	^ true! !!PPFailure methodsFor: '*PetitGui'!sampleIn: composite	(composite text)		title: 'Sample';		display: [:res | res findStream contents ifNil: [''] ];		allowNil.! !!PPFailure methodsFor: '*PetitGui'!debugResult	context ifNil: [ ^ nil ].	context root ifNil: [ ^ nil ].		^ context root enableDebug parse: context stream reset! !!PPFailure methodsFor: '*PetitGui'!treeViewIn: composite	composite tree		title: 'Execution Traces';		format: [:resultNode | resultNode formattedText ];		children: [:resultNode | resultNode children ]. ! !!PPFailure methodsFor: '*PetitGui'!gtDebugView: composite	<gtInspectorPresentationOrder: 40>	| browser |	browser := 		composite tabulator.	browser title: 'Debug View'.	browser row: #tree;			  row: #source.	browser transmit 		fromOutsideEntityPort; 		toOutsidePort: #debugResult;		transformed: [ :failure | failure debugResult  ].					browser transmit 		from: #tree;		to: #source port: #selectionInterval;		transformed: [:debuggingResult |			debuggingResult ifNotNil: [			debuggingResult start to: debuggingResult end]		].	browser transmit		fromOutsidePort: #debugResult;		to: #source;		andShow: [ :a |  self sampleIn: a ].		browser transmit 		fromOutsidePort: #debugResult;		to: #tree;		andShow: [ :a | self treeViewIn: a ].			browser startOn: self! !!PPFailure methodsFor: 'initialization'!initializeMessage: aString		message := aString.! !!PPFailure methodsFor: 'initialization'!initializeMessage: aString context: aPPContext	self initializeMessage: aString context:  aPPContext position: aPPContext position! !!PPFailure methodsFor: 'initialization'!initializeMessage: aString at: anInteger	"One should not use this method if the furthest failure is supposed to be reported correctly"	message := aString.	position := anInteger.! !!PPFailure methodsFor: 'initialization'!initializeMessage: aString context: aPPContext position: anInteger	message := aString.	context := aPPContext.	position := anInteger.		"record the furthest failure encountered while parsing the input stream "	aPPContext noteFailure: self.	! !!PPFailure methodsFor: 'accessing'!position	"Answer the position in the source string that caused this parse failure."	^ position! !!PPFailure methodsFor: 'accessing'!message	"Answer a human readable error message of this parse failure."		^ message! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPFailure class	instanceVariableNames: ''!!PPFailure class methodsFor: '*PetitGui'!gtExampleEmptyMessage	<gtExample>	<label: 'Failure: empty'>		^ self message: ''! !!PPFailure class methodsFor: '*PetitGui'!gtExampleNumberExpected	<gtExample>	<label: 'Failure: Number expected'>		^ #digit asParser plus parse: 'a'! !!PPFailure class methodsFor: 'instance creation'!message: aString context: aPPContext at: position	^ self basicNew initializeMessage: aString context: aPPContext position: position! !!PPFailure class methodsFor: 'instance creation'!message: aString	^ self basicNew initializeMessage: aString ! !!PPFailure class methodsFor: 'instance creation'!message: aString at: anInteger	"One should not use this method if the furthest failure is supposed to be reported correctly"	^ self basicNew initializeMessage: aString at: anInteger! !!PPFailure class methodsFor: 'instance creation'!message: aString context: aPPContext	^ self basicNew initializeMessage: aString context: aPPContext! !Object subclass: #PPMemento	instanceVariableNames: 'result count context'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Core'!!PPMemento commentStamp: '' prior: 0!PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.Instance Variables:	result	<Object>	The cached result.	count	<Integer>	The number of recursive cycles followed.	!!PPMemento methodsFor: 'initialization'!initialize	count := 0	! !!PPMemento methodsFor: 'accessing'!contextMemento: aPPContextMemento	context  := aPPContextMemento ! !!PPMemento methodsFor: 'accessing'!result: anObject	result := anObject! !!PPMemento methodsFor: 'accessing'!result	^ result! !!PPMemento methodsFor: 'accessing'!contextMemento	^ context! !!PPMemento methodsFor: 'actions'!increment	count := count + 1! !!PPMemento methodsFor: 'accessing-readonly'!count	^ count! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPMemento class	instanceVariableNames: ''!!PPMemento class methodsFor: 'instance creation'!new	^ self basicNew initialize! !ReadStream subclass: #PPStream	instanceVariableNames: 'newlines'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Core'!!PPStream commentStamp: '' prior: 0!A positional stream implementation used for parsing. It overrides some methods for optimization reasons.!!PPStream methodsFor: 'accessing'!peek	"An improved version of peek, that is slightly faster than the built in version."	^ self atEnd ifFalse: [ collection at: position + 1 ]! !!PPStream methodsFor: 'accessing'!next: anInteger 	"Answer up to anInteger elements of my collection. Overridden for efficiency."	| answer endPosition |	endPosition := position + anInteger min: readLimit.	answer := collection copyFrom: position + 1 to: endPosition.	position := endPosition.	^ answer! !!PPStream methodsFor: 'accessing'!collection	"Answer the underlying collection."		^ collection! !!PPStream methodsFor: 'accessing'!uncheckedPeek	"An unchecked version of peek that throws an error if we try to peek over the end of the stream, even faster than #peek."	^ collection at: position + 1! !!PPStream methodsFor: 'accessing'!size	"		The same implementation as a ReadStream. Implemented here for compatibility with Smalltalk/X		that has different implementation in a ReadStream	"	^readLimit! !!PPStream methodsFor: 'accessing'!position: anInteger	"The receiver does not check for invalid arguments passed to this method, as it is solely used with valid indexes for backtracking."	position := anInteger! !!PPStream methodsFor: 'printing'!printOn: aStream	collection isString		ifFalse: [ ^ super printOn: aStream ].	aStream		nextPutAll: (collection copyFrom: 1 to: position);		nextPutAll: '';		nextPutAll: (collection copyFrom: position + 1 to: readLimit)! !!PPStream methodsFor: 'converting'!asPetitStream	^ self! !!PPStream methodsFor: 'positioning'!fillNewlines	| tmp line |	newlines := OrderedCollection new.			tmp := position.	line := 0.		(0 to: readLimit) do: [:index |		position := index.		self isStartOfLine ifTrue: [ newlines add: position ]	].	position := tmp.	newlines := newlines asArray.	^ newlines! !!PPStream methodsFor: 'positioning'!column: pos	| nl |	(pos = -1) ifTrue: [  ^ 0 ].	(pos > readLimit) ifTrue: [ ^ self error: 'Out of limit' ].		nl := self newlines.	1 to: nl size do: [ :index | 		((nl at: index) > pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1 ]	]."	nl keysAndValuesDo: [ :index :value |		(value > pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1]	].	"	^ pos - (nl at: (nl size )) + 1! !!PPStream methodsFor: 'positioning'!column	^ self column: position.! !!PPStream methodsFor: 'positioning'!line	^ self line: position! !!PPStream methodsFor: 'positioning'!newlines	^ newlines ifNil: [ 		newlines := self fillNewlines.	]! !!PPStream methodsFor: 'positioning'!line: pos	| nl |	(pos = -1) ifTrue: [  ^ 0 ].	(pos > readLimit) ifTrue: [ ^ self error: 'Out of limit' ].		nl := self newlines.	nl keysAndValuesDo: [ :index :value |		(value > pos) ifTrue: [ ^ (index - 1)]	].		^ nl size! !!PPStream methodsFor: 'queries'!isStartOfLine	(position = 0) ifTrue: [ ^ true ].	self insideCRLF ifTrue: [ ^ false ].		^ (self peekBack = (Character codePoint: 13)) or: [ self peekBack = (Character codePoint: 10)].! !!PPStream methodsFor: 'queries'!isEndOfLine	self atEnd ifTrue: [ ^ true ].	self insideCRLF ifTrue: [ ^ false ].	^ (self peek = (Character codePoint: 13) or: [ self peek = (Character codePoint: 10)]).! !!PPStream methodsFor: 'queries'!insideCRLF	(position < 1) ifTrue: [ ^ false ].		^ (self peek = (Character codePoint: 10)) and: [ self peekBack = (Character codePoint: 13) ]! !Object subclass: #PPToken	instanceVariableNames: 'collection start stop value'	classVariableNames: 'NewLineParser'	poolDictionaries: ''	category: 'PetitParser-Core'!!PPToken commentStamp: '' prior: 0!PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection and its start and stop position.Instance Variables:	collection	<SequenceableCollection>	The collection this token comes from.	start	<Integer>	The start position in the collection.	stop	<Integer>	The stop position in the collection.!!PPToken methodsFor: 'comparing'!= anObject	^ self class = anObject class and: [ self inputValue = anObject inputValue ]! !!PPToken methodsFor: 'comparing'!hash	^ self inputValue hash! !!PPToken methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $[; print: self start; nextPut: $,; print: self stop; nextPut: $].	aStream nextPut: $(; print: self inputValue; nextPut: $)! !!PPToken methodsFor: 'accessing'!start	"Answer the start position of this token in the underlying collection."	^ start! !!PPToken methodsFor: 'accessing'!stop	"Answer the stop position of this token in the underlying collection."		^ stop! !!PPToken methodsFor: 'accessing'!collection	"Answer the underlying collection of this token."	^ collection! !!PPToken methodsFor: 'accessing'!size	"Answer the size of this token in the underlying collection."	^ stop - start + 1! !!PPToken methodsFor: 'initialization'!initializeOn: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	collection := aSequenceableCollection.	start := aStartInteger.	stop := aStopInteger.	value := anObject! !!PPToken methodsFor: 'copying'!copyFrom: aStartInteger to: aStopInteger	^ self class on: collection start: start + aStartInteger - 1 stop: stop + aStopInteger - 3 value: value! !!PPToken methodsFor: 'accessing-values'!inputValue	"Answer the consumed input of this token."	^ collection copyFrom: start to: stop! !!PPToken methodsFor: 'accessing-values'!parsedValue	"Answer the parsed value of this token."	^ value! !!PPToken methodsFor: 'accessing-values'!value	self notify: 'Token>>#value is no longer supported. Instead use Token>>#inputValue'.	^ self inputValue! !!PPToken methodsFor: 'querying'!column	"Answer the column number of this token in the underlying collection."		| position |	position := 0.	(NewLineParser , [ :stream |		start <= stream position			ifTrue: [ ^ start - position ].		position := stream position ] asParser		/ #any asParser) star			parse: collection.	 ^ start - position! !!PPToken methodsFor: 'querying'!line	"Answer the line number of this token in the underlying collection."		| line |	line := 1.	(NewLineParser , [ :stream |		start <= stream position			ifTrue: [ ^ line ].		line := line + 1 ] asParser		/ #any asParser) star			parse: collection.	^ line! !!PPToken methodsFor: '*PetitGui'!gtInspectorSourceIn: composite	<gtInspectorPresentationOrder: 10> 	^ composite text 		title: 'Source';		display: [ self collection asString ];		initialize: [ :presentation | 			presentation selectionInterval: (self start to: self stop) ];		when: [ self collection notNil ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPToken class	instanceVariableNames: ''!!PPToken class methodsFor: 'initialization'!initialize	"Platform independent newline sequence. LF: Unix, CR+LF: Windows, and CR: Apple."	| cr lf |	cr := Character codePoint: 13.	lf := Character codePoint: 10.	NewLineParser := lf asParser / (cr asParser , lf asParser optional)! !!PPToken class methodsFor: 'instance creation'!on: aSequenceableCollection	^ self on: aSequenceableCollection start: 1 stop: aSequenceableCollection size value: nil! !!PPToken class methodsFor: 'instance creation'!on: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	^ self basicNew 		initializeOn: aSequenceableCollection		start: aStartInteger stop: aStopInteger		value: anObject! !!PPToken class methodsFor: 'instance creation'!new	self error: 'Token can only be created using a dedicated constructor.'! !PPToken initialize!Object subclass: #PPCharSetPredicate	instanceVariableNames: 'block classification'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Tools'!!PPCharSetPredicate methodsFor: 'evaluating'!value: aCharacter	| index |	index := aCharacter asInteger.	index == 0		ifTrue: [ ^ block value: aCharacter ].	index > 255		ifTrue: [ ^ block value: aCharacter ].	^ classification at: index! !!PPCharSetPredicate methodsFor: 'initialization'!initializeOn: aBlock	block := aBlock.	classification := Array new: 255.	1 to: classification size do: [ :index |		classification at: index put: (block			value: (Character codePoint: index)) ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPCharSetPredicate class	instanceVariableNames: ''!!PPCharSetPredicate class methodsFor: 'instance creation'!on: aBlock	^ self basicNew initializeOn: aBlock! !PPDelegateParser subclass: #PPCompositeParser	instanceVariableNames: 'dependencies'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Tools'!!PPCompositeParser commentStamp: '' prior: 0!A PPCompositeParser is composed parser built from various primitive parsers. Every production in the receiver is specified as a method that returns its parser. Note that every production requires an instance variable of the same name, otherwise the production is not cached and cannot be used in recursive grammars. Productions should refer to each other by reading the respective inst-var. Note: these inst-vars are typically not written, as the assignment happens in the initialize method using reflection.The start production is defined in the method start. It is aliased to the inst-var parser defined in the superclass of PPCompositeParser.!!PPCompositeParser methodsFor: 'initialization'!initializeStartingAt: aSymbol dependencies: aDictionary	self initialize.	parser := PPDelegateParser named: aSymbol.	self productionNames keysAndValuesDo: [ :key :value |		self instVarAt: key put: (PPDelegateParser named: value) ].	dependencies := aDictionary! !!PPCompositeParser methodsFor: 'querying'!productionAt: aSymbol ifAbsent: aBlock	"Answer the production named aSymbol, if there is no such production answer the result of evaluating aBlock."		(self class ignoredNames includes: aSymbol asString)		ifTrue: [ ^ aBlock value ].	(self class startSymbol = aSymbol)		ifTrue: [ ^ parser ].	^ self instVarAt: (self class allInstVarNames		indexOf: aSymbol asString		ifAbsent: [ ^ aBlock value ])! !!PPCompositeParser methodsFor: 'querying'!productionNames	"Answer a dictionary of slot indexes and production names."		| productionNames ignoredNames |	productionNames := Dictionary new.	ignoredNames := self class ignoredNames		collect: [ :each | each asSymbol ].	self class allInstVarNames keysAndValuesDo: [ :key :value |		(ignoredNames includes: value asSymbol)			ifFalse: [ productionNames at: key put: value asSymbol ] ].	^ productionNames! !!PPCompositeParser methodsFor: 'querying'!productionAt: aSymbol	"Answer the production named aSymbol."		^ self productionAt: aSymbol ifAbsent: [ nil ]! !!PPCompositeParser methodsFor: 'querying'!dependencyAt: aClass	"Answer the dependent parser aClass. Throws an error if this parser class is not declared in the method #dependencies on the class-side of the receiver."		^ dependencies at: aClass ifAbsent: [ self error: 'Undeclared dependency in ' , self class name , ' to ' , aClass name ]! !!PPCompositeParser methodsFor: '*PetitGui'!spotterForProductionsFor: aStep	<spotterOrder: 10>		aStep listProcessor		title: 'Productions';		allCandidates: [ (self productionNames collect: #value) asOrderedCollection ];		candidatesLimit: 5;		filter: GTFilterSubstring;		wantsToDisplayOnEmptyQuery: true! !!PPCompositeParser methodsFor: 'accessing'!start	"Answer the production to start this parser with."		self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPCompositeParser class	instanceVariableNames: ''!!PPCompositeParser class methodsFor: 'accessing'!ignoredNames	"Answer a collection of instance-variables that should not be automatically initialized with productions, but that are used internal to the composite parser."	^ PPCompositeParser allInstVarNames! !!PPCompositeParser class methodsFor: 'accessing'!startSymbol	"Answer the method that represents the default start symbol."	^ #start! !!PPCompositeParser class methodsFor: 'accessing'!dependencies	"Answer a collection of PPCompositeParser classes that this parser directly dependends on. Override this method in subclasses to declare dependent parsers. The default implementation does not depend on other PPCompositeParser."	^ #()! !!PPCompositeParser class methodsFor: '*PetitGui'!debug: anObject onError: aBlock	^ self debug: anObject startingAt: self startSymbol onError: aBlock! !!PPCompositeParser class methodsFor: '*PetitGui'!debug: anObject startingAt: aSymbol onError: aBlock	^ (self newStartingAt: aSymbol) debug: anObject onError: aBlock! !!PPCompositeParser class methodsFor: '*PetitGui'!debug: anObject	^ self debug: anObject startingAt: self startSymbol! !!PPCompositeParser class methodsFor: '*PetitGui'!debug: anObject startingAt: aSymbol	^ (self newStartingAt: aSymbol) debug: anObject! !!PPCompositeParser class methodsFor: 'instance creation'!newStartingAt: aSymbol	"Answer a new parser starting at aSymbol. The code makes sure to resolve all dependent parsers correctly."	| parsers remaining |	parsers := IdentityDictionary new.	remaining := OrderedCollection with: self.	[ remaining isEmpty ] whileFalse: [		| dependency |		dependency := remaining removeLast.		(parsers includesKey: dependency) ifFalse: [			parsers at: dependency put: dependency basicNew.			remaining addAll: dependency dependencies ] ].	parsers keysAndValuesDo: [ :class :parser |		| dependencies |		dependencies := IdentityDictionary new.		class dependencies 			do: [ :dependency | dependencies at: dependency put: (parsers at: dependency) ].		parser 			initializeStartingAt: (class == self				ifTrue: [ aSymbol ]				ifFalse: [ class startSymbol ]) 			dependencies: dependencies ].	parsers keysAndValuesDo: [ :class :parser |		parser setParser: (parser perform: parser children first name).		parser productionNames keysAndValuesDo: [ :key :value |			(parser instVarAt: key) setParser: (parser perform: value) ] ].	^ parsers at: self! !!PPCompositeParser class methodsFor: 'instance creation'!new	"Answer a new parser starting at the default start symbol."	^ self newStartingAt: self startSymbol! !!PPCompositeParser class methodsFor: 'parsing'!parse: anObject onError: aBlock	^ self parse: anObject startingAt: self startSymbol onError: aBlock! !!PPCompositeParser class methodsFor: 'parsing'!parse: anObject startingAt: aSymbol	^ (self newStartingAt: aSymbol) parse: anObject! !!PPCompositeParser class methodsFor: 'parsing'!parse: anObject startingAt: aSymbol onError: aBlock	^ (self newStartingAt: aSymbol) parse: anObject onError: aBlock! !!PPCompositeParser class methodsFor: 'parsing'!parse: anObject	^ self parse: anObject startingAt: self startSymbol! !PPCompositeParser subclass: #CoPGrammer	instanceVariableNames: 'subt term mul var brackets num pro'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Tools'!!CoPGrammer commentStamp: 'MarkusKaleta 1/8/2020 04:04' prior: 0!by Markus KaletaLeacture: Concepts of Programminglanguage!!CoPGrammer methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:00'!term ^ subt / pro ! !!CoPGrammer methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:01'!var ^ num / brackets! !!CoPGrammer methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:00'!mul ^ var, $* asParser trim, pro! !!CoPGrammer methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:01'!brackets ^ $( asParser trim, term, $) asParser trim! !!CoPGrammer methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:03'!subt ^ pro, $- asParser trim, term! !!CoPGrammer methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:02'!pro ^ mul / var ! !!CoPGrammer methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:04'!start ^ term end! !!CoPGrammer methodsFor: 'accessing' stamp: 'MarkusKaleta 1/8/2020 04:05'!num ^ #digit asParser plus flatten trim ==> [ :str | str asNumber ]! !PPDelegateParser subclass: #PPExpressionParser	instanceVariableNames: 'operators'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Tools'!!PPExpressionParser commentStamp: '' prior: 0!A PPExpressionParser is a parser to conveniently define an expression grammar with prefix, postfix, and left- and right-associative infix operators.The following code initializes a parser for arithmetic expressions. First we instantiate an expression parser, a simple parser for expressions in parenthesis and a simple parser for integer numbers.	expression := PPExpressionParser new.	parens := $( asParser token trim , expression , $) asParser token trim 		==> [ :nodes | nodes second ].	integer := #digit asParser plus token trim		==> [ :token | token value asInteger ].	Then we define on what term the expression grammar is built on:	expression term: parens / integer.	Finally we define the operator-groups in descending precedence. Note, that the action blocks receive both, the terms and the parsed operator in the order they appear in the parsed input. 		expression		group: [ :g |			g prefix: $- asParser token trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser token trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser token trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser token trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser token trim do: [ :a :op :b | a * b ].			g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser token trim do: [ :a :op :b | a + b ].			g left: $- asParser token trim do: [ :a :op :b | a - b ] ].		After evaluating the above code the 'expression' is an efficient parser that evaluates examples like:	expression parse: '-8++'.	expression parse: '1+2*3'.	expression parse: '1*2+3'.	expression parse: '(1+2)*3'.	expression parse: '8/4/2'.	expression parse: '8/(4/2)'.	expression parse: '2^2^3'.	expression parse: '(2^2)^3'.	Instance Variables:	operators	<Dictionary>	The operators defined in the current group.!!PPExpressionParser methodsFor: 'private'!build: aParser prefix: aChoiceParser	^ aChoiceParser star , aParser map: [ :ops :term | ops reverse inject: term into: [ :result :operator | operator first value: operator second value: result ] ]! !!PPExpressionParser methodsFor: 'private'!operator: aSymbol parser: aParser do: aBlock	parser isNil		ifTrue: [ ^ self error: 'You did not specify a term when creating the receiver.' ].	operators isNil		ifTrue: [ ^ self error: 'Use #group: to define precedence groups in descending order.' ].	(operators at: aSymbol ifAbsentPut: [ OrderedCollection new ])		addLast: (Array with: aParser asParser with: aBlock)! !!PPExpressionParser methodsFor: 'private'!build: aParser right: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldRight: [ :a :op :b | op first value: a value: op second value: b ]! !!PPExpressionParser methodsFor: 'private'!buildSelectors	^ #(build:prefix: build:postfix: build:right: build:left:)! !!PPExpressionParser methodsFor: 'private'!build: aParser left: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldLeft: [ :a :op :b | op first value: a value: op second value: b ]! !!PPExpressionParser methodsFor: 'private'!build: aParser postfix: aChoiceParser	^ aParser , aChoiceParser star map: [ :term :ops | ops inject: term into: [ :result :operator | operator first value: result value: operator second ] ]! !!PPExpressionParser methodsFor: 'private'!buildOn: aParser	^ self buildSelectors inject: aParser into: [ :term :selector |		| list |		list := operators at: selector ifAbsent: [ #() ].		list isEmpty			ifTrue: [ term ]			ifFalse: [				self					perform: selector with: term 					with: (list size = 1						ifTrue: [ list first first ==> [ :operator | Array with: list first second with: operator ] ]						ifFalse: [ 							list								inject: PPChoiceParser new								into: [ :choice :each | choice / (each first ==> [ :operator | Array with: each second with: operator ]) ] ]) ] ]! !!PPExpressionParser methodsFor: 'specifying'!term: aParser	"Defines the initial term aParser of the receiver."		parser isNil		ifTrue: [ parser := aParser ]		ifFalse: [ self error: 'Unable to redefine the term.' ]! !!PPExpressionParser methodsFor: 'specifying'!group: aOneArgumentBlock	"Defines a priority group by evaluating aOneArgumentBlock."		operators := Dictionary new.	parser := [ 		aOneArgumentBlock value: self.	 	self buildOn: parser ]			ensure: [ operators := nil ]! !!PPExpressionParser methodsFor: 'specifying'!left: aParser do: aThreeArgumentBlock	"Define an operator aParser that is left-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:left: parser: aParser do: aThreeArgumentBlock! !!PPExpressionParser methodsFor: 'specifying'!right: aParser do: aThreeArgumentBlock	"Define an operator aParser that is right-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:right: parser: aParser do: aThreeArgumentBlock! !!PPExpressionParser methodsFor: 'specifying'!prefix: aParser do: aTwoArgumentBlock	"Define a prefix operator aParser. Evaluate aTwoArgumentBlock with the operator and the term."	self operator: #build:prefix: parser: aParser do: aTwoArgumentBlock! !!PPExpressionParser methodsFor: 'specifying'!postfix: aParser do: aTwoArgumentBlock	"Define a postfix operator aParser. Evaluate aTwoArgumentBlock with the term and the operator."	self operator: #build:postfix: parser: aParser do: aTwoArgumentBlock! !PPParser subclass: #PPUnresolvedParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Tools'!!PPUnresolvedParser commentStamp: '' prior: 0!This is a temporary placeholder or forward reference to a parser that has not been defined yet. If everything goes well it will eventually be replaced with the real parser instance.!!PPUnresolvedParser methodsFor: 'parsing'!parseOn: aStream	self error: self printString , ' need to be resolved before execution.'! !!PPUnresolvedParser methodsFor: 'testing'!isUnresolved	^ true! !!PPUnresolvedParser methodsFor: '*PetitGui'!displayColor	^ Color red! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5065 pm'!!Stream methodsFor: '*PetitParser'!asPetitStream	^ self contents asPetitStream! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5085 pm'!!Object methodsFor: '*PetitParser'!isPetitFailure	^ false! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5085 pm'!!Object methodsFor: '*PetitParser'!isPetitParser	^ false! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5085 pm'!!Object methodsFor: '*PetitParser'!asParser	"Answer a parser accepting the receiving object."	^ PPPredicateObjectParser expect: self! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5095 pm'!!Symbol methodsFor: '*PetitParser'!asParser	"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."	^ PPPredicateObjectParser perform: self! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5095 pm'!!UndefinedObject methodsFor: '*PetitParser'!asParser	"Answer a parser that succeeds and does not consume anything."		^ PPEpsilonParser new! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5095 pm'!!String methodsFor: '*PetitParser'!asParser	"Answer a parser that accepts the receiving string."	^ PPLiteralSequenceParser on: self! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5095 pm'!!SequenceableCollection methodsFor: '*PetitParser'!asPetitStream	^ PPStream on: self! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5095 pm'!!Character methodsFor: '*PetitParser'!asParser	"Answer a parser that accepts the receiving character."		^ PPLiteralObjectParser on: self! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5095 pm'!!Interval methodsFor: '*PetitParser'!asParser    	"Create a range of characters between start and stop."    self assert:start isCharacter.    self assert:stop isCharacter.    self assert:step == 1.    ^ PPPredicateObjectParser between: start and: stop    "		($a to: $f) asParser parse: 'a'		($a to: $f) asParser parse: 'g'    "! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5105 pm'!!PositionableStream methodsFor: '*PetitParser'!asPetitStream	"Some of my subclasses do not use the instance-variables collection, position and readLimit but instead have a completely different internal representation. In these cases just use the super implementation that is inefficient but should work in all cases.""	Disabled until we agree on some way how to optimize this	^ (collection isNil or: [ position isNil or: [ readLimit isNil ] ])		ifFalse: [ PPStream on: collection from: ( position + 1 ) to: readLimit ]      ifTrue: [ super asPetitStream ]"	^ super asPetitStream! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5105 pm'!!PositionableStream methodsFor: '*PetitParser'!peekTwice	"Answer what would be returned if the message next were sent to the 	receiver. If the receiver is at the end, answer nil."	| array |	self atEnd 		ifTrue: [^Array with: nil with: nil].	array := Array with: (self next) with: (self peek).	position := position - 1.	^array! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5105 pm'!!Text methodsFor: '*PetitParser'!asPetitStream	^ string asPetitStream! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5105 pm'!!BlockClosure methodsFor: '*PetitParser'!asParser	"Answer a parser implemented in the receiving one-argument block."	^ PPPluggableParser on: self! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5105 pm'!!Collection methodsFor: '*PetitParser'!asChoiceParser	^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5105 pm'!!Collection methodsFor: '*PetitParser'!asParser    	"Create a range of characters between start and stop."	(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ 		| charSet |		charSet := PPCharSetPredicate on: [ :char | self includes: char ] .     	^ PPPredicateObjectParser on: charSet message: 'One of these charactes expected: ', self printString.	].	^ super asParser	"		($a to:$f) asParser parse:'a'		($a to:$f) asParser parse:'g'	"! !'From Pharo7.0.3 of 12 April 2019 [Build information: Pharo-7.0.3+build.158.sha.0903ade8a6c96633f07e0a7f1baa9a5d48cfdf55 (64 Bit)] on 8 January 2020 at 6:32:36.5105 pm'!!Collection methodsFor: '*PetitParser'!asSequenceParser	^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])! !