OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2020-01-07T02:12:40.167626+01:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.7mjpbpkhuf138t2m6a82npg3r', '60977' ],		#self : OmReference [ '1' ]	},	#content : EpMonticelloVersionsLoad {		#versionNames : OrderedCollection [			'PetitParser-lr.231',			'PetitTests-lr.45'		]	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ],		#time : DateAndTime [ '2020-01-07T02:12:40.372626+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPFailure\r\tinstanceVariableNames: \'message context position\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPFailure,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPFailure,						#isMetaSide : false					},					#name : #message,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPFailure,						#isMetaSide : false					},					#name : #context,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPFailure,						#isMetaSide : false					},					#name : #position,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPFailure class\r\tinstanceVariableNames: \'\''				},				#name : #'PPFailure class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPFailure,					#isMetaSide : false				},				#parent : @7,				#content : 'The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.\r\rInstance Variables:\r\tmessage\t<String>\tThe error message of this failure.\r\tposition\t<Integer>\tThe position of this failure in the input stream.\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPFailure\r\tinstanceVariableNames: \'message position\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPFailure,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPFailure,						#isMetaSide : false					},					#name : #message,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPFailure,						#isMetaSide : false					},					#name : #position,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPFailure class\r\tinstanceVariableNames: \'\''				},				#name : #'PPFailure class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPFailure,					#isMetaSide : false				},				#parent : @27,				#content : 'The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.\r\rInstance Variables:\r\tmessage\t<String>\tThe error message of this failure.\r\tposition\t<Integer>\tThe position of this failure in the input stream.\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ],		#time : DateAndTime [ '2020-01-07T02:12:40.412626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPMemento\r\tinstanceVariableNames: \'result count position\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPMemento,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemento,						#isMetaSide : false					},					#name : #result,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemento,						#isMetaSide : false					},					#name : #count,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemento,						#isMetaSide : false					},					#name : #position,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMemento class\r\tinstanceVariableNames: \'\''				},				#name : #'PPMemento class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPMemento,					#isMetaSide : false				},				#parent : @8,				#content : 'PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.\r\rInstance Variables:\r\tresult\t<Object>\tThe cached result.\r\tcount\t<Integer>\tThe number of recursive cycles followed.\r\tposition\t<Integer>\tThe position of the cached result in the input stream.',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.\r\rInstance Variables:\r\tresult\t<Object>\tThe cached result.\r\tcount\t<Integer>\tThe number of recursive cycles followed.\r\t',		#newComment : 'PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.\r\rInstance Variables:\r\tresult\t<Object>\tThe cached result.\r\tcount\t<Integer>\tThe number of recursive cycles followed.\r\tposition\t<Integer>\tThe position of the cached result in the input stream.',		#oldStamp : '',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ],		#time : DateAndTime [ '2020-01-07T02:12:40.415626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPMemento\r\tinstanceVariableNames: \'result count context\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPMemento,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemento,						#isMetaSide : false					},					#name : #result,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemento,						#isMetaSide : false					},					#name : #count,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemento,						#isMetaSide : false					},					#name : #context,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMemento class\r\tinstanceVariableNames: \'\''				},				#name : #'PPMemento class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPMemento,					#isMetaSide : false				},				#parent : @8,				#content : 'PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.\r\rInstance Variables:\r\tresult\t<Object>\tThe cached result.\r\tcount\t<Integer>\tThe number of recursive cycles followed.\r\t',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPMemento\r\tinstanceVariableNames: \'result count position\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPMemento,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemento,						#isMetaSide : false					},					#name : #result,					#parent : @28				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemento,						#isMetaSide : false					},					#name : #count,					#parent : @28				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemento,						#isMetaSide : false					},					#name : #position,					#parent : @28				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMemento class\r\tinstanceVariableNames: \'\''				},				#name : #'PPMemento class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @28			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPMemento,					#isMetaSide : false				},				#parent : @28,				#content : 'PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.\r\rInstance Variables:\r\tresult\t<Object>\tThe cached result.\r\tcount\t<Integer>\tThe number of recursive cycles followed.\r\tposition\t<Integer>\tThe position of the cached result in the input stream.',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ],		#time : DateAndTime [ '2020-01-07T02:12:40.417626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPParser\r\tinstanceVariableNames: \'properties\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'Object'			},			#name : #PPParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPParser,						#isMetaSide : false					},					#name : #properties,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPParser,					#isMetaSide : false				},				#parent : @8,				#content : 'An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.\r\rInstance Variables:\r\tproperties\t<Dictionary>\tStores additional state in the parser object.',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.\r\rInstance Variables:\r\tproperties\t<Dictionary>\tStores additional state in the parser object.\r',		#newComment : 'An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.\r\rInstance Variables:\r\tproperties\t<Dictionary>\tStores additional state in the parser object.',		#oldStamp : '',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ],		#time : DateAndTime [ '2020-01-07T02:12:40.421626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPFailingParser\r\tinstanceVariableNames: \'message\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPFailingParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPFailingParser,						#isMetaSide : false					},					#name : #message,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPFailingParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPFailingParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPFailingParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A parser that consumes nothing and always fails.\r\rInstance Variables:\r\tmessage <String>\tThe failure message.',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'A parser that consumes nothing and always fails.\r\rInstance Variables:\r\tmessage <String>\tThe failure message.\r',		#newComment : 'A parser that consumes nothing and always fails.\r\rInstance Variables:\r\tmessage <String>\tThe failure message.',		#oldStamp : '',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ],		#time : DateAndTime [ '2020-01-07T02:12:40.424626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPListParser\r\tinstanceVariableNames: \'parsers\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPListParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPListParser,						#isMetaSide : false					},					#name : #parsers,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPListParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPListParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPListParser,					#isMetaSide : false				},				#parent : @8,				#content : 'Abstract parser that parses a list of things in some way (to be specified by the subclasses).\r\rInstance Variables:\r\tparsers\t<SequenceableCollection of: PPParser>\tA sequence of other parsers to delegate to.',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Abstract parser that parses a list of things in some way (to be specified by the subclasses).\r\rInstance Variables:\r\tparsers\t<SequenceableCollection of: PPParser>\tA sequence of other parsers to delegate to.\r',		#newComment : 'Abstract parser that parses a list of things in some way (to be specified by the subclasses).\r\rInstance Variables:\r\tparsers\t<SequenceableCollection of: PPParser>\tA sequence of other parsers to delegate to.',		#oldStamp : '',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ],		#time : DateAndTime [ '2020-01-07T02:12:40.426626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPLiteralParser\r\tinstanceVariableNames: \'literal message\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPLiteralParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPLiteralParser,						#isMetaSide : false					},					#name : #literal,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPLiteralParser,						#isMetaSide : false					},					#name : #message,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPLiteralParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPLiteralParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPLiteralParser,					#isMetaSide : false				},				#parent : @8,				#content : 'Abstract literal parser that parses some kind of literal type (to be specified by subclasses).\r\rInstance Variables:\r\tliteral\t<Object>\tThe literal object to be parsed.\r\tmessage\t<String>\tThe error message to be generated.\r',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Abstract literal parser that parses some kind of literal type (to be specified by subclasses).\r\rInstance Variables:\r\tliteral\t<Object>\tThe literal object to be parsed.\r\tmessage\t<String>\tThe error message to be generated.\r\r',		#newComment : 'Abstract literal parser that parses some kind of literal type (to be specified by subclasses).\r\rInstance Variables:\r\tliteral\t<Object>\tThe literal object to be parsed.\r\tmessage\t<String>\tThe error message to be generated.\r',		#oldStamp : '',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ],		#time : DateAndTime [ '2020-01-07T02:12:40.428626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPPluggableParser\r\tinstanceVariableNames: \'block\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPPluggableParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPPluggableParser,						#isMetaSide : false					},					#name : #block,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPPluggableParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPPluggableParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPPluggableParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.\r\rInstance Variables:\r\tblock\t<BlockClosure>\tThe pluggable one-argument block.\r',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.\r\rInstance Variables:\r\tblock\t<BlockClosure>\tThe pluggable one-argument block.\r\r',		#newComment : 'A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.\r\rInstance Variables:\r\tblock\t<BlockClosure>\tThe pluggable one-argument block.\r',		#oldStamp : '',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ],		#time : DateAndTime [ '2020-01-07T02:12:40.431626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPToken\r\tinstanceVariableNames: \'collection start stop value\'\r\tclassVariableNames: \'NewLineParser\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPToken,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPToken,						#isMetaSide : false					},					#name : #collection,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPToken,						#isMetaSide : false					},					#name : #start,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPToken,						#isMetaSide : false					},					#name : #stop,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPToken,						#isMetaSide : false					},					#name : #value,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPToken class\r\tinstanceVariableNames: \'\''				},				#name : #'PPToken class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPToken,					#isMetaSide : false				},				#parent : @8,				#content : 'PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection, its start and stop position and its parse value.\r\rInstance Variables:\r\tcollection\t<SequenceableCollection>\tThe collection this token comes from.\r\tstart\t<Integer>\tThe start position in the collection.\r\tstop\t<Integer>\tThe stop position in the collection.\r\tvalue <Object>\tThe parse result.',				#stamp : 'lr 2/25/2013 23:34'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPToken,						#isMetaSide : false					},					#name : #NewLineParser,					#parent : @8				}			],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection and its start and stop position.\r\rInstance Variables:\r\tcollection\t<SequenceableCollection>\tThe collection this token comes from.\r\tstart\t<Integer>\tThe start position in the collection.\r\tstop\t<Integer>\tThe stop position in the collection.',		#newComment : 'PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection, its start and stop position and its parse value.\r\rInstance Variables:\r\tcollection\t<SequenceableCollection>\tThe collection this token comes from.\r\tstart\t<Integer>\tThe start position in the collection.\r\tstop\t<Integer>\tThe stop position in the collection.\r\tvalue <Object>\tThe parse result.',		#oldStamp : '',		#newStamp : 'lr 2/25/2013 23:34'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ],		#time : DateAndTime [ '2020-01-07T02:12:40.448626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPPredicateParser subclass: #PPPredicateObjectParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPPredicateParser'			},			#name : #PPPredicateObjectParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPPredicateObjectParser class\r\tinstanceVariableNames: \'cache\''				},				#name : #'PPPredicateObjectParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#isMetaSide : true,							#className : #'PPPredicateObjectParser class'						},						#name : #cache,						#parent : @13					}				],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPPredicateObjectParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A parser that accepts if a given predicate on one element of the input sequence holds.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPPredicateParser subclass: #PPPredicateObjectParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPPredicateParser'			},			#name : #PPPredicateObjectParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPPredicateObjectParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPPredicateObjectParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @24			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPPredicateObjectParser,					#isMetaSide : false				},				#parent : @24,				#content : 'A parser that accepts if a given predicate on one element of the input sequence holds.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ],		#time : DateAndTime [ '2020-01-07T02:12:40.453626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPPredicateParser subclass: #PPPredicateSequenceParser\r\tinstanceVariableNames: \'size\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPPredicateParser'			},			#name : #PPPredicateSequenceParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPPredicateSequenceParser,						#isMetaSide : false					},					#name : #size,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPPredicateSequenceParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPPredicateSequenceParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPPredicateSequenceParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.\r\rInstance Variables:\r\tsize\t<Integer>\tThe number of elements to consume.',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.\r\rInstance Variables:\r\tsize\t<Integer>\tThe number of elements to consume.\r',		#newComment : 'A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.\r\rInstance Variables:\r\tsize\t<Integer>\tThe number of elements to consume.',		#oldStamp : '',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ],		#time : DateAndTime [ '2020-01-07T02:12:40.482626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPDelegateParser subclass: #PPMemoizedParser\r\tinstanceVariableNames: \'buffer identifier\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPDelegateParser'			},			#name : #PPMemoizedParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemoizedParser,						#isMetaSide : false					},					#name : #buffer,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemoizedParser,						#isMetaSide : false					},					#name : #identifier,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMemoizedParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPMemoizedParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPMemoizedParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A memoized parser, for refraining redundant computations.\r\rInstance Variables:\r\tstream\t<PositionableStream>\tThe stream of the associated memento objects.\r\tbuffer\t<Array of: PPMemento>\tThe buffer of memento objects.\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPDelegateParser subclass: #PPMemoizedParser\r\tinstanceVariableNames: \'stream buffer\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPDelegateParser'			},			#name : #PPMemoizedParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemoizedParser,						#isMetaSide : false					},					#name : #stream,					#parent : @26				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPMemoizedParser,						#isMetaSide : false					},					#name : #buffer,					#parent : @26				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMemoizedParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPMemoizedParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @26			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPMemoizedParser,					#isMetaSide : false				},				#parent : @26,				#content : 'A memoized parser, for refraining redundant computations.\r\rInstance Variables:\r\tstream\t<PositionableStream>\tThe stream of the associated memento objects.\r\tbuffer\t<Array of: PPMemento>\tThe buffer of memento objects.\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ],		#time : DateAndTime [ '2020-01-07T02:12:40.652626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPArithmeticParserTest subclass: #PPExpressionParserTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'PPArithmeticParserTest'			},			#name : #PPExpressionParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPExpressionParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPExpressionParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPExpressionParserTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPArithmeticParserTest subclass: #PPExpressionParserTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'PPArithmeticParserTest'			},			#name : #PPExpressionParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPExpressionParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPExpressionParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @22			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPExpressionParserTest,					#isMetaSide : false				},				#parent : @22,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ],		#time : DateAndTime [ '2020-01-07T02:12:40.654626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParserTest subclass: #PPArithmeticParserTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'PPCompositeParserTest'			},			#name : #PPArithmeticParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPArithmeticParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPArithmeticParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPArithmeticParserTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParserTest subclass: #PPArithmeticParserTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'PPCompositeParserTest'			},			#name : #PPArithmeticParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPArithmeticParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPArithmeticParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @22			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPArithmeticParserTest,					#isMetaSide : false				},				#parent : @22,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ],		#time : DateAndTime [ '2020-01-07T02:12:40.684626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParserTest subclass: #PPLambdaParserTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'PPCompositeParserTest'			},			#name : #PPLambdaParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPLambdaParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPLambdaParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPLambdaParserTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParserTest subclass: #PPLambdaParserTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'PPCompositeParserTest'			},			#name : #PPLambdaParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPLambdaParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPLambdaParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @22			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPLambdaParserTest,					#isMetaSide : false				},				#parent : @22,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ],		#time : DateAndTime [ '2020-01-07T02:12:40.751626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPMSEGrammarTest subclass: #PPMSEArrayParserTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitMSE\'',				#superclassName : 'PPMSEGrammarTest'			},			#name : #PPMSEArrayParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMSEArrayParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPMSEArrayParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPMSEArrayParserTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitMSE,			#package : #PetitMSE,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPMSEGrammarTest subclass: #PPMSEArrayParserTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitMSE\'',				#superclassName : 'PPMSEGrammarTest'			},			#name : #PPMSEArrayParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMSEArrayParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPMSEArrayParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @22			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPMSEArrayParserTest,					#isMetaSide : false				},				#parent : @22,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitMSE,			#package : #PetitMSE,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ],		#time : DateAndTime [ '2020-01-07T02:12:40.752626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParserTest subclass: #PPMSEGrammarTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitMSE\'',				#superclassName : 'PPCompositeParserTest'			},			#name : #PPMSEGrammarTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMSEGrammarTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPMSEGrammarTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPMSEGrammarTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitMSE,			#package : #PetitMSE,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParserTest subclass: #PPMSEGrammarTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitMSE\'',				#superclassName : 'PPCompositeParserTest'			},			#name : #PPMSEGrammarTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMSEGrammarTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPMSEGrammarTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @22			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPMSEGrammarTest,					#isMetaSide : false				},				#parent : @22,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitMSE,			#package : #PetitMSE,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ],		#time : DateAndTime [ '2020-01-07T02:12:40.788626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParserTest subclass: #PPJsonGrammarTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitJson-Tests\'',				#superclassName : 'PPCompositeParserTest'			},			#name : #PPJsonGrammarTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPJsonGrammarTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPJsonGrammarTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPJsonGrammarTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitJson-Tests,			#package : #PetitJson-Tests,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParserTest subclass: #PPJsonGrammarTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitJson-Tests\'',				#superclassName : 'PPCompositeParserTest'			},			#name : #PPJsonGrammarTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPJsonGrammarTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPJsonGrammarTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @22			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPJsonGrammarTest,					#isMetaSide : false				},				#parent : @22,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitJson-Tests,			#package : #PetitJson-Tests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ],		#time : DateAndTime [ '2020-01-07T02:12:40.789626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPAbstractParserTest subclass: #PPCompositeParserTest\r\tinstanceVariableNames: \'parser result debugResult\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Core\'',				#superclassName : 'PPAbstractParserTest'			},			#name : #PPCompositeParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPCompositeParserTest,						#isMetaSide : false					},					#name : #parser,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPCompositeParserTest,						#isMetaSide : false					},					#name : #result,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPCompositeParserTest,						#isMetaSide : false					},					#name : #debugResult,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPCompositeParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPCompositeParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPCompositeParserTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Core,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPAbstractParserTest subclass: #PPCompositeParserTest\r\tinstanceVariableNames: \'parser result\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Core\'',				#superclassName : 'PPAbstractParserTest'			},			#name : #PPCompositeParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPCompositeParserTest,						#isMetaSide : false					},					#name : #parser,					#parent : @28				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPCompositeParserTest,						#isMetaSide : false					},					#name : #result,					#parent : @28				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPCompositeParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPCompositeParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @28			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPCompositeParserTest,					#isMetaSide : false				},				#parent : @28,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Core,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ],		#time : DateAndTime [ '2020-01-07T02:12:40.881626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPStream subclass: #PPBrowserStream\r\tinstanceVariableNames: \'positions stamps parsers\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitGui-Core\'',				#superclassName : 'PPStream'			},			#name : #PPBrowserStream,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPBrowserStream,						#isMetaSide : false					},					#name : #positions,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPBrowserStream,						#isMetaSide : false					},					#name : #stamps,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPBrowserStream,						#isMetaSide : false					},					#name : #parsers,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPBrowserStream class\r\tinstanceVariableNames: \'\''				},				#name : #'PPBrowserStream class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPBrowserStream,					#isMetaSide : false				},				#parent : @8,				#content : 'Provides a stream compatible with PPStream with additional abilities for display in parser inspections.\r\rCheck conversions:\r\r- asExecutionTrace\r- asFrequencyTable\r- asPositionDrawing\r- asPositionMorph\r\rthe is also support for clicking on representations.\r ',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitGui-Core,			#package : #PetitGui,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPStream subclass: #PPBrowserStream\r\tinstanceVariableNames: \'positions stamps parsers\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitGui-Core\'',				#superclassName : 'PPStream'			},			#name : #PPBrowserStream,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPBrowserStream,						#isMetaSide : false					},					#name : #positions,					#parent : @28				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPBrowserStream,						#isMetaSide : false					},					#name : #stamps,					#parent : @28				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPBrowserStream,						#isMetaSide : false					},					#name : #parsers,					#parent : @28				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPBrowserStream class\r\tinstanceVariableNames: \'\''				},				#name : #'PPBrowserStream class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @28			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPBrowserStream,					#isMetaSide : false				},				#parent : @28,				#content : 'Provides a stream compatible with PPStream with additional abilities for display in parser inspections.\r\rCheck conversions:\r\r- asExecutionTrace\r- asFrequencyTable\r- asPositionDrawing\r- asPositionMorph\r\rthe is also support for clicking on representations.\r ',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitGui-Core,			#package : #PetitGui,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ],		#time : DateAndTime [ '2020-01-07T02:12:40.883626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ReadStream subclass: #PPStream\r\tinstanceVariableNames: \'newlines\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'ReadStream'			},			#name : #PPStream,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPStream,						#isMetaSide : false					},					#name : #newlines,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPStream class\r\tinstanceVariableNames: \'\''				},				#name : #'PPStream class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPStream,					#isMetaSide : false				},				#parent : @8,				#content : 'A positional stream implementation used for parsing. It overrides some methods for optimization reasons.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ReadStream subclass: #PPStream\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'ReadStream'			},			#name : #PPStream,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPStream class\r\tinstanceVariableNames: \'\''				},				#name : #'PPStream class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @24			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPStream,					#isMetaSide : false				},				#parent : @24,				#content : 'A positional stream implementation used for parsing. It overrides some methods for optimization reasons.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ],		#time : DateAndTime [ '2020-01-07T02:12:41.293626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testStartOfWord,			#protocol : #testing-chars,			#sourceCode : 'testStartOfWord\r\t| parser |\r\tparser := #startOfWord asParser, #word asParser plus.\r\t\r\tself assert: parser parse: \'lorem\'.\r\t\r\tparser := #any asParser, #startOfWord asParser, #word asParser plus.\r\tself assert: parser fail: \'lorem\'.\r\tself assert: parser fail: \'1234\'.\r\t\r\tself assert: parser parse: \' lorem\'.\t\r\tself assert: parser parse: \' 123\'.\r\tself assert: parser parse: \')lorem\'.\r\tself assert: parser parse: \':lorem\'.\r\t\r\tparser := #startOfWord asParser, #any asParser optional.\r\tself assert: parser fail: \'\'.\r\tself assert: parser parse: \'a\'.\r\tself assert: parser fail: \'.\'.',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testStartOfWord,			#protocol : #'as yet unclassified',			#sourceCode : 'testStartOfWord\r\t| parser |\r\tparser := #startOfWord asParser, #word asParser plus.\r\t\r\tself assert: parser parse: \'lorem\'.\r\t\r\tparser := #any asParser, #startOfWord asParser, #word asParser plus.\r\tself assert: parser fail: \'lorem\'.\r\tself assert: parser fail: \'1234\'.\r\t\r\tself assert: parser parse: \' lorem\'.\t\r\tself assert: parser parse: \' 123\'.\r\tself assert: parser parse: \')lorem\'.\r\tself assert: parser parse: \':lorem\'.\r\t\r\tparser := #startOfWord asParser, #any asParser optional.\r\tself assert: parser fail: \'\'.\r\tself assert: parser parse: \'a\'.\r\tself assert: parser fail: \'.\'.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ],		#time : DateAndTime [ '2020-01-07T02:12:41.294626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testStartOfWord,			#protocol : #testing-chars,			#sourceCode : 'testStartOfWord\r\t| parser |\r\tparser := #startOfWord asParser, #word asParser plus.\r\t\r\tself assert: parser parse: \'lorem\'.\r\t\r\tparser := #any asParser, #startOfWord asParser, #word asParser plus.\r\tself assert: parser fail: \'lorem\'.\r\tself assert: parser fail: \'1234\'.\r\t\r\tself assert: parser parse: \' lorem\'.\t\r\tself assert: parser parse: \' 123\'.\r\tself assert: parser parse: \')lorem\'.\r\tself assert: parser parse: \':lorem\'.\r\t\r\tparser := #startOfWord asParser, #any asParser optional.\r\tself assert: parser fail: \'\'.\r\tself assert: parser parse: \'a\'.\r\tself assert: parser fail: \'.\'.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ],		#time : DateAndTime [ '2020-01-07T02:12:41.298626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testStartOfLogicalLine,			#protocol : #testing-chars,			#sourceCode : 'testStartOfLogicalLine\r\t| parser |\r\tparser := #startOfLogicalLine asParser, #any asParser star.\r\t\r\tself assert: parser parse: \'lorem\'.\r\tself assert: parser fail: \' lorem\'.\r\t\r\tparser := #any asParser, #startOfLogicalLine asParser, #any asParser star.\r\tself assert: parser fail: \'lorem\'.\r\tself assert: parser fail: \'        lorem\'.\r\tself assert: parser parse: \' lorem\'.\r\tself assert: parser parse: \'\tlorem\'.',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testStartOfLogicalLine,			#protocol : #'as yet unclassified',			#sourceCode : 'testStartOfLogicalLine\r\t| parser |\r\tparser := #startOfLogicalLine asParser, #any asParser star.\r\t\r\tself assert: parser parse: \'lorem\'.\r\tself assert: parser fail: \' lorem\'.\r\t\r\tparser := #any asParser, #startOfLogicalLine asParser, #any asParser star.\r\tself assert: parser fail: \'lorem\'.\r\tself assert: parser fail: \'        lorem\'.\r\tself assert: parser parse: \' lorem\'.\r\tself assert: parser parse: \'\tlorem\'.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ],		#time : DateAndTime [ '2020-01-07T02:12:41.299626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testStartOfLogicalLine,			#protocol : #testing-chars,			#sourceCode : 'testStartOfLogicalLine\r\t| parser |\r\tparser := #startOfLogicalLine asParser, #any asParser star.\r\t\r\tself assert: parser parse: \'lorem\'.\r\tself assert: parser fail: \' lorem\'.\r\t\r\tparser := #any asParser, #startOfLogicalLine asParser, #any asParser star.\r\tself assert: parser fail: \'lorem\'.\r\tself assert: parser fail: \'        lorem\'.\r\tself assert: parser parse: \' lorem\'.\r\tself assert: parser parse: \'\tlorem\'.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ],		#time : DateAndTime [ '2020-01-07T02:12:41.303626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testStartOfLine,			#protocol : #testing-chars,			#sourceCode : 'testStartOfLine\r\t| cr crlf lf parser |\r\tcr := Character cr asString.\r\tcrlf := Character cr asString , Character lf asString.\r\tlf := Character lf asString.\r\tparser := #startOfLine asParser, #any asParser star.\r\t\r\tself assert: parser parse: \'lorem ipsum\'.\r\t\r\tparser := #any asParser, #startOfLine asParser, #any asParser star.\r\tself assert: parser fail: \'lorem ipsum\'.\r\t\r\tparser := #startOfLine asParser, #any asParser, #startOfLine asParser, #any asParser star.\r\tself assert: parser parse: cr, \'lorem ipsum\'.\r\tself assert: parser parse: lf, \'lorem ipsum\'.\t\r\tself assert: parser fail: crlf, \'lorem ipsum\'.\t\r\t\r\tself assert: parser fail: crlf.\r\tself assert: parser parse: cr.\r\tself assert: parser parse: lf.\r\t\r\tparser := #startOfLine asParser, #any asParser, #any asParser, #startOfLine asParser, #any asParser star.\r\tself assert: parser parse: crlf, \'lorem ipsum\'.\r\tself assert: parser parse: crlf.\r\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testStartOfLine,			#protocol : #'as yet unclassified',			#sourceCode : 'testStartOfLine\r\t| cr crlf lf parser |\r\tcr := Character cr asString.\r\tcrlf := Character cr asString , Character lf asString.\r\tlf := Character lf asString.\r\tparser := #startOfLine asParser, #any asParser star.\r\t\r\tself assert: parser parse: \'lorem ipsum\'.\r\t\r\tparser := #any asParser, #startOfLine asParser, #any asParser star.\r\tself assert: parser fail: \'lorem ipsum\'.\r\t\r\tparser := #startOfLine asParser, #any asParser, #startOfLine asParser, #any asParser star.\r\tself assert: parser parse: cr, \'lorem ipsum\'.\r\tself assert: parser parse: lf, \'lorem ipsum\'.\t\r\tself assert: parser fail: crlf, \'lorem ipsum\'.\t\r\t\r\tself assert: parser fail: crlf.\r\tself assert: parser parse: cr.\r\tself assert: parser parse: lf.\r\t\r\tparser := #startOfLine asParser, #any asParser, #any asParser, #startOfLine asParser, #any asParser star.\r\tself assert: parser parse: crlf, \'lorem ipsum\'.\r\tself assert: parser parse: crlf.\r\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ],		#time : DateAndTime [ '2020-01-07T02:12:41.304626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testStartOfLine,			#protocol : #testing-chars,			#sourceCode : 'testStartOfLine\r\t| cr crlf lf parser |\r\tcr := Character cr asString.\r\tcrlf := Character cr asString , Character lf asString.\r\tlf := Character lf asString.\r\tparser := #startOfLine asParser, #any asParser star.\r\t\r\tself assert: parser parse: \'lorem ipsum\'.\r\t\r\tparser := #any asParser, #startOfLine asParser, #any asParser star.\r\tself assert: parser fail: \'lorem ipsum\'.\r\t\r\tparser := #startOfLine asParser, #any asParser, #startOfLine asParser, #any asParser star.\r\tself assert: parser parse: cr, \'lorem ipsum\'.\r\tself assert: parser parse: lf, \'lorem ipsum\'.\t\r\tself assert: parser fail: crlf, \'lorem ipsum\'.\t\r\t\r\tself assert: parser fail: crlf.\r\tself assert: parser parse: cr.\r\tself assert: parser parse: lf.\r\t\r\tparser := #startOfLine asParser, #any asParser, #any asParser, #startOfLine asParser, #any asParser star.\r\tself assert: parser parse: crlf, \'lorem ipsum\'.\r\tself assert: parser parse: crlf.\r\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ],		#time : DateAndTime [ '2020-01-07T02:12:41.308626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testEndOfLine,			#protocol : #testing-chars,			#sourceCode : 'testEndOfLine\r\t| cr crlf lf parser |\r\tcr := Character cr asString.\r\tcrlf := Character cr asString , Character lf asString.\r\tlf := Character lf asString.\r\tparser := (#letter asParser / #blank asParser) star, #endOfLine asParser.\r\t\r\tself assert: parser parse: \'lorem ipsum\'.\r\t\r\tparser := #any asParser, #endOfLine asParser, #any asParser star.\r\tself assert: parser parse: \'a\', cr, \'b\'.\r\tself assert: parser fail: crlf.\r\tself assert: parser fail: \'lorem ipsum\'.\r\t\r\tparser := #endOfLine asParser, #any asParser, #endOfLine asParser negate star, #endOfLine asParser.\r\tself assert: parser parse: cr, \'lorem ipsum\'.\r\tself assert: parser parse: lf, \'lorem ipsum\'.\t\r\tself assert: parser parse: crlf, \'lorem ipsum\'.\t\r\t\r\tself assert: parser parse: crlf.\r\tself assert: parser parse: cr.\r\tself assert: parser parse: lf.\r\t\r\tparser := #endOfLine asParser negate star, #endOfLine asParser, #any asParser star.\r\tself assert: parser parse: crlf, \'lorem ipsum\'.\r\tself assert: parser parse: crlf.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testEndOfLine,			#protocol : #'as yet unclassified',			#sourceCode : 'testEndOfLine\r\t| cr crlf lf parser |\r\tcr := Character cr asString.\r\tcrlf := Character cr asString , Character lf asString.\r\tlf := Character lf asString.\r\tparser := (#letter asParser / #blank asParser) star, #endOfLine asParser.\r\t\r\tself assert: parser parse: \'lorem ipsum\'.\r\t\r\tparser := #any asParser, #endOfLine asParser, #any asParser star.\r\tself assert: parser parse: \'a\', cr, \'b\'.\r\tself assert: parser fail: crlf.\r\tself assert: parser fail: \'lorem ipsum\'.\r\t\r\tparser := #endOfLine asParser, #any asParser, #endOfLine asParser negate star, #endOfLine asParser.\r\tself assert: parser parse: cr, \'lorem ipsum\'.\r\tself assert: parser parse: lf, \'lorem ipsum\'.\t\r\tself assert: parser parse: crlf, \'lorem ipsum\'.\t\r\t\r\tself assert: parser parse: crlf.\r\tself assert: parser parse: cr.\r\tself assert: parser parse: lf.\r\t\r\tparser := #endOfLine asParser negate star, #endOfLine asParser, #any asParser star.\r\tself assert: parser parse: crlf, \'lorem ipsum\'.\r\tself assert: parser parse: crlf.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ],		#time : DateAndTime [ '2020-01-07T02:12:41.308626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testEndOfLine,			#protocol : #testing-chars,			#sourceCode : 'testEndOfLine\r\t| cr crlf lf parser |\r\tcr := Character cr asString.\r\tcrlf := Character cr asString , Character lf asString.\r\tlf := Character lf asString.\r\tparser := (#letter asParser / #blank asParser) star, #endOfLine asParser.\r\t\r\tself assert: parser parse: \'lorem ipsum\'.\r\t\r\tparser := #any asParser, #endOfLine asParser, #any asParser star.\r\tself assert: parser parse: \'a\', cr, \'b\'.\r\tself assert: parser fail: crlf.\r\tself assert: parser fail: \'lorem ipsum\'.\r\t\r\tparser := #endOfLine asParser, #any asParser, #endOfLine asParser negate star, #endOfLine asParser.\r\tself assert: parser parse: cr, \'lorem ipsum\'.\r\tself assert: parser parse: lf, \'lorem ipsum\'.\t\r\tself assert: parser parse: crlf, \'lorem ipsum\'.\t\r\t\r\tself assert: parser parse: crlf.\r\tself assert: parser parse: cr.\r\tself assert: parser parse: lf.\r\t\r\tparser := #endOfLine asParser negate star, #endOfLine asParser, #any asParser star.\r\tself assert: parser parse: crlf, \'lorem ipsum\'.\r\tself assert: parser parse: crlf.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ],		#time : DateAndTime [ '2020-01-07T02:12:41.312626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testEndOfFile,			#protocol : #testing-chars,			#sourceCode : 'testEndOfFile\r\t| parser |\r\tparser := (#letter asParser / #blank asParser) star, #eof asParser.\r\t\r\tself assert: parser parse: \'lorem ipsum\'.\r\t\r\tparser := #any asParser, #eof asParser, #any asParser star.\r\tself assert: parser fail: \'a\', Character cr asString, \'b\'.\r\tself assert: parser fail: Character cr asString , Character lf asString.\r\tself assert: parser parse: \'a\'.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testEndOfFile,			#protocol : #'as yet unclassified',			#sourceCode : 'testEndOfFile\r\t| parser |\r\tparser := (#letter asParser / #blank asParser) star, #eof asParser.\r\t\r\tself assert: parser parse: \'lorem ipsum\'.\r\t\r\tparser := #any asParser, #eof asParser, #any asParser star.\r\tself assert: parser fail: \'a\', Character cr asString, \'b\'.\r\tself assert: parser fail: Character cr asString , Character lf asString.\r\tself assert: parser parse: \'a\'.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ],		#time : DateAndTime [ '2020-01-07T02:12:41.312626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testEndOfFile,			#protocol : #testing-chars,			#sourceCode : 'testEndOfFile\r\t| parser |\r\tparser := (#letter asParser / #blank asParser) star, #eof asParser.\r\t\r\tself assert: parser parse: \'lorem ipsum\'.\r\t\r\tparser := #any asParser, #eof asParser, #any asParser star.\r\tself assert: parser fail: \'a\', Character cr asString, \'b\'.\r\tself assert: parser fail: Character cr asString , Character lf asString.\r\tself assert: parser parse: \'a\'.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ],		#time : DateAndTime [ '2020-01-07T02:12:41.317626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser    \r\t"Create a range of characters between start and stop."\r\r\t(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ \r\t\t| charSet |\r\t\tcharSet := PPCharSetPredicate on: [ :char | self includes: char ] .\r     \t^ PPPredicateObjectParser on: charSet message: \'One of these charactes expected: \', self printString.\r\t].\r\r\r\t^ super asParser\r\t"\r\t\t($a to:$f) asParser parse:\'a\'\r\t\t($a to:$f) asParser parse:\'g\'\r\t"\r',			#stamp : '',			#package : #Collections-Abstract		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'as yet unclassified',			#sourceCode : 'asParser    \r\t"Create a range of characters between start and stop."\r\r\t(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ \r\t\t| charSet |\r\t\tcharSet := PPCharSetPredicate on: [ :char | self includes: char ] .\r     \t^ PPPredicateObjectParser on: charSet message: \'One of these charactes expected: \', self printString.\r\t].\r\r\r\t^ super asParser\r\t"\r\t\t($a to:$f) asParser parse:\'a\'\r\t\t($a to:$f) asParser parse:\'g\'\r\t"\r',			#stamp : '',			#package : #Collections-Abstract		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ],		#time : DateAndTime [ '2020-01-07T02:12:41.318626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser    \r\t"Create a range of characters between start and stop."\r\r\t(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ \r\t\t| charSet |\r\t\tcharSet := PPCharSetPredicate on: [ :char | self includes: char ] .\r     \t^ PPPredicateObjectParser on: charSet message: \'One of these charactes expected: \', self printString.\r\t].\r\r\r\t^ super asParser\r\t"\r\t\t($a to:$f) asParser parse:\'a\'\r\t\t($a to:$f) asParser parse:\'g\'\r\t"\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ],		#time : DateAndTime [ '2020-01-07T02:12:41.322626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:context:position:',			#protocol : #initialization,			#sourceCode : 'initializeMessage: aString context: aPPContext position: anInteger\r\tmessage := aString.\r\tcontext := aPPContext.\r\tposition := anInteger.\r\t\r\t"record the furthest failure encountered while parsing the input stream "\r\taPPContext noteFailure: self.\t',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:context:position:',			#protocol : #'as yet unclassified',			#sourceCode : 'initializeMessage: aString context: aPPContext position: anInteger\r\tmessage := aString.\r\tcontext := aPPContext.\r\tposition := anInteger.\r\t\r\t"record the furthest failure encountered while parsing the input stream "\r\taPPContext noteFailure: self.\t',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ],		#time : DateAndTime [ '2020-01-07T02:12:41.322626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:context:position:',			#protocol : #initialization,			#sourceCode : 'initializeMessage: aString context: aPPContext position: anInteger\r\tmessage := aString.\r\tcontext := aPPContext.\r\tposition := anInteger.\r\t\r\t"record the furthest failure encountered while parsing the input stream "\r\taPPContext noteFailure: self.\t',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ],		#time : DateAndTime [ '2020-01-07T02:12:41.330626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:context:',			#protocol : #initialization,			#sourceCode : 'initializeMessage: aString context: aPPContext\r\tself initializeMessage: aString context:  aPPContext position: aPPContext position',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:context:',			#protocol : #'as yet unclassified',			#sourceCode : 'initializeMessage: aString context: aPPContext\r\tself initializeMessage: aString context:  aPPContext position: aPPContext position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ],		#time : DateAndTime [ '2020-01-07T02:12:41.330626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:context:',			#protocol : #initialization,			#sourceCode : 'initializeMessage: aString context: aPPContext\r\tself initializeMessage: aString context:  aPPContext position: aPPContext position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ],		#time : DateAndTime [ '2020-01-07T02:12:41.334626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:',			#protocol : #initialization,			#sourceCode : 'initializeMessage: aString\t\r\tmessage := aString.\r',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:',			#protocol : #'as yet unclassified',			#sourceCode : 'initializeMessage: aString\t\r\tmessage := aString.\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ],		#time : DateAndTime [ '2020-01-07T02:12:41.334626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:',			#protocol : #initialization,			#sourceCode : 'initializeMessage: aString\t\r\tmessage := aString.\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ],		#time : DateAndTime [ '2020-01-07T02:12:41.338626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:context:at:',			#protocol : #'instance creation',			#sourceCode : 'message: aString context: aPPContext at: position\r\t^ self basicNew initializeMessage: aString context: aPPContext position: position',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:context:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'message: aString context: aPPContext at: position\r\t^ self basicNew initializeMessage: aString context: aPPContext position: position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ],		#time : DateAndTime [ '2020-01-07T02:12:41.338626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:context:at:',			#protocol : #'instance creation',			#sourceCode : 'message: aString context: aPPContext at: position\r\t^ self basicNew initializeMessage: aString context: aPPContext position: position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ],		#time : DateAndTime [ '2020-01-07T02:12:41.342626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:context:',			#protocol : #'instance creation',			#sourceCode : 'message: aString context: aPPContext\r\t^ self basicNew initializeMessage: aString context: aPPContext',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:context:',			#protocol : #'as yet unclassified',			#sourceCode : 'message: aString context: aPPContext\r\t^ self basicNew initializeMessage: aString context: aPPContext',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ],		#time : DateAndTime [ '2020-01-07T02:12:41.343626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:context:',			#protocol : #'instance creation',			#sourceCode : 'message: aString context: aPPContext\r\t^ self basicNew initializeMessage: aString context: aPPContext',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ],		#time : DateAndTime [ '2020-01-07T02:12:41.346626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:',			#protocol : #'instance creation',			#sourceCode : 'message: aString\r\t^ self basicNew initializeMessage: aString ',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:',			#protocol : #'as yet unclassified',			#sourceCode : 'message: aString\r\t^ self basicNew initializeMessage: aString ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ],		#time : DateAndTime [ '2020-01-07T02:12:41.346626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:',			#protocol : #'instance creation',			#sourceCode : 'message: aString\r\t^ self basicNew initializeMessage: aString ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ],		#time : DateAndTime [ '2020-01-07T02:12:41.350626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testStreamProtocol,			#protocol : #tests,			#sourceCode : 'testStreamProtocol\r\tcontext stream: \'hi there\' asPetitStream.\r\t\r\tself assert: context position = 0.\r\tself assert: context peek = $h.\r\tself assert: context uncheckedPeek = $h.\r\r\tself assert: context next = $h.\r\tself assert: context peek = $i.\r\tself assert: context uncheckedPeek = $i.\r\tself assert: context position = 1.\r\t\r\tcontext skip: 2.\r\tself assert: context position = 3.\r\tself assert: context peek = $t.\r\tself assert: context atEnd not.\r\t\r\tself assert: (context next: 5) = \'there\'.\r\tself assert: context position = 8.\r\tself assert: context atEnd.',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testStreamProtocol,			#protocol : #'as yet unclassified',			#sourceCode : 'testStreamProtocol\r\tcontext stream: \'hi there\' asPetitStream.\r\t\r\tself assert: context position = 0.\r\tself assert: context peek = $h.\r\tself assert: context uncheckedPeek = $h.\r\r\tself assert: context next = $h.\r\tself assert: context peek = $i.\r\tself assert: context uncheckedPeek = $i.\r\tself assert: context position = 1.\r\t\r\tcontext skip: 2.\r\tself assert: context position = 3.\r\tself assert: context peek = $t.\r\tself assert: context atEnd not.\r\t\r\tself assert: (context next: 5) = \'there\'.\r\tself assert: context position = 8.\r\tself assert: context atEnd.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ],		#time : DateAndTime [ '2020-01-07T02:12:41.350626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testStreamProtocol,			#protocol : #tests,			#sourceCode : 'testStreamProtocol\r\tcontext stream: \'hi there\' asPetitStream.\r\t\r\tself assert: context position = 0.\r\tself assert: context peek = $h.\r\tself assert: context uncheckedPeek = $h.\r\r\tself assert: context next = $h.\r\tself assert: context peek = $i.\r\tself assert: context uncheckedPeek = $i.\r\tself assert: context position = 1.\r\t\r\tcontext skip: 2.\r\tself assert: context position = 3.\r\tself assert: context peek = $t.\r\tself assert: context atEnd not.\r\t\r\tself assert: (context next: 5) = \'there\'.\r\tself assert: context position = 8.\r\tself assert: context atEnd.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ],		#time : DateAndTime [ '2020-01-07T02:12:41.356626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testRemoveProperties,			#protocol : #tests,			#sourceCode : 'testRemoveProperties\r\tcontext propertyAt: #foo put: #zorg.\r\tcontext propertyAt: #bar put: #qwark.\t\r\r\tself assert: (context removeProperty: #foo) = #zorg.\r\tself assert: (context removeProperty: #bar) = #qwark.\r\t\r\tself should: [context removeProperty: #foo] raise: Error.\r\tself assert: (context removeProperty: #bar ifAbsent: [ #foobar ]) = #foobar.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testRemoveProperties,			#protocol : #'as yet unclassified',			#sourceCode : 'testRemoveProperties\r\tcontext propertyAt: #foo put: #zorg.\r\tcontext propertyAt: #bar put: #qwark.\t\r\r\tself assert: (context removeProperty: #foo) = #zorg.\r\tself assert: (context removeProperty: #bar) = #qwark.\r\t\r\tself should: [context removeProperty: #foo] raise: Error.\r\tself assert: (context removeProperty: #bar ifAbsent: [ #foobar ]) = #foobar.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ],		#time : DateAndTime [ '2020-01-07T02:12:41.356626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testRemoveProperties,			#protocol : #tests,			#sourceCode : 'testRemoveProperties\r\tcontext propertyAt: #foo put: #zorg.\r\tcontext propertyAt: #bar put: #qwark.\t\r\r\tself assert: (context removeProperty: #foo) = #zorg.\r\tself assert: (context removeProperty: #bar) = #qwark.\r\t\r\tself should: [context removeProperty: #foo] raise: Error.\r\tself assert: (context removeProperty: #bar ifAbsent: [ #foobar ]) = #foobar.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ],		#time : DateAndTime [ '2020-01-07T02:12:41.360626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testRemoveGlobals,			#protocol : #tests,			#sourceCode : 'testRemoveGlobals\r\tcontext globalAt: #foo put: #zorg.\r\tcontext globalAt: #bar put: #qwark.\t\r\r\tself assert: (context removeGlobal: #foo) = #zorg.\r\tself assert: (context removeGlobal: #bar) = #qwark.\r\t\r\tself should: [context removeGlobal: #foo] raise: Error.\r\tself assert: (context removeGlobal: #bar ifAbsent: [ #foobar ]) = #foobar.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testRemoveGlobals,			#protocol : #'as yet unclassified',			#sourceCode : 'testRemoveGlobals\r\tcontext globalAt: #foo put: #zorg.\r\tcontext globalAt: #bar put: #qwark.\t\r\r\tself assert: (context removeGlobal: #foo) = #zorg.\r\tself assert: (context removeGlobal: #bar) = #qwark.\r\t\r\tself should: [context removeGlobal: #foo] raise: Error.\r\tself assert: (context removeGlobal: #bar ifAbsent: [ #foobar ]) = #foobar.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ],		#time : DateAndTime [ '2020-01-07T02:12:41.360626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testRemoveGlobals,			#protocol : #tests,			#sourceCode : 'testRemoveGlobals\r\tcontext globalAt: #foo put: #zorg.\r\tcontext globalAt: #bar put: #qwark.\t\r\r\tself assert: (context removeGlobal: #foo) = #zorg.\r\tself assert: (context removeGlobal: #bar) = #qwark.\r\t\r\tself should: [context removeGlobal: #foo] raise: Error.\r\tself assert: (context removeGlobal: #bar ifAbsent: [ #foobar ]) = #foobar.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ],		#time : DateAndTime [ '2020-01-07T02:12:41.364626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testPutProperties,			#protocol : #tests,			#sourceCode : 'testPutProperties\r\tself assert: (context hasProperty: #foo) not.\r\tself assert: (context hasProperty: #bar) not.\t\r\t\r\tself should: [ context propertyAt: #foo ] raise: Error.\r\tself assert: (context propertyAt: #foo ifAbsent: [ #bar ]) = #bar.\r\t\r\tself assert: (context propertyAt: #foo ifAbsentPut: [ #bar ]) = #bar.\t\r\tself assert: (context hasProperty: #foo).\r\tself assert: (context hasProperty: #bar) not.\t\r\tself assert: (context propertyAt: #foo) = #bar.\r\t\r\tself assert: (context propertyAt: #foo ifAbsentPut: [ #zorg ]) = #bar.\t\r\tself assert: (context hasProperty: #foo).\r\tself assert: (context hasProperty: #bar) not.\t\r\tself assert: (context propertyAt: #foo) = #bar.\r\t\r\tself assert: (context propertyAt: #foo put: #zorg) = #zorg.\t\r\tself assert: (context hasProperty: #foo).\r\tself assert: (context hasProperty: #bar) not.\t\r\tself assert: (context propertyAt: #foo) = #zorg.\r\t\r\tself should: [ context propertyAt: #bar ] raise: Error.\r\tself assert: (context propertyAt: #bar put: #foo) = #foo.\r\tself assert: (context propertyAt: #foo) = #zorg.\r\tself assert: (context propertyAt: #bar) = #foo.\r\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testPutProperties,			#protocol : #'as yet unclassified',			#sourceCode : 'testPutProperties\r\tself assert: (context hasProperty: #foo) not.\r\tself assert: (context hasProperty: #bar) not.\t\r\t\r\tself should: [ context propertyAt: #foo ] raise: Error.\r\tself assert: (context propertyAt: #foo ifAbsent: [ #bar ]) = #bar.\r\t\r\tself assert: (context propertyAt: #foo ifAbsentPut: [ #bar ]) = #bar.\t\r\tself assert: (context hasProperty: #foo).\r\tself assert: (context hasProperty: #bar) not.\t\r\tself assert: (context propertyAt: #foo) = #bar.\r\t\r\tself assert: (context propertyAt: #foo ifAbsentPut: [ #zorg ]) = #bar.\t\r\tself assert: (context hasProperty: #foo).\r\tself assert: (context hasProperty: #bar) not.\t\r\tself assert: (context propertyAt: #foo) = #bar.\r\t\r\tself assert: (context propertyAt: #foo put: #zorg) = #zorg.\t\r\tself assert: (context hasProperty: #foo).\r\tself assert: (context hasProperty: #bar) not.\t\r\tself assert: (context propertyAt: #foo) = #zorg.\r\t\r\tself should: [ context propertyAt: #bar ] raise: Error.\r\tself assert: (context propertyAt: #bar put: #foo) = #foo.\r\tself assert: (context propertyAt: #foo) = #zorg.\r\tself assert: (context propertyAt: #bar) = #foo.\r\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ],		#time : DateAndTime [ '2020-01-07T02:12:41.364626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testPutProperties,			#protocol : #tests,			#sourceCode : 'testPutProperties\r\tself assert: (context hasProperty: #foo) not.\r\tself assert: (context hasProperty: #bar) not.\t\r\t\r\tself should: [ context propertyAt: #foo ] raise: Error.\r\tself assert: (context propertyAt: #foo ifAbsent: [ #bar ]) = #bar.\r\t\r\tself assert: (context propertyAt: #foo ifAbsentPut: [ #bar ]) = #bar.\t\r\tself assert: (context hasProperty: #foo).\r\tself assert: (context hasProperty: #bar) not.\t\r\tself assert: (context propertyAt: #foo) = #bar.\r\t\r\tself assert: (context propertyAt: #foo ifAbsentPut: [ #zorg ]) = #bar.\t\r\tself assert: (context hasProperty: #foo).\r\tself assert: (context hasProperty: #bar) not.\t\r\tself assert: (context propertyAt: #foo) = #bar.\r\t\r\tself assert: (context propertyAt: #foo put: #zorg) = #zorg.\t\r\tself assert: (context hasProperty: #foo).\r\tself assert: (context hasProperty: #bar) not.\t\r\tself assert: (context propertyAt: #foo) = #zorg.\r\t\r\tself should: [ context propertyAt: #bar ] raise: Error.\r\tself assert: (context propertyAt: #bar put: #foo) = #foo.\r\tself assert: (context propertyAt: #foo) = #zorg.\r\tself assert: (context propertyAt: #bar) = #foo.\r\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ],		#time : DateAndTime [ '2020-01-07T02:12:41.368626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testPutGlobals,			#protocol : #tests,			#sourceCode : 'testPutGlobals\r\tself assert: (context hasGlobal: #foo) not.\r\tself assert: (context hasGlobal: #bar) not.\t\r\t\r\tself should: [ context globalAt: #foo ] raise: Error.\r\tself assert: (context globalAt: #foo ifAbsent: [ #bar ]) = #bar.\r\t\r\tself assert: (context globalAt: #foo ifAbsentPut: [ #bar ]) = #bar.\t\r\tself assert: (context hasGlobal: #foo).\r\tself assert: (context hasGlobal: #bar) not.\t\r\tself assert: (context globalAt: #foo) = #bar.\r\t\r\tself assert: (context globalAt: #foo ifAbsentPut: [ #zorg ]) = #bar.\t\r\tself assert: (context hasGlobal: #foo).\r\tself assert: (context hasGlobal: #bar) not.\t\r\tself assert: (context globalAt: #foo) = #bar.\r\t\r\tself assert: (context globalAt: #foo put: #zorg) = #zorg.\t\r\tself assert: (context hasGlobal: #foo).\r\tself assert: (context hasGlobal: #bar) not.\t\r\tself assert: (context globalAt: #foo) = #zorg.\r\t\r\tself should: [ context globalAt: #bar ] raise: Error.\r\tself assert: (context globalAt: #bar put: #foo) = #foo.\r\tself assert: (context globalAt: #foo) = #zorg.\r\tself assert: (context globalAt: #bar) = #foo.\r\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testPutGlobals,			#protocol : #'as yet unclassified',			#sourceCode : 'testPutGlobals\r\tself assert: (context hasGlobal: #foo) not.\r\tself assert: (context hasGlobal: #bar) not.\t\r\t\r\tself should: [ context globalAt: #foo ] raise: Error.\r\tself assert: (context globalAt: #foo ifAbsent: [ #bar ]) = #bar.\r\t\r\tself assert: (context globalAt: #foo ifAbsentPut: [ #bar ]) = #bar.\t\r\tself assert: (context hasGlobal: #foo).\r\tself assert: (context hasGlobal: #bar) not.\t\r\tself assert: (context globalAt: #foo) = #bar.\r\t\r\tself assert: (context globalAt: #foo ifAbsentPut: [ #zorg ]) = #bar.\t\r\tself assert: (context hasGlobal: #foo).\r\tself assert: (context hasGlobal: #bar) not.\t\r\tself assert: (context globalAt: #foo) = #bar.\r\t\r\tself assert: (context globalAt: #foo put: #zorg) = #zorg.\t\r\tself assert: (context hasGlobal: #foo).\r\tself assert: (context hasGlobal: #bar) not.\t\r\tself assert: (context globalAt: #foo) = #zorg.\r\t\r\tself should: [ context globalAt: #bar ] raise: Error.\r\tself assert: (context globalAt: #bar put: #foo) = #foo.\r\tself assert: (context globalAt: #foo) = #zorg.\r\tself assert: (context globalAt: #bar) = #foo.\r\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ],		#time : DateAndTime [ '2020-01-07T02:12:41.368626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testPutGlobals,			#protocol : #tests,			#sourceCode : 'testPutGlobals\r\tself assert: (context hasGlobal: #foo) not.\r\tself assert: (context hasGlobal: #bar) not.\t\r\t\r\tself should: [ context globalAt: #foo ] raise: Error.\r\tself assert: (context globalAt: #foo ifAbsent: [ #bar ]) = #bar.\r\t\r\tself assert: (context globalAt: #foo ifAbsentPut: [ #bar ]) = #bar.\t\r\tself assert: (context hasGlobal: #foo).\r\tself assert: (context hasGlobal: #bar) not.\t\r\tself assert: (context globalAt: #foo) = #bar.\r\t\r\tself assert: (context globalAt: #foo ifAbsentPut: [ #zorg ]) = #bar.\t\r\tself assert: (context hasGlobal: #foo).\r\tself assert: (context hasGlobal: #bar) not.\t\r\tself assert: (context globalAt: #foo) = #bar.\r\t\r\tself assert: (context globalAt: #foo put: #zorg) = #zorg.\t\r\tself assert: (context hasGlobal: #foo).\r\tself assert: (context hasGlobal: #bar) not.\t\r\tself assert: (context globalAt: #foo) = #zorg.\r\t\r\tself should: [ context globalAt: #bar ] raise: Error.\r\tself assert: (context globalAt: #bar put: #foo) = #foo.\r\tself assert: (context globalAt: #foo) = #zorg.\r\tself assert: (context globalAt: #bar) = #foo.\r\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ],		#time : DateAndTime [ '2020-01-07T02:12:41.372626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testMemoization3,			#protocol : #tests,			#sourceCode : 'testMemoization3\r\t| stream memento memento2 collection |\r\tstream := \'abc\' asPetitStream.\r\tcontext := context stream: stream.\r\tcollection := OrderedCollection new.\r\r\tmemento := context remember.\r\tcontext propertyAt: #foo put: collection.\r\tmemento2 := context remember.\r\t\r\tcontext restore: memento.\r\tself assert: (context hasProperty: #foo) not.\r\t\r\tcontext restore: memento2.\r\tself assert: (context hasProperty: #foo).',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testMemoization3,			#protocol : #'as yet unclassified',			#sourceCode : 'testMemoization3\r\t| stream memento memento2 collection |\r\tstream := \'abc\' asPetitStream.\r\tcontext := context stream: stream.\r\tcollection := OrderedCollection new.\r\r\tmemento := context remember.\r\tcontext propertyAt: #foo put: collection.\r\tmemento2 := context remember.\r\t\r\tcontext restore: memento.\r\tself assert: (context hasProperty: #foo) not.\r\t\r\tcontext restore: memento2.\r\tself assert: (context hasProperty: #foo).',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ],		#time : DateAndTime [ '2020-01-07T02:12:41.372626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testMemoization3,			#protocol : #tests,			#sourceCode : 'testMemoization3\r\t| stream memento memento2 collection |\r\tstream := \'abc\' asPetitStream.\r\tcontext := context stream: stream.\r\tcollection := OrderedCollection new.\r\r\tmemento := context remember.\r\tcontext propertyAt: #foo put: collection.\r\tmemento2 := context remember.\r\t\r\tcontext restore: memento.\r\tself assert: (context hasProperty: #foo) not.\r\t\r\tcontext restore: memento2.\r\tself assert: (context hasProperty: #foo).',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ],		#time : DateAndTime [ '2020-01-07T02:12:41.376626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testMemoization2,			#protocol : #tests,			#sourceCode : 'testMemoization2\r\t| stream memento |\r\tstream := \'abc\' asPetitStream.\r\tcontext := context stream: stream.\r\t\r\tmemento := context remember.\r\t\r\tcontext next.\r\tself assert: context position = 1.\r\t\r\tcontext restore: memento.\r\tself assert: context position = 0.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testMemoization2,			#protocol : #'as yet unclassified',			#sourceCode : 'testMemoization2\r\t| stream memento |\r\tstream := \'abc\' asPetitStream.\r\tcontext := context stream: stream.\r\t\r\tmemento := context remember.\r\t\r\tcontext next.\r\tself assert: context position = 1.\r\t\r\tcontext restore: memento.\r\tself assert: context position = 0.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ],		#time : DateAndTime [ '2020-01-07T02:12:41.376626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testMemoization2,			#protocol : #tests,			#sourceCode : 'testMemoization2\r\t| stream memento |\r\tstream := \'abc\' asPetitStream.\r\tcontext := context stream: stream.\r\t\r\tmemento := context remember.\r\t\r\tcontext next.\r\tself assert: context position = 1.\r\t\r\tcontext restore: memento.\r\tself assert: context position = 0.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ],		#time : DateAndTime [ '2020-01-07T02:12:41.380626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testMemoization,			#protocol : #tests,			#sourceCode : 'testMemoization\r\t| stream memento memento2 collection |\r\tstream := \'abc\' asPetitStream.\r\tcontext := context stream: stream.\r\tcollection := OrderedCollection new.\r\r\tcontext propertyAt: #foo put: collection.\r\t\r\tmemento := context remember.\r\t\r\tself assert: memento isNil not.\r\t\r\tcontext next.\r\tcollection add: #element.\r\tself assert: (context propertyAt: #foo) size = 1. \t\r\r\tmemento2 := context remember.\r\r\tcontext restore: memento.\r\tself assert: (context propertyAt: #foo) size = 0. \r\tself assert: context position = 0.\r\t\r\tcontext restore: memento2.\r\tself assert: (context propertyAt: #foo) size = 1. \r\tself assert: context position = 1.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testMemoization,			#protocol : #'as yet unclassified',			#sourceCode : 'testMemoization\r\t| stream memento memento2 collection |\r\tstream := \'abc\' asPetitStream.\r\tcontext := context stream: stream.\r\tcollection := OrderedCollection new.\r\r\tcontext propertyAt: #foo put: collection.\r\t\r\tmemento := context remember.\r\t\r\tself assert: memento isNil not.\r\t\r\tcontext next.\r\tcollection add: #element.\r\tself assert: (context propertyAt: #foo) size = 1. \t\r\r\tmemento2 := context remember.\r\r\tcontext restore: memento.\r\tself assert: (context propertyAt: #foo) size = 0. \r\tself assert: context position = 0.\r\t\r\tcontext restore: memento2.\r\tself assert: (context propertyAt: #foo) size = 1. \r\tself assert: context position = 1.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ],		#time : DateAndTime [ '2020-01-07T02:12:41.380626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testMemoization,			#protocol : #tests,			#sourceCode : 'testMemoization\r\t| stream memento memento2 collection |\r\tstream := \'abc\' asPetitStream.\r\tcontext := context stream: stream.\r\tcollection := OrderedCollection new.\r\r\tcontext propertyAt: #foo put: collection.\r\t\r\tmemento := context remember.\r\t\r\tself assert: memento isNil not.\r\t\r\tcontext next.\r\tcollection add: #element.\r\tself assert: (context propertyAt: #foo) size = 1. \t\r\r\tmemento2 := context remember.\r\r\tcontext restore: memento.\r\tself assert: (context propertyAt: #foo) size = 0. \r\tself assert: context position = 0.\r\t\r\tcontext restore: memento2.\r\tself assert: (context propertyAt: #foo) size = 1. \r\tself assert: context position = 1.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ],		#time : DateAndTime [ '2020-01-07T02:12:41.384626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testFurthestFailure,			#protocol : #tests,			#sourceCode : 'testFurthestFailure\r\t| f1 f2 |\r\t\r\tf1 := PPFailure message: #foo context: context at: 1.\r\tself assert: context furthestFailure = f1.\t\r\tf2 := PPFailure message: #foo context: context at: 1.\r\tself assert: context furthestFailure = f1.\t\r\tf2 := PPFailure message: #foo context: context at: 3.\r\tself assert: context furthestFailure = f2.',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testFurthestFailure,			#protocol : #'as yet unclassified',			#sourceCode : 'testFurthestFailure\r\t| f1 f2 |\r\t\r\tf1 := PPFailure message: #foo context: context at: 1.\r\tself assert: context furthestFailure = f1.\t\r\tf2 := PPFailure message: #foo context: context at: 1.\r\tself assert: context furthestFailure = f1.\t\r\tf2 := PPFailure message: #foo context: context at: 3.\r\tself assert: context furthestFailure = f2.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ],		#time : DateAndTime [ '2020-01-07T02:12:41.384626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #testFurthestFailure,			#protocol : #tests,			#sourceCode : 'testFurthestFailure\r\t| f1 f2 |\r\t\r\tf1 := PPFailure message: #foo context: context at: 1.\r\tself assert: context furthestFailure = f1.\t\r\tf2 := PPFailure message: #foo context: context at: 1.\r\tself assert: context furthestFailure = f1.\t\r\tf2 := PPFailure message: #foo context: context at: 3.\r\tself assert: context furthestFailure = f2.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ],		#time : DateAndTime [ '2020-01-07T02:12:41.387626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #PPContextTest\r\tinstanceVariableNames: \'context\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'TestCase'			},			#name : #PPContextTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextTest,						#isMetaSide : false					},					#name : #context,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContextTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContextTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#protocol : #tests	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ],		#time : DateAndTime [ '2020-01-07T02:12:41.388626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tcontext := self context.',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #'as yet unclassified',			#sourceCode : 'setUp\r\tsuper setUp.\r\tcontext := self context.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ],		#time : DateAndTime [ '2020-01-07T02:12:41.389626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tcontext := self context.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ],		#time : DateAndTime [ '2020-01-07T02:12:41.391626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #PPContextTest\r\tinstanceVariableNames: \'context\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'TestCase'			},			#name : #PPContextTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextTest,						#isMetaSide : false					},					#name : #context,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContextTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContextTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#protocol : #running	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ],		#time : DateAndTime [ '2020-01-07T02:12:41.392626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextTest,				#isMetaSide : false			},			#name : #context,			#protocol : #'as yet unclassified',			#sourceCode : 'context\r\t^ PPContext new',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ],		#time : DateAndTime [ '2020-01-07T02:12:41.464626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #PPContextTest\r\tinstanceVariableNames: \'context\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitTests-Tests\'',				#superclassName : 'TestCase'			},			#name : #PPContextTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContextTest,						#isMetaSide : false					},					#name : #context,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextTest class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPContextTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPContextTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ],		#time : DateAndTime [ '2020-01-07T02:12:41.466626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testPutProperty,			#protocol : #tests,			#sourceCode : 'testPutProperty\r\t| c retval  |\r\tc := OrderedCollection new.\r\tself assert: (memento hasProperty: #foo) not.\r\tself assert: (memento hasProperty: #bar) not.\t\r\t\r\tself should: [ memento propertyAt: #foo ] raise: Error.\r\tself assert: (memento propertyAt: #foo ifAbsent: [ c ]) == c.\r\t\r\tretval := memento propertyAt: #foo ifAbsentPut: [ c ].\r\tself assert: retval size = c size.\t\r\tself assert: (retval == c) not.\r\tself assert: retval = c.\r\tself assert: (memento hasProperty: #foo).\r\t\r\tretval := memento propertyAt: #bar put: c.\r\tself assert: retval size = c size.\t\r\tself assert: (retval == c) not.\r\tself assert: retval = c.\r\tself assert: (memento hasProperty: #foo).\t\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testPutProperty,			#protocol : #'as yet unclassified',			#sourceCode : 'testPutProperty\r\t| c retval  |\r\tc := OrderedCollection new.\r\tself assert: (memento hasProperty: #foo) not.\r\tself assert: (memento hasProperty: #bar) not.\t\r\t\r\tself should: [ memento propertyAt: #foo ] raise: Error.\r\tself assert: (memento propertyAt: #foo ifAbsent: [ c ]) == c.\r\t\r\tretval := memento propertyAt: #foo ifAbsentPut: [ c ].\r\tself assert: retval size = c size.\t\r\tself assert: (retval == c) not.\r\tself assert: retval = c.\r\tself assert: (memento hasProperty: #foo).\r\t\r\tretval := memento propertyAt: #bar put: c.\r\tself assert: retval size = c size.\t\r\tself assert: (retval == c) not.\r\tself assert: retval = c.\r\tself assert: (memento hasProperty: #foo).\t\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ],		#time : DateAndTime [ '2020-01-07T02:12:41.467626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testPutProperty,			#protocol : #tests,			#sourceCode : 'testPutProperty\r\t| c retval  |\r\tc := OrderedCollection new.\r\tself assert: (memento hasProperty: #foo) not.\r\tself assert: (memento hasProperty: #bar) not.\t\r\t\r\tself should: [ memento propertyAt: #foo ] raise: Error.\r\tself assert: (memento propertyAt: #foo ifAbsent: [ c ]) == c.\r\t\r\tretval := memento propertyAt: #foo ifAbsentPut: [ c ].\r\tself assert: retval size = c size.\t\r\tself assert: (retval == c) not.\r\tself assert: retval = c.\r\tself assert: (memento hasProperty: #foo).\r\t\r\tretval := memento propertyAt: #bar put: c.\r\tself assert: retval size = c size.\t\r\tself assert: (retval == c) not.\r\tself assert: retval = c.\r\tself assert: (memento hasProperty: #foo).\t\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ],		#time : DateAndTime [ '2020-01-07T02:12:41.470626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testKeysAndValuesDo2,			#protocol : #tests,			#sourceCode : 'testKeysAndValuesDo2\r\t| c1 c2   |\r\tc1 := OrderedCollection new.\r\tc2 := OrderedCollection new.\r\r\tmemento propertyAt: #foo put: c1.\r\tmemento propertyAt: #bar put: c2.\r\r\tmemento keysAndValuesDo: [ :key :value |\r\t\tself assert: (value == c1) not.\r\t\tself assert: (value == c2) not.\r\t].',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testKeysAndValuesDo2,			#protocol : #'as yet unclassified',			#sourceCode : 'testKeysAndValuesDo2\r\t| c1 c2   |\r\tc1 := OrderedCollection new.\r\tc2 := OrderedCollection new.\r\r\tmemento propertyAt: #foo put: c1.\r\tmemento propertyAt: #bar put: c2.\r\r\tmemento keysAndValuesDo: [ :key :value |\r\t\tself assert: (value == c1) not.\r\t\tself assert: (value == c2) not.\r\t].',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ],		#time : DateAndTime [ '2020-01-07T02:12:41.471626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testKeysAndValuesDo2,			#protocol : #tests,			#sourceCode : 'testKeysAndValuesDo2\r\t| c1 c2   |\r\tc1 := OrderedCollection new.\r\tc2 := OrderedCollection new.\r\r\tmemento propertyAt: #foo put: c1.\r\tmemento propertyAt: #bar put: c2.\r\r\tmemento keysAndValuesDo: [ :key :value |\r\t\tself assert: (value == c1) not.\r\t\tself assert: (value == c2) not.\r\t].',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ],		#time : DateAndTime [ '2020-01-07T02:12:41.474626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testKeysAndValuesDo,			#protocol : #tests,			#sourceCode : 'testKeysAndValuesDo\r\t|   |\r\tmemento keysAndValuesDo: [ :key :value |\r\t\tself signalFailure: \'Should not be called\'\r\t].',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testKeysAndValuesDo,			#protocol : #'as yet unclassified',			#sourceCode : 'testKeysAndValuesDo\r\t|   |\r\tmemento keysAndValuesDo: [ :key :value |\r\t\tself signalFailure: \'Should not be called\'\r\t].',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ],		#time : DateAndTime [ '2020-01-07T02:12:41.475626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testKeysAndValuesDo,			#protocol : #tests,			#sourceCode : 'testKeysAndValuesDo\r\t|   |\r\tmemento keysAndValuesDo: [ :key :value |\r\t\tself signalFailure: \'Should not be called\'\r\t].',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ],		#time : DateAndTime [ '2020-01-07T02:12:41.482626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testGetProperty,			#protocol : #tests,			#sourceCode : 'testGetProperty\r\t\r\t| c retval retval2 |\r\tc := OrderedCollection new.\r\t\r\tmemento propertyAt: #foo put: c.\r\t\r\tretval := memento propertyAt: #foo.\r\tself assert: retval size = c size.\r\tself assert: (retval == c) not.\r\tself assert: retval = c.\r\t\r\tc add: #element.\r\tself assert: (retval = c) not.\r\r\tretval2 := memento propertyAt: #foo.\r\tself assert: (retval = retval2).\r\tself assert: (retval == retval2) not.\r\t\r\tretval add: #element.\r\tself assert: (retval = retval2) not.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testGetProperty,			#protocol : #'as yet unclassified',			#sourceCode : 'testGetProperty\r\t\r\t| c retval retval2 |\r\tc := OrderedCollection new.\r\t\r\tmemento propertyAt: #foo put: c.\r\t\r\tretval := memento propertyAt: #foo.\r\tself assert: retval size = c size.\r\tself assert: (retval == c) not.\r\tself assert: retval = c.\r\t\r\tc add: #element.\r\tself assert: (retval = c) not.\r\r\tretval2 := memento propertyAt: #foo.\r\tself assert: (retval = retval2).\r\tself assert: (retval == retval2) not.\r\t\r\tretval add: #element.\r\tself assert: (retval = retval2) not.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ],		#time : DateAndTime [ '2020-01-07T02:12:41.482626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testGetProperty,			#protocol : #tests,			#sourceCode : 'testGetProperty\r\t\r\t| c retval retval2 |\r\tc := OrderedCollection new.\r\t\r\tmemento propertyAt: #foo put: c.\r\t\r\tretval := memento propertyAt: #foo.\r\tself assert: retval size = c size.\r\tself assert: (retval == c) not.\r\tself assert: retval = c.\r\t\r\tc add: #element.\r\tself assert: (retval = c) not.\r\r\tretval2 := memento propertyAt: #foo.\r\tself assert: (retval = retval2).\r\tself assert: (retval == retval2) not.\r\t\r\tretval add: #element.\r\tself assert: (retval = retval2) not.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ],		#time : DateAndTime [ '2020-01-07T02:12:41.485626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testEquality2,			#protocol : #tests,			#sourceCode : 'testEquality2\r\t| m1 m2  |\r\tm1 := self memento.\r\tm2 := self memento.\r\t\r\tself assert: m1 = m2.\r\t\r\tm1 propertyAt: #foo put: #bar.\r\tself assert: (m1 = m2) not.\r\t\r\tm2 propertyAt: #bar put: #foo.\r\tself assert: (m1 = m2) not.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testEquality2,			#protocol : #'as yet unclassified',			#sourceCode : 'testEquality2\r\t| m1 m2  |\r\tm1 := self memento.\r\tm2 := self memento.\r\t\r\tself assert: m1 = m2.\r\t\r\tm1 propertyAt: #foo put: #bar.\r\tself assert: (m1 = m2) not.\r\t\r\tm2 propertyAt: #bar put: #foo.\r\tself assert: (m1 = m2) not.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ],		#time : DateAndTime [ '2020-01-07T02:12:41.486626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testEquality2,			#protocol : #tests,			#sourceCode : 'testEquality2\r\t| m1 m2  |\r\tm1 := self memento.\r\tm2 := self memento.\r\t\r\tself assert: m1 = m2.\r\t\r\tm1 propertyAt: #foo put: #bar.\r\tself assert: (m1 = m2) not.\r\t\r\tm2 propertyAt: #bar put: #foo.\r\tself assert: (m1 = m2) not.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ],		#time : DateAndTime [ '2020-01-07T02:12:41.489626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testEquality,			#protocol : #tests,			#sourceCode : 'testEquality\r\t| m1 m2  |\r\tm1 := self memento.\r\tm2 := self memento.\r\t\r\tself assert: m1 = m2.\r\t\r\tm1 propertyAt: #foo put: #bar.\r\tself assert: (m1 = m2) not.\r\t\r\tm2 propertyAt: #foo put: #bar.\r\tself assert: m1 = m2.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testEquality,			#protocol : #'as yet unclassified',			#sourceCode : 'testEquality\r\t| m1 m2  |\r\tm1 := self memento.\r\tm2 := self memento.\r\t\r\tself assert: m1 = m2.\r\t\r\tm1 propertyAt: #foo put: #bar.\r\tself assert: (m1 = m2) not.\r\t\r\tm2 propertyAt: #foo put: #bar.\r\tself assert: m1 = m2.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ],		#time : DateAndTime [ '2020-01-07T02:12:41.490626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #testEquality,			#protocol : #tests,			#sourceCode : 'testEquality\r\t| m1 m2  |\r\tm1 := self memento.\r\tm2 := self memento.\r\t\r\tself assert: m1 = m2.\r\t\r\tm1 propertyAt: #foo put: #bar.\r\tself assert: (m1 = m2) not.\r\t\r\tm2 propertyAt: #foo put: #bar.\r\tself assert: m1 = m2.\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ],		#time : DateAndTime [ '2020-01-07T02:12:41.493626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #PPContextMementoTest\r\tinstanceVariableNames: \'memento\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'TestCase'			},			#name : #PPContextMementoTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMementoTest,						#isMetaSide : false					},					#name : #memento,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextMementoTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContextMementoTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContextMementoTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#protocol : #tests	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ],		#time : DateAndTime [ '2020-01-07T02:12:41.494626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tmemento := self memento.',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #'as yet unclassified',			#sourceCode : 'setUp\r\tsuper setUp.\r\tmemento := self memento.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ],		#time : DateAndTime [ '2020-01-07T02:12:41.494626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tmemento := self memento.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ],		#time : DateAndTime [ '2020-01-07T02:12:41.497626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #PPContextMementoTest\r\tinstanceVariableNames: \'memento\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'TestCase'			},			#name : #PPContextMementoTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMementoTest,						#isMetaSide : false					},					#name : #memento,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextMementoTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContextMementoTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContextMementoTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#protocol : #running	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ],		#time : DateAndTime [ '2020-01-07T02:12:41.498626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #memento,			#protocol : #accessing,			#sourceCode : 'memento\r\t^ PPContextMemento new',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #memento,			#protocol : #'as yet unclassified',			#sourceCode : 'memento\r\t^ PPContextMemento new',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ],		#time : DateAndTime [ '2020-01-07T02:12:41.498626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMementoTest,				#isMetaSide : false			},			#name : #memento,			#protocol : #accessing,			#sourceCode : 'memento\r\t^ PPContextMemento new',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ],		#time : DateAndTime [ '2020-01-07T02:12:41.501626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #PPContextMementoTest\r\tinstanceVariableNames: \'memento\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'TestCase'			},			#name : #PPContextMementoTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMementoTest,						#isMetaSide : false					},					#name : #memento,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextMementoTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContextMementoTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContextMementoTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#protocol : #accessing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ],		#time : DateAndTime [ '2020-01-07T02:12:41.589626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #PPContextMementoTest\r\tinstanceVariableNames: \'memento\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitTests-Tests\'',				#superclassName : 'TestCase'			},			#name : #PPContextMementoTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContextMementoTest,						#isMetaSide : false					},					#name : #memento,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextMementoTest class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPContextMementoTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPContextMementoTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ],		#time : DateAndTime [ '2020-01-07T02:12:41.597626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PositionableStream,				#isMetaSide : false			},			#name : #peekTwice,			#protocol : #'*PetitParser',			#sourceCode : 'peekTwice\r\t"Answer what would be returned if the message next were sent to the \r\treceiver. If the receiver is at the end, answer nil."\r\r\t| array |\r\tself atEnd \r\t\tifTrue: [^Array with: nil with: nil].\r\tarray := Array with: (self next) with: (self peek).\r\tposition := position - 1.\r\t^array',			#stamp : '',			#package : #Collections-Streams		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PositionableStream,				#isMetaSide : false			},			#name : #peekTwice,			#protocol : #'as yet unclassified',			#sourceCode : 'peekTwice\r\t"Answer what would be returned if the message next were sent to the \r\treceiver. If the receiver is at the end, answer nil."\r\r\t| array |\r\tself atEnd \r\t\tifTrue: [^Array with: nil with: nil].\r\tarray := Array with: (self next) with: (self peek).\r\tposition := position - 1.\r\t^array',			#stamp : '',			#package : #Collections-Streams		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ],		#time : DateAndTime [ '2020-01-07T02:12:41.598626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PositionableStream,				#isMetaSide : false			},			#name : #peekTwice,			#protocol : #'*PetitParser',			#sourceCode : 'peekTwice\r\t"Answer what would be returned if the message next were sent to the \r\treceiver. If the receiver is at the end, answer nil."\r\r\t| array |\r\tself atEnd \r\t\tifTrue: [^Array with: nil with: nil].\r\tarray := Array with: (self next) with: (self peek).\r\tposition := position - 1.\r\t^array',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ],		#time : DateAndTime [ '2020-01-07T02:12:41.603626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PositionableStream,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*PetitParser',			#sourceCode : 'asPetitStream\r\t"Some of my subclasses do not use the instance-variables collection, position and readLimit but instead have a completely different internal representation. In these cases just use the super implementation that is inefficient but should work in all cases."\r\r"\r\tDisabled until we agree on some way how to optimize this\r\r\t^ (collection isNil or: [ position isNil or: [ readLimit isNil ] ])\r\t\tifFalse: [ PPStream on: collection from: ( position + 1 ) to: readLimit ]\r      ifTrue: [ super asPetitStream ]\r"\r\t^ super asPetitStream',			#stamp : '',			#package : #Collections-Streams		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PositionableStream,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'as yet unclassified',			#sourceCode : 'asPetitStream\r\t"Some of my subclasses do not use the instance-variables collection, position and readLimit but instead have a completely different internal representation. In these cases just use the super implementation that is inefficient but should work in all cases."\r\r"\r\tDisabled until we agree on some way how to optimize this\r\r\t^ (collection isNil or: [ position isNil or: [ readLimit isNil ] ])\r\t\tifFalse: [ PPStream on: collection from: ( position + 1 ) to: readLimit ]\r      ifTrue: [ super asPetitStream ]\r"\r\t^ super asPetitStream',			#stamp : '',			#package : #Collections-Streams		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ],		#time : DateAndTime [ '2020-01-07T02:12:41.603626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PositionableStream,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*PetitParser',			#sourceCode : 'asPetitStream\r\t"Some of my subclasses do not use the instance-variables collection, position and readLimit but instead have a completely different internal representation. In these cases just use the super implementation that is inefficient but should work in all cases."\r\r"\r\tDisabled until we agree on some way how to optimize this\r\r\t^ (collection isNil or: [ position isNil or: [ readLimit isNil ] ])\r\t\tifFalse: [ PPStream on: collection from: ( position + 1 ) to: readLimit ]\r      ifTrue: [ super asPetitStream ]\r"\r\t^ super asPetitStream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ],		#time : DateAndTime [ '2020-01-07T02:12:41.609626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Stream subclass: #PositionableStream\r\tinstanceVariableNames: \'collection position readLimit\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'Collections-Streams-Base\'',				#superclassName : 'Stream'			},			#name : #PositionableStream,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PositionableStream,						#isMetaSide : false					},					#name : #collection,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PositionableStream,						#isMetaSide : false					},					#name : #position,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PositionableStream,						#isMetaSide : false					},					#name : #readLimit,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PositionableStream class\r\tinstanceVariableNames: \'\''				},				#name : #'PositionableStream class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PositionableStream,					#isMetaSide : false				},				#parent : @8,				#content : 'I represent an accessor for a sequence of objects (a collection) that are externally named by indices so that the point of access can be repositioned. I am abstract in that I do not implement the messages next and nextPut: which are inherited from my superclass Stream.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #Collections-Streams-Base,			#package : #Collections-Streams,			#sharedPools : OrderedCollection [ ]		},		#protocol : #'*PetitParser'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ],		#time : DateAndTime [ '2020-01-07T02:12:41.611626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedChoiceParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'parseOn: aPPContext\r\t"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."\r\r\t| element limitResult memento |\r\t"self halt."\r\t1 to: parsers size do: [ :index |\r\t\tmemento := aPPContext remember.\r\t\t\r\t\telement := (parsers at: index)\r\t\t\tparseOn: aPPContext.\r\t\t\r\t\t(element isPetitFailure not) ifTrue: [ \r\t\t\t"check limit"\r\t\t\tlimitResult := limit parseOn: aPPContext.\r\t\t\tlimitResult isPetitFailure ifTrue: [ \r\t\t\t\telement := PPFailure message: \'limit failed\' at: aPPContext position .\r\t\t\t\taPPContext restore: memento.\r\t\t\t] ifFalse: [ ^ element ].\r\t\t].\r\t].\t\r\t^ element',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ],		#time : DateAndTime [ '2020-01-07T02:12:41.614626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedChoiceParser,				#isMetaSide : false			},			#name : #'limit:',			#protocol : #accessing,			#sourceCode : 'limit: anObject\r\t\r\tlimit := anObject',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedChoiceParser,				#isMetaSide : false			},			#name : #'limit:',			#protocol : #'as yet unclassified',			#sourceCode : 'limit: anObject\r\t\r\tlimit := anObject',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ],		#time : DateAndTime [ '2020-01-07T02:12:41.614626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedChoiceParser,				#isMetaSide : false			},			#name : #'limit:',			#protocol : #accessing,			#sourceCode : 'limit: anObject\r\t\r\tlimit := anObject',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ],		#time : DateAndTime [ '2020-01-07T02:12:41.618626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedChoiceParser,				#isMetaSide : false			},			#name : #limit,			#protocol : #accessing,			#sourceCode : 'limit\r\t\r\t^ limit',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedChoiceParser,				#isMetaSide : false			},			#name : #limit,			#protocol : #'as yet unclassified',			#sourceCode : 'limit\r\t\r\t^ limit',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ],		#time : DateAndTime [ '2020-01-07T02:12:41.618626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedChoiceParser,				#isMetaSide : false			},			#name : #limit,			#protocol : #accessing,			#sourceCode : 'limit\r\t\r\t^ limit',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ],		#time : DateAndTime [ '2020-01-07T02:12:41.621626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPChoiceParser subclass: #PPLimitedChoiceParser\r\tinstanceVariableNames: \'limit\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPChoiceParser'			},			#name : #PPLimitedChoiceParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPLimitedChoiceParser,						#isMetaSide : false					},					#name : #limit,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPLimitedChoiceParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPLimitedChoiceParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPLimitedChoiceParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPLimitedChoiceParser is similar to the choice parser except for the fact, that limit must pass if one of the choices passes. This is similar strategy as with the PPLimitedRepeatingParsers.\r\rThis way, one can implement choices that successfully parse this (if limit is filled with \'a\'):\r\r(\'aa\' // \'a\') \'a\' parse: \'aa\'\r\rThe limit can be automatically filled using elements from either follow or next set (see methods  PPParser>>followSets or PPParser>>nextSets).\r\rLimit is by default epsilon and therefore it behaves as an ordinary ordered choice.\r\rInstance Variables\r\tlimit:\t\t<Object>\r\rlimit\r\t- xxxxx\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #accessing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ],		#time : DateAndTime [ '2020-01-07T02:12:41.621626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedChoiceParser,				#isMetaSide : false			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r\tlimit := nil asParser',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ],		#time : DateAndTime [ '2020-01-07T02:12:41.624626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedChoiceParser,				#isMetaSide : false			},			#name : #//,			#protocol : #'as yet unclassified',			#sourceCode : '// aRule \r\t^ self copyWith: aRule',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ],		#time : DateAndTime [ '2020-01-07T02:12:41.691626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPChoiceParser subclass: #PPLimitedChoiceParser\r\tinstanceVariableNames: \'limit\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitParser-Parsers\'',				#superclassName : 'PPChoiceParser'			},			#name : #PPLimitedChoiceParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPLimitedChoiceParser,						#isMetaSide : false					},					#name : #limit,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPLimitedChoiceParser class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPLimitedChoiceParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPLimitedChoiceParser,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ],		#time : DateAndTime [ '2020-01-07T02:12:41.693626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMappingTest,				#isMetaSide : false			},			#name : #testMap3,			#protocol : #'as yet unclassified',			#sourceCode : 'testMap3\r\t| parser |\r\tparser := (#any asParser , #any asParser , #any asParser)\r\t\tmap: [ :a :b :c | Array with: c with: b with: a ].\r\r\tself assert: parser parse: #(a b c) to: #(c b a)\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ],		#time : DateAndTime [ '2020-01-07T02:12:41.696626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMappingTest,				#isMetaSide : false			},			#name : #testMap2,			#protocol : #'as yet unclassified',			#sourceCode : 'testMap2\r\t| parser |\r\tparser := (#any asParser , #any asParser) \r\t\tmap: [ :a :b | Array with: b with: a ].\r\r\tself assert: parser parse: #(a b) to: #(b a)',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ],		#time : DateAndTime [ '2020-01-07T02:12:41.699626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMappingTest,				#isMetaSide : false			},			#name : #testMap1,			#protocol : #'as yet unclassified',			#sourceCode : 'testMap1\r\t| parser |\r\tparser := #any asParser \r\t\tmap: [ :a | Array with: a ].\r\r\tself assert: parser parse: #(a) to: #(a)',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ],		#time : DateAndTime [ '2020-01-07T02:12:41.702626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMappingTest,				#isMetaSide : false			},			#name : #testFoldRight3,			#protocol : #'as yet unclassified',			#sourceCode : 'testFoldRight3\r\t| parser |\r\tparser := #any asParser star \r\t\tfoldRight: [ :a :b :c | Array with: a with: b with: c ].\r\r\tself assert: parser parse: #(a) to: #a.\r\tself assert: parser parse: #(a b c) to: #(a b c).\r\tself assert: parser parse: #(a b c d e) to: #(a b (c d e))',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ],		#time : DateAndTime [ '2020-01-07T02:12:41.705626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMappingTest,				#isMetaSide : false			},			#name : #testFoldRight2,			#protocol : #'as yet unclassified',			#sourceCode : 'testFoldRight2\r\t| parser |\r\tparser := #any asParser star \r\t\tfoldRight: [ :a :b | Array with: a with: b ].\r\r\tself assert: parser parse: #(a) to: #a.\r\tself assert: parser parse: #(a b) to: #(a b).\r\tself assert: parser parse: #(a b c) to: #(a (b c)).\r\tself assert: parser parse: #(a b c d) to: #(a (b (c d))).\r\tself assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ],		#time : DateAndTime [ '2020-01-07T02:12:41.708626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMappingTest,				#isMetaSide : false			},			#name : #testFoldLeft3,			#protocol : #'as yet unclassified',			#sourceCode : 'testFoldLeft3\r\t| parser |\r\tparser := #any asParser star \r\t\tfoldLeft: [ :a :b :c | Array with: a with: b with: c ].\r\r\tself assert: parser parse: #(a) to: #a.\r\tself assert: parser parse: #(a b c) to: #(a b c).\r\tself assert: parser parse: #(a b c d e) to: #((a b c) d e)\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ],		#time : DateAndTime [ '2020-01-07T02:12:41.711626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMappingTest,				#isMetaSide : false			},			#name : #testFoldLeft2,			#protocol : #'as yet unclassified',			#sourceCode : 'testFoldLeft2\r\t| parser |\r\tparser := #any asParser star \r\t\tfoldLeft: [ :a :b | Array with: a with: b ].\r\r\tself assert: parser parse: #(a) to: #a.\r\tself assert: parser parse: #(a b) to: #(a b).\r\tself assert: parser parse: #(a b c) to: #((a b) c).\r\tself assert: parser parse: #(a b c d) to: #(((a b) c) d).\r\tself assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ],		#time : DateAndTime [ '2020-01-07T02:12:41.800626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPAbstractParserTest subclass: #PPMappingTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitTests-Tests\'',				#superclassName : 'PPAbstractParserTest'			},			#name : #PPMappingTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPMappingTest class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPMappingTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPMappingTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ],		#time : DateAndTime [ '2020-01-07T02:12:41.802626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTests,				#isMetaSide : false			},			#name : #testConditionTrue,			#protocol : #'as yet unclassified',			#sourceCode : 'testConditionTrue\r\t| parser |\r\tparser := (\'a\' asParser if: [ :ctx | true ]).\r\t\r\tself assert: parser parse: \'a\'.\r\tself assert: parser fail: \'b\'.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ],		#time : DateAndTime [ '2020-01-07T02:12:41.805626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTests,				#isMetaSide : false			},			#name : #testConditionFalse,			#protocol : #'as yet unclassified',			#sourceCode : 'testConditionFalse\r\t| parser |\r\tparser := (\'a\' asParser if: [ :ctx | false ]).\r\t\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'b\'.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ],		#time : DateAndTime [ '2020-01-07T02:12:41.808626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTests,				#isMetaSide : false			},			#name : #testConditionCtxAccess,			#protocol : #'as yet unclassified',			#sourceCode : 'testConditionCtxAccess\r\t| parser |\r\r\tparser := (\'a\' asParser if: [ :ctx | (ctx propertyAt: #foo) = #bar ]).\r\t\r\tcontext propertyAt: #foo put: #bar.\r\tself assert: parser parse: \'a\' .\r\r\r\tcontext propertyAt: #foo put: #zorg.\r\tself assert: parser fail: \'a\' .\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ],		#time : DateAndTime [ '2020-01-07T02:12:41.811626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTests,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tcontext := PPContext new',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTests,				#isMetaSide : false			},			#name : #setUp,			#protocol : #'as yet unclassified',			#sourceCode : 'setUp\r\tsuper setUp.\r\tcontext := PPContext new',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ],		#time : DateAndTime [ '2020-01-07T02:12:41.811626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTests,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tcontext := PPContext new',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ],		#time : DateAndTime [ '2020-01-07T02:12:41.814626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPAbstractParserTest subclass: #PPConditionalParserTests\r\tinstanceVariableNames: \'context\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'PPAbstractParserTest'			},			#name : #PPConditionalParserTests,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPConditionalParserTests,						#isMetaSide : false					},					#name : #context,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPConditionalParserTests class\r\tinstanceVariableNames: \'\''				},				#name : #'PPConditionalParserTests class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPConditionalParserTests,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#protocol : #running	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ],		#time : DateAndTime [ '2020-01-07T02:12:41.814626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTests,				#isMetaSide : false			},			#name : #context,			#protocol : #'as yet unclassified',			#sourceCode : 'context\r\t^ context',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ],		#time : DateAndTime [ '2020-01-07T02:12:41.903626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPAbstractParserTest subclass: #PPConditionalParserTests\r\tinstanceVariableNames: \'context\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitTests-Tests\'',				#superclassName : 'PPAbstractParserTest'			},			#name : #PPConditionalParserTests,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPConditionalParserTests,						#isMetaSide : false					},					#name : #context,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPConditionalParserTests class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPConditionalParserTests class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPConditionalParserTests,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ],		#time : DateAndTime [ '2020-01-07T02:12:41.904626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTest,				#isMetaSide : false			},			#name : #testConditionTrue,			#protocol : #'as yet unclassified',			#sourceCode : 'testConditionTrue\r\t| parser |\r\tparser := (\'a\' asParser if: [ :ctx | true ]).\r\t\r\tself assert: parser parse: \'a\'.\r\tself assert: parser fail: \'b\'.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ],		#time : DateAndTime [ '2020-01-07T02:12:41.907626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTest,				#isMetaSide : false			},			#name : #testConditionFalse,			#protocol : #'as yet unclassified',			#sourceCode : 'testConditionFalse\r\t| parser |\r\tparser := (\'a\' asParser if: [ :ctx | false ]).\r\t\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'b\'.',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ],		#time : DateAndTime [ '2020-01-07T02:12:41.910626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTest,				#isMetaSide : false			},			#name : #testConditionCtxAccess,			#protocol : #'as yet unclassified',			#sourceCode : 'testConditionCtxAccess\r\t| parser |\r\r\tparser := (\'a\' asParser if: [ :ctx | (ctx propertyAt: #foo) = #bar ]).\r\t\r\tcontext propertyAt: #foo put: #bar.\r\tself assert: parser parse: \'a\' .\r\r\r\tcontext propertyAt: #foo put: #zorg.\r\tself assert: parser fail: \'a\' .\r',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ],		#time : DateAndTime [ '2020-01-07T02:12:41.913626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tcontext := PPContext new',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #'as yet unclassified',			#sourceCode : 'setUp\r\tsuper setUp.\r\tcontext := PPContext new',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ],		#time : DateAndTime [ '2020-01-07T02:12:41.914626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tcontext := PPContext new',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ],		#time : DateAndTime [ '2020-01-07T02:12:41.916626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPAbstractParserTest subclass: #PPConditionalParserTest\r\tinstanceVariableNames: \'context\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Tests\'',				#superclassName : 'PPAbstractParserTest'			},			#name : #PPConditionalParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPConditionalParserTest,						#isMetaSide : false					},					#name : #context,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPConditionalParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPConditionalParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPConditionalParserTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#protocol : #running	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ],		#time : DateAndTime [ '2020-01-07T02:12:41.917626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParserTest,				#isMetaSide : false			},			#name : #context,			#protocol : #'as yet unclassified',			#sourceCode : 'context\r\t^ context',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ],		#time : DateAndTime [ '2020-01-07T02:12:42.007626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPAbstractParserTest subclass: #PPConditionalParserTest\r\tinstanceVariableNames: \'context\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitTests-Tests\'',				#superclassName : 'PPAbstractParserTest'			},			#name : #PPConditionalParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPConditionalParserTest,						#isMetaSide : false					},					#name : #context,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPConditionalParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPConditionalParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPConditionalParserTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Tests,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ],		#time : DateAndTime [ '2020-01-07T02:12:42.009626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #context,			#protocol : #context,			#sourceCode : 'context\r\t^ PPContext new',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #context,			#protocol : #'as yet unclassified',			#sourceCode : 'context\r\t^ PPContext new',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ],		#time : DateAndTime [ '2020-01-07T02:12:42.009626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #context,			#protocol : #context,			#sourceCode : 'context\r\t^ PPContext new',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ],		#time : DateAndTime [ '2020-01-07T02:12:42.012626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #PPAbstractParserTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitTests-Core\'',				#superclassName : 'TestCase'			},			#name : #PPAbstractParserTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPAbstractParserTest class\r\tinstanceVariableNames: \'\''				},				#name : #'PPAbstractParserTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPAbstractParserTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitTests-Core,			#package : #PetitTests,			#sharedPools : OrderedCollection [ ]		},		#protocol : #context	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ],		#time : DateAndTime [ '2020-01-07T02:12:42.013626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #'assert:includesSubstring:',			#protocol : #utilities,			#sourceCode : 'assert: string1 includesSubstring: string2\r\t"Support portability by using ANSI search method"\r\r\tself assert: (string1 notEmpty and: [string2 notEmpty and: [0 < (string1 indexOfSubCollection: string2 startingAt: 1)]])',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #'assert:includesSubstring:',			#protocol : #'as yet unclassified',			#sourceCode : 'assert: string1 includesSubstring: string2\r\t"Support portability by using ANSI search method"\r\r\tself assert: (string1 notEmpty and: [string2 notEmpty and: [0 < (string1 indexOfSubCollection: string2 startingAt: 1)]])',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ],		#time : DateAndTime [ '2020-01-07T02:12:42.013626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #'assert:includesSubstring:',			#protocol : #utilities,			#sourceCode : 'assert: string1 includesSubstring: string2\r\t"Support portability by using ANSI search method"\r\r\tself assert: (string1 notEmpty and: [string2 notEmpty and: [0 < (string1 indexOfSubCollection: string2 startingAt: 1)]])',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ],		#time : DateAndTime [ '2020-01-07T02:12:42.017626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #nonMemoized,			#protocol : #operators,			#sourceCode : 'nonMemoized\r\t^ parser',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #nonMemoized,			#protocol : #'as yet unclassified',			#sourceCode : 'nonMemoized\r\t^ parser',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ],		#time : DateAndTime [ '2020-01-07T02:12:42.018626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #nonMemoized,			#protocol : #operators,			#sourceCode : 'nonMemoized\r\t^ parser',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ],		#time : DateAndTime [ '2020-01-07T02:12:42.022626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #'check:',			#protocol : #parsing,			#sourceCode : 'check: aPPContext\r\t(identifier == aPPContext identifier)\r\t\tifFalse: [ self reset: aPPContext ].',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #'check:',			#protocol : #'as yet unclassified',			#sourceCode : 'check: aPPContext\r\t(identifier == aPPContext identifier)\r\t\tifFalse: [ self reset: aPPContext ].',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ],		#time : DateAndTime [ '2020-01-07T02:12:42.022626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #'check:',			#protocol : #parsing,			#sourceCode : 'check: aPPContext\r\t(identifier == aPPContext identifier)\r\t\tifFalse: [ self reset: aPPContext ].',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ],		#time : DateAndTime [ '2020-01-07T02:12:42.027626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Interval,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser    \r\t"Create a range of characters between start and stop."\r\r    self assert:start isCharacter.\r    self assert:stop isCharacter.\r    self assert:step == 1.\r    ^ PPPredicateObjectParser between: start and: stop\r\r    "\r\t\t($a to: $f) asParser parse: \'a\'\r\t\t($a to: $f) asParser parse: \'g\'\r    "',			#stamp : '',			#package : #Collections-Sequenceable		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Interval,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'as yet unclassified',			#sourceCode : 'asParser    \r\t"Create a range of characters between start and stop."\r\r    self assert:start isCharacter.\r    self assert:stop isCharacter.\r    self assert:step == 1.\r    ^ PPPredicateObjectParser between: start and: stop\r\r    "\r\t\t($a to: $f) asParser parse: \'a\'\r\t\t($a to: $f) asParser parse: \'g\'\r    "',			#stamp : '',			#package : #Collections-Sequenceable		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ],		#time : DateAndTime [ '2020-01-07T02:12:42.028626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Interval,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser    \r\t"Create a range of characters between start and stop."\r\r    self assert:start isCharacter.\r    self assert:stop isCharacter.\r    self assert:step == 1.\r    ^ PPPredicateObjectParser between: start and: stop\r\r    "\r\t\t($a to: $f) asParser parse: \'a\'\r\t\t($a to: $f) asParser parse: \'g\'\r    "',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ],		#time : DateAndTime [ '2020-01-07T02:12:42.031626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'SequenceableCollection subclass: #Interval\r\tinstanceVariableNames: \'start stop step\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'Collections-Sequenceable-Base\'',				#superclassName : 'SequenceableCollection'			},			#name : #Interval,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Interval,						#isMetaSide : false					},					#name : #start,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Interval,						#isMetaSide : false					},					#name : #stop,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Interval,						#isMetaSide : false					},					#name : #step,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Interval class\r\tinstanceVariableNames: \'\''				},				#name : #'Interval class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Interval,					#isMetaSide : false				},				#parent : @8,				#content : 'I represent a finite arithmetic progression (a range of number).\r\rDescription\r--------------------------\r\rI allow to iterate easily on a range of number (for example to manupulate an index) with a define step (by default one by one).\r\rZero step size is not allowed and will raise an error.\r\rI know at which number I begin, at which number I end and the step.\r\rI work with the Number class. I manipulate some numbers and I can be created from a Number.  \r\rPublic API and Key Messages\r--------------------------\r\r- I implement most of the classic Iterators as #do: or #collect:.\r\r- #from: to: and #from: to: by:  are my two common contructors. But I am usually created by a message send on Number  (See examples).\r\rExamples \r--------------------------\r\rTo create an Interval from 1 to 100 there is many ways:\r\r\tInterval from: 1 to: 100\r\tor\r\tInterval from: 1 to: 100 by: 1\r\t\r\tor from a Number \r\t\r\t1 to: 100 \r\tor \r\t1 to: 100 by: 1\r\t\r\tYou can also use floats or fractions: \r\t\r\t0.1 to: 0.5 by: 0.01\r\tor\r\t1/10 to: 1/2 by: 1/100\r\t\r\tNB: both expressions will not give exactly the same result. The first will contains only floats and the second only fractions.\r\t\r \rInternal Representation and Key Implementation Points.\r--------------------------\r\r    Instance Variables\r\tstart:\t\t<Number> \tThe beginning of the Interval.\r\tstep:\t\t<Number> \tThe end of the Interval.\r\tstop:\t\t<Number> \tThe step of the interval. If the step is 3 and we begin at 1 the interval will be 1, 4, 7, 10, 13 until the end.\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #Collections-Sequenceable-Base,			#package : #Collections-Sequenceable,			#sharedPools : OrderedCollection [ ]		},		#protocol : #'*PetitParser'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ],		#time : DateAndTime [ '2020-01-07T02:12:42.032626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStartOfWordParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'parseOn: aPPContext\r\taPPContext atEnd ifTrue: [  \r\t\t^ PPFailure message: \'Start of word expected\' context: aPPContext at: aPPContext position \r\t].\r\r\t(aPPContext position == 0) ifTrue: [ \r\t\t(aPPContext peek isAlphaNumeric) ifTrue: [ \r\t\t\t^ #startOfWord\r\t\t] ifFalse: [ \r\t\t\t^ PPFailure message: \'Start of word expected\' context: aPPContext at: aPPContext position \r\t \t]\r\t].\r\r\taPPContext back.\r\taPPContext peek isAlphaNumeric ifTrue: [\r\t\t^ PPFailure message: \'Start of word expected\' context: aPPContext at: aPPContext position \r\t].\r\taPPContext next.\r\t\r\t^ aPPContext peek isAlphaNumeric ifTrue: [ #startOfWord ] ifFalse: [ \r\t\tPPFailure message: \'Start of word expected\' context: aPPContext at: aPPContext position \r\t]\r\t\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ],		#time : DateAndTime [ '2020-01-07T02:12:42.034626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStartOfWordParser,				#isMetaSide : false			},			#name : #acceptsEpsilon,			#protocol : #'as yet unclassified',			#sourceCode : 'acceptsEpsilon\r\t^ false',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ],		#time : DateAndTime [ '2020-01-07T02:12:42.108626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPStartOfWordParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPStartOfWordParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPStartOfWordParser class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPStartOfWordParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPStartOfWordParser,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ],		#time : DateAndTime [ '2020-01-07T02:12:42.109626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStartOfLogicalLineParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'parseOn: aPPContext\r\taPPContext peek isAlphaNumeric ifFalse: [ \r\t\t^ PPFailure message: \'Start of logical line expected\' context: aPPContext \r\t].\r\r\taPPContext isStartOfLine ifTrue: [ ^ #startOfLogicalLine ].\r\t\r\t\r\t[ aPPContext position ~= 0 ] whileTrue: [  \r\t\taPPContext back.\r\t\t(self isBlank: aPPContext peek) ifFalse: [ \r\t\t\t^ PPFailure message: \'Start of logical line expected\' context: aPPContext\r\t\t].\r\t\taPPContext isStartOfLine ifTrue: [ ^ #startOfLogicalLine ].\r\t]\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ],		#time : DateAndTime [ '2020-01-07T02:12:42.112626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStartOfLogicalLineParser,				#isMetaSide : false			},			#name : #'isBlank:',			#protocol : #'as yet unclassified',			#sourceCode : 'isBlank: character\r\t^ (character == Character space or: [character == Character tab])\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ],		#time : DateAndTime [ '2020-01-07T02:12:42.181626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPStartOfLogicalLineParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPStartOfLogicalLineParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPStartOfLogicalLineParser class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPStartOfLogicalLineParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPStartOfLogicalLineParser,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ],		#time : DateAndTime [ '2020-01-07T02:12:42.183626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStartOfLineParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t(aPPContext isStartOfLine) ifTrue: [ \r\t\t^ #startOfLine\r\t].\r\t^ PPFailure message: \'Start of line expected\' context: aPPContext at: aPPContext position',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStartOfLineParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'parseOn: aPPContext\r\t(aPPContext isStartOfLine) ifTrue: [ \r\t\t^ #startOfLine\r\t].\r\t^ PPFailure message: \'Start of line expected\' context: aPPContext at: aPPContext position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ],		#time : DateAndTime [ '2020-01-07T02:12:42.183626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStartOfLineParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t(aPPContext isStartOfLine) ifTrue: [ \r\t\t^ #startOfLine\r\t].\r\t^ PPFailure message: \'Start of line expected\' context: aPPContext at: aPPContext position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ],		#time : DateAndTime [ '2020-01-07T02:12:42.185626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPStartOfLineParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPStartOfLineParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPStartOfLineParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPStartOfLineParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPStartOfLineParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPStartOfLineParser is that does not fail, if the stream position is at the beginning of a line. It does not consume anything.\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #parsing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ],		#time : DateAndTime [ '2020-01-07T02:12:42.251626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPStartOfLineParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPStartOfLineParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPStartOfLineParser class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPStartOfLineParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPStartOfLineParser,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ],		#time : DateAndTime [ '2020-01-07T02:12:42.253626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimSpacesRight,			#protocol : #operators-mapping,			#sourceCode : 'trimSpacesRight\r\t"Answer a new parser that consumes spaces after the receiving parser."\r\t\r\t^ (self, #space asParser star) ==> #first',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimSpacesRight,			#protocol : #'as yet unclassified',			#sourceCode : 'trimSpacesRight\r\t"Answer a new parser that consumes spaces after the receiving parser."\r\t\r\t^ (self, #space asParser star) ==> #first',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ],		#time : DateAndTime [ '2020-01-07T02:12:42.253626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimSpacesRight,			#protocol : #operators-mapping,			#sourceCode : 'trimSpacesRight\r\t"Answer a new parser that consumes spaces after the receiving parser."\r\t\r\t^ (self, #space asParser star) ==> #first',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ],		#time : DateAndTime [ '2020-01-07T02:12:42.256626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimSpacesLeft,			#protocol : #operators-mapping,			#sourceCode : 'trimSpacesLeft\r\t"Answer a new parser that consumes spaces before the receiving parser."\r\t\r\t^ (#space asParser star, self) ==> #second',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimSpacesLeft,			#protocol : #'as yet unclassified',			#sourceCode : 'trimSpacesLeft\r\t"Answer a new parser that consumes spaces before the receiving parser."\r\t\r\t^ (#space asParser star, self) ==> #second',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ],		#time : DateAndTime [ '2020-01-07T02:12:42.256626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimSpacesLeft,			#protocol : #operators-mapping,			#sourceCode : 'trimSpacesLeft\r\t"Answer a new parser that consumes spaces before the receiving parser."\r\t\r\t^ (#space asParser star, self) ==> #second',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ],		#time : DateAndTime [ '2020-01-07T02:12:42.259626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'trimRight:',			#protocol : #operators-mapping,			#sourceCode : 'trimRight: trimmer\r\t"Answer a new parser that consumes spaces after the receiving parser."\r\t\r\t^ (self, trimmer star) ==> #first',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'trimRight:',			#protocol : #'as yet unclassified',			#sourceCode : 'trimRight: trimmer\r\t"Answer a new parser that consumes spaces after the receiving parser."\r\t\r\t^ (self, trimmer star) ==> #first',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ],		#time : DateAndTime [ '2020-01-07T02:12:42.259626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'trimRight:',			#protocol : #operators-mapping,			#sourceCode : 'trimRight: trimmer\r\t"Answer a new parser that consumes spaces after the receiving parser."\r\t\r\t^ (self, trimmer star) ==> #first',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ],		#time : DateAndTime [ '2020-01-07T02:12:42.262626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimRight,			#protocol : #operators-mapping,			#sourceCode : 'trimRight\r\t"Answer a new parser that consumes spaces after the receiving parser."\r\t\r\t^ self trimSpacesRight',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimRight,			#protocol : #'as yet unclassified',			#sourceCode : 'trimRight\r\t"Answer a new parser that consumes spaces after the receiving parser."\r\t\r\t^ self trimSpacesRight',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ],		#time : DateAndTime [ '2020-01-07T02:12:42.262626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimRight,			#protocol : #operators-mapping,			#sourceCode : 'trimRight\r\t"Answer a new parser that consumes spaces after the receiving parser."\r\t\r\t^ self trimSpacesRight',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ],		#time : DateAndTime [ '2020-01-07T02:12:42.265626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimLeft,			#protocol : #operators-mapping,			#sourceCode : 'trimLeft\r\t"Answer a new parser that consumes spaces before the receiving parser."\r\t\r\t^ self trimSpacesLeft',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimLeft,			#protocol : #'as yet unclassified',			#sourceCode : 'trimLeft\r\t"Answer a new parser that consumes spaces before the receiving parser."\r\t\r\t^ self trimSpacesLeft',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ],		#time : DateAndTime [ '2020-01-07T02:12:42.266626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #trimLeft,			#protocol : #operators-mapping,			#sourceCode : 'trimLeft\r\t"Answer a new parser that consumes spaces before the receiving parser."\r\t\r\t^ self trimSpacesLeft',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ],		#time : DateAndTime [ '2020-01-07T02:12:42.268626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #properties,			#protocol : #accessing-properties,			#sourceCode : 'properties\r\t^ properties',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #properties,			#protocol : #'as yet unclassified',			#sourceCode : 'properties\r\t^ properties',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ],		#time : DateAndTime [ '2020-01-07T02:12:42.269626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #properties,			#protocol : #accessing-properties,			#sourceCode : 'properties\r\t^ properties',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ],		#time : DateAndTime [ '2020-01-07T02:12:42.271626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parseWithContext:',			#protocol : #context,			#sourceCode : 'parseWithContext: context\r\t| result |\r\tcontext initializeFor: self.\r\tresult := self parseOn: context.\r\t\r\t"Return the furthest failure, it gives better results than the last failure"\r\t(result isPetitFailure and: [ context furthestFailure notNil]) \r\t\tifTrue: [ ^ context furthestFailure ].\r\t^ result\r\t',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parseWithContext:',			#protocol : #'as yet unclassified',			#sourceCode : 'parseWithContext: context\r\t| result |\r\tcontext initializeFor: self.\r\tresult := self parseOn: context.\r\t\r\t"Return the furthest failure, it gives better results than the last failure"\r\t(result isPetitFailure and: [ context furthestFailure notNil]) \r\t\tifTrue: [ ^ context furthestFailure ].\r\t^ result\r\t',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ],		#time : DateAndTime [ '2020-01-07T02:12:42.272626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parseWithContext:',			#protocol : #context,			#sourceCode : 'parseWithContext: context\r\t| result |\r\tcontext initializeFor: self.\r\tresult := self parseOn: context.\r\t\r\t"Return the furthest failure, it gives better results than the last failure"\r\t(result isPetitFailure and: [ context furthestFailure notNil]) \r\t\tifTrue: [ ^ context furthestFailure ].\r\t^ result\r\t',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ],		#time : DateAndTime [ '2020-01-07T02:12:42.275626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parse:withContext:',			#protocol : #context,			#sourceCode : 'parse: anObject withContext: aPPContext\r\t"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."\r\r\taPPContext stream: anObject asPetitStream.\r\t^ self parseWithContext: aPPContext.\r',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parse:withContext:',			#protocol : #'as yet unclassified',			#sourceCode : 'parse: anObject withContext: aPPContext\r\t"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."\r\r\taPPContext stream: anObject asPetitStream.\r\t^ self parseWithContext: aPPContext.\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ],		#time : DateAndTime [ '2020-01-07T02:12:42.275626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parse:withContext:',			#protocol : #context,			#sourceCode : 'parse: anObject withContext: aPPContext\r\t"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."\r\r\taPPContext stream: anObject asPetitStream.\r\t^ self parseWithContext: aPPContext.\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ],		#time : DateAndTime [ '2020-01-07T02:12:42.277626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPParser\r\tinstanceVariableNames: \'properties\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'Object'			},			#name : #PPParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPParser,						#isMetaSide : false					},					#name : #properties,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPParser,					#isMetaSide : false				},				#parent : @8,				#content : 'An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.\r\rInstance Variables:\r\tproperties\t<Dictionary>\tStores additional state in the parser object.',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #context	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ],		#time : DateAndTime [ '2020-01-07T02:12:42.278626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #nonMemoized,			#protocol : #operators,			#sourceCode : 'nonMemoized\r\t^ self',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #nonMemoized,			#protocol : #'as yet unclassified',			#sourceCode : 'nonMemoized\r\t^ self',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ],		#time : DateAndTime [ '2020-01-07T02:12:42.279626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #nonMemoized,			#protocol : #operators,			#sourceCode : 'nonMemoized\r\t^ self',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ],		#time : DateAndTime [ '2020-01-07T02:12:42.282626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'if:',			#protocol : #operators,			#sourceCode : 'if: aBlock\r\t^ PPConditionalParser on: self block: aBlock',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'if:',			#protocol : #'as yet unclassified',			#sourceCode : 'if: aBlock\r\t^ PPConditionalParser on: self block: aBlock',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ],		#time : DateAndTime [ '2020-01-07T02:12:42.282626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'if:',			#protocol : #operators,			#sourceCode : 'if: aBlock\r\t^ PPConditionalParser on: self block: aBlock',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ],		#time : DateAndTime [ '2020-01-07T02:12:42.285626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #child,			#protocol : #accessing,			#sourceCode : 'child\r\tself assert: (self children size == 1).\r\t^ self children first',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #child,			#protocol : #'as yet unclassified',			#sourceCode : 'child\r\tself assert: (self children size == 1).\r\t^ self children first',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '172' ],		#self : OmReference [ '173' ],		#time : DateAndTime [ '2020-01-07T02:12:42.285626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #child,			#protocol : #accessing,			#sourceCode : 'child\r\tself assert: (self children size == 1).\r\t^ self children first',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '173' ],		#self : OmReference [ '174' ],		#time : DateAndTime [ '2020-01-07T02:12:42.288626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'allParsersDo:seen:',			#protocol : #enumerating,			#sourceCode : 'allParsersDo: aBlock seen: aSet\r\t"Iterate over all the parse nodes of the receiver, do not visit and follow the ones contained in aSet."\r\r\t(aSet includes: self)\r\t\tifTrue: [ ^ self ].\r\taSet add: self.\r\taBlock value: self.\r\tself children\r\t\tdo: [ :each | each allParsersDo: aBlock seen: aSet ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'allParsersDo:seen:',			#protocol : #'as yet unclassified',			#sourceCode : 'allParsersDo: aBlock seen: aSet\r\t"Iterate over all the parse nodes of the receiver, do not visit and follow the ones contained in aSet."\r\r\t(aSet includes: self)\r\t\tifTrue: [ ^ self ].\r\taSet add: self.\r\taBlock value: self.\r\tself children\r\t\tdo: [ :each | each allParsersDo: aBlock seen: aSet ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '174' ],		#self : OmReference [ '175' ],		#time : DateAndTime [ '2020-01-07T02:12:42.289626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'allParsersDo:seen:',			#protocol : #enumerating,			#sourceCode : 'allParsersDo: aBlock seen: aSet\r\t"Iterate over all the parse nodes of the receiver, do not visit and follow the ones contained in aSet."\r\r\t(aSet includes: self)\r\t\tifTrue: [ ^ self ].\r\taSet add: self.\r\taBlock value: self.\r\tself children\r\t\tdo: [ :each | each allParsersDo: aBlock seen: aSet ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '175' ],		#self : OmReference [ '176' ],		#time : DateAndTime [ '2020-01-07T02:12:42.292626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'allParsersDo:',			#protocol : #enumerating,			#sourceCode : 'allParsersDo: aBlock\r\t"Iterate over all the parse nodes of the receiver."\r\r\tself allParsersDo: aBlock seen: IdentitySet new',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'allParsersDo:',			#protocol : #'as yet unclassified',			#sourceCode : 'allParsersDo: aBlock\r\t"Iterate over all the parse nodes of the receiver."\r\r\tself allParsersDo: aBlock seen: IdentitySet new',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '176' ],		#self : OmReference [ '177' ],		#time : DateAndTime [ '2020-01-07T02:12:42.292626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'allParsersDo:',			#protocol : #enumerating,			#sourceCode : 'allParsersDo: aBlock\r\t"Iterate over all the parse nodes of the receiver."\r\r\tself allParsersDo: aBlock seen: IdentitySet new',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '177' ],		#self : OmReference [ '178' ],		#time : DateAndTime [ '2020-01-07T02:12:42.295626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #allParsers,			#protocol : #enumerating,			#sourceCode : 'allParsers\r\t"Answer all the parse nodes of the receiver."\r\r\t| result |\r\tresult := OrderedCollection new.\r\tself allParsersDo: [ :parser | result addLast: parser ].\r\t^ result',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #allParsers,			#protocol : #'as yet unclassified',			#sourceCode : 'allParsers\r\t"Answer all the parse nodes of the receiver."\r\r\t| result |\r\tresult := OrderedCollection new.\r\tself allParsersDo: [ :parser | result addLast: parser ].\r\t^ result',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '178' ],		#self : OmReference [ '179' ],		#time : DateAndTime [ '2020-01-07T02:12:42.295626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #allParsers,			#protocol : #enumerating,			#sourceCode : 'allParsers\r\t"Answer all the parse nodes of the receiver."\r\r\t| result |\r\tresult := OrderedCollection new.\r\tself allParsersDo: [ :parser | result addLast: parser ].\r\t^ result',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '179' ],		#self : OmReference [ '180' ],		#time : DateAndTime [ '2020-01-07T02:12:42.297626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPParser\r\tinstanceVariableNames: \'properties\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'Object'			},			#name : #PPParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPParser,						#isMetaSide : false					},					#name : #properties,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPParser,					#isMetaSide : false				},				#parent : @8,				#content : 'An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.\r\rInstance Variables:\r\tproperties\t<Dictionary>\tStores additional state in the parser object.',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #enumerating	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '180' ],		#self : OmReference [ '181' ],		#time : DateAndTime [ '2020-01-07T02:12:42.299626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #//,			#protocol : #operators,			#sourceCode : '// aParser \r\t"\r\t\tAnswer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice).\r\t\tIf the receiver passes, limit must pass as well.\r\t"\r\t\r\t^ PPLimitedChoiceParser with: self with: aParser',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #//,			#protocol : #'as yet unclassified',			#sourceCode : '// aParser \r\t"\r\t\tAnswer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice).\r\t\tIf the receiver passes, limit must pass as well.\r\t"\r\t\r\t^ PPLimitedChoiceParser with: self with: aParser',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '181' ],		#self : OmReference [ '182' ],		#time : DateAndTime [ '2020-01-07T02:12:42.299626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #//,			#protocol : #operators,			#sourceCode : '// aParser \r\t"\r\t\tAnswer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice).\r\t\tIf the receiver passes, limit must pass as well.\r\t"\r\t\r\t^ PPLimitedChoiceParser with: self with: aParser',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '182' ],		#self : OmReference [ '183' ],		#time : DateAndTime [ '2020-01-07T02:12:42.302626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPEndOfLineParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t(aPPContext isEndOfLine) ifTrue: [ \r\t\t^ #endOfLine\r\t].\r\t^ PPFailure message: \'End of line expected\' context: aPPContext at: aPPContext position',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPEndOfLineParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'parseOn: aPPContext\r\t(aPPContext isEndOfLine) ifTrue: [ \r\t\t^ #endOfLine\r\t].\r\t^ PPFailure message: \'End of line expected\' context: aPPContext at: aPPContext position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '183' ],		#self : OmReference [ '184' ],		#time : DateAndTime [ '2020-01-07T02:12:42.303626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPEndOfLineParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t(aPPContext isEndOfLine) ifTrue: [ \r\t\t^ #endOfLine\r\t].\r\t^ PPFailure message: \'End of line expected\' context: aPPContext at: aPPContext position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '184' ],		#self : OmReference [ '185' ],		#time : DateAndTime [ '2020-01-07T02:12:42.305626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPEndOfLineParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPEndOfLineParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPEndOfLineParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPEndOfLineParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPEndOfLineParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPEndOfLineParser is a parser that does not fail, if the stream position is at the end of a line. It does not consume anything.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #parsing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '185' ],		#self : OmReference [ '186' ],		#time : DateAndTime [ '2020-01-07T02:12:42.371626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPEndOfLineParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPEndOfLineParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPEndOfLineParser class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPEndOfLineParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPEndOfLineParser,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '186' ],		#self : OmReference [ '187' ],		#time : DateAndTime [ '2020-01-07T02:12:42.373626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPEndOfFileParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t(aPPContext atEnd) ifFalse:\r\t[\r\t\t^ PPFailure message: \'end of input expected\' context: aPPContext.\r\t].\r\t^ #\'end-of-input\'',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPEndOfFileParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'parseOn: aPPContext\r\t(aPPContext atEnd) ifFalse:\r\t[\r\t\t^ PPFailure message: \'end of input expected\' context: aPPContext.\r\t].\r\t^ #\'end-of-input\'',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '187' ],		#self : OmReference [ '188' ],		#time : DateAndTime [ '2020-01-07T02:12:42.374626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPEndOfFileParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t(aPPContext atEnd) ifFalse:\r\t[\r\t\t^ PPFailure message: \'end of input expected\' context: aPPContext.\r\t].\r\t^ #\'end-of-input\'',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '188' ],		#self : OmReference [ '189' ],		#time : DateAndTime [ '2020-01-07T02:12:42.376626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPEndOfFileParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPEndOfFileParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPEndOfFileParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPEndOfFileParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPEndOfFileParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPEndOfFileParser is parser that will will return true if the stream position is at the end, returns failure otherwise.\r\rThe diffirenece between PPEndOfFIleParser and PPEndOfInputParser is:\r - PPEndOfFileParser can be created using #eof asParser\r - PPEndOfInputParser can be created by using parser end\r - PPEndOfFileParser does not delegate to any other parser\r - PPEndOfInputParser parsers its delegate and then decides if the input is at the end.\r\rThe PPEndOfFileParser can be used to accept some input only if it is at the end of the input, e.g:\r\r   (\'a\' asParser, #eof asParser) parse: \'a\'\r   (\'a\' asParser, #eof asParser) parse: \'aa\'\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #parsing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '189' ],		#self : OmReference [ '190' ],		#time : DateAndTime [ '2020-01-07T02:12:42.441626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPParser subclass: #PPEndOfFileParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitParser-Parsers\'',				#superclassName : 'PPParser'			},			#name : #PPEndOfFileParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPEndOfFileParser class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPEndOfFileParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPEndOfFileParser,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '190' ],		#self : OmReference [ '191' ],		#time : DateAndTime [ '2020-01-07T02:12:42.443626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'parse:rule:to:end:',			#protocol : #parsing,			#sourceCode : 'parse: aString rule: aSymbol to: expectedResult end: end\r\t| production context |\r\tproduction := self parserInstanceFor: aSymbol.\r\tcontext := self context.\r\t\r\tresult := production parse: aString withContext: context.\r\tself\r\t\tdeny: result isPetitFailure\r\t\tdescription: \'Unable to parse \' , aString printString.\r\t\r\tself assert: expectedResult = result.\r\tself assert: context position = end.\r\t^ result',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'parse:rule:to:end:',			#protocol : #'as yet unclassified',			#sourceCode : 'parse: aString rule: aSymbol to: expectedResult end: end\r\t| production context |\r\tproduction := self parserInstanceFor: aSymbol.\r\tcontext := self context.\r\t\r\tresult := production parse: aString withContext: context.\r\tself\r\t\tdeny: result isPetitFailure\r\t\tdescription: \'Unable to parse \' , aString printString.\r\t\r\tself assert: expectedResult = result.\r\tself assert: context position = end.\r\t^ result',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '191' ],		#self : OmReference [ '192' ],		#time : DateAndTime [ '2020-01-07T02:12:42.443626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'parse:rule:to:end:',			#protocol : #parsing,			#sourceCode : 'parse: aString rule: aSymbol to: expectedResult end: end\r\t| production context |\r\tproduction := self parserInstanceFor: aSymbol.\r\tcontext := self context.\r\t\r\tresult := production parse: aString withContext: context.\r\tself\r\t\tdeny: result isPetitFailure\r\t\tdescription: \'Unable to parse \' , aString printString.\r\t\r\tself assert: expectedResult = result.\r\tself assert: context position = end.\r\t^ result',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '192' ],		#self : OmReference [ '193' ],		#time : DateAndTime [ '2020-01-07T02:12:42.447626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'debug:rule:',			#protocol : #parsing,			#sourceCode : 'debug: aString rule: aSymbol\r\t| production context |\r\tproduction := self parserInstanceFor: aSymbol.\r\tcontext := self context.\r\t\r\tdebugResult := production end enableDebug parse: aString withContext: context.\r\tresult := debugResult children first result.\r\t\r\tself\r\t\tdeny: result isPetitFailure\r\t\tdescription: \'Unable to parse \' , aString printString.\t\r\t\r\t^ debugResult',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'debug:rule:',			#protocol : #'as yet unclassified',			#sourceCode : 'debug: aString rule: aSymbol\r\t| production context |\r\tproduction := self parserInstanceFor: aSymbol.\r\tcontext := self context.\r\t\r\tdebugResult := production end enableDebug parse: aString withContext: context.\r\tresult := debugResult children first result.\r\t\r\tself\r\t\tdeny: result isPetitFailure\r\t\tdescription: \'Unable to parse \' , aString printString.\t\r\t\r\t^ debugResult',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '193' ],		#self : OmReference [ '194' ],		#time : DateAndTime [ '2020-01-07T02:12:42.447626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'debug:rule:',			#protocol : #parsing,			#sourceCode : 'debug: aString rule: aSymbol\r\t| production context |\r\tproduction := self parserInstanceFor: aSymbol.\r\tcontext := self context.\r\t\r\tdebugResult := production end enableDebug parse: aString withContext: context.\r\tresult := debugResult children first result.\r\t\r\tself\r\t\tdeny: result isPetitFailure\r\t\tdescription: \'Unable to parse \' , aString printString.\t\r\t\r\t^ debugResult',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '194' ],		#self : OmReference [ '195' ],		#time : DateAndTime [ '2020-01-07T02:12:42.451626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'debug:',			#protocol : #parsing,			#sourceCode : 'debug: aString \r\t^ self debug: aString rule: #start',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'debug:',			#protocol : #'as yet unclassified',			#sourceCode : 'debug: aString \r\t^ self debug: aString rule: #start',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '195' ],		#self : OmReference [ '196' ],		#time : DateAndTime [ '2020-01-07T02:12:42.451626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'debug:',			#protocol : #parsing,			#sourceCode : 'debug: aString \r\t^ self debug: aString rule: #start',			#stamp : '',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '196' ],		#self : OmReference [ '197' ],		#time : DateAndTime [ '2020-01-07T02:12:42.455626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t^ (block value: aPPContext) \r\t\tifTrue: [ parser parseOn: aPPContext ]\r\t\tifFalse: [ PPFailure message: block asString, \' was not evaluated to true.\' context: aPPContext ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'parseOn: aPPContext\r\t^ (block value: aPPContext) \r\t\tifTrue: [ parser parseOn: aPPContext ]\r\t\tifFalse: [ PPFailure message: block asString, \' was not evaluated to true.\' context: aPPContext ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '197' ],		#self : OmReference [ '198' ],		#time : DateAndTime [ '2020-01-07T02:12:42.455626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t^ (block value: aPPContext) \r\t\tifTrue: [ parser parseOn: aPPContext ]\r\t\tifFalse: [ PPFailure message: block asString, \' was not evaluated to true.\' context: aPPContext ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '198' ],		#self : OmReference [ '199' ],		#time : DateAndTime [ '2020-01-07T02:12:42.457626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPDelegateParser subclass: #PPConditionalParser\r\tinstanceVariableNames: \'block\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPDelegateParser'			},			#name : #PPConditionalParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPConditionalParser,						#isMetaSide : false					},					#name : #block,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPConditionalParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPConditionalParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPConditionalParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPConditionalParser is a delegate parser that evaluates a block and if that returns true, the delegate parser is invoked and its result returned. If the block evaluates to false, the PPFailure is returned.\r\rThe block accepts one argument, context.\r\rE.g.\r    (\'a\' asParser if: [ :ctx | (ctx propertyAt: #myProperty) isNotNil ]) parse: \'a\'',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #parsing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '199' ],		#self : OmReference [ '200' ],		#time : DateAndTime [ '2020-01-07T02:12:42.458626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParser,				#isMetaSide : false			},			#name : #'block:',			#protocol : #accessing,			#sourceCode : 'block: aBlock\r\tblock := aBlock',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParser,				#isMetaSide : false			},			#name : #'block:',			#protocol : #'as yet unclassified',			#sourceCode : 'block: aBlock\r\tblock := aBlock',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '200' ],		#self : OmReference [ '201' ],		#time : DateAndTime [ '2020-01-07T02:12:42.459626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPConditionalParser,				#isMetaSide : false			},			#name : #'block:',			#protocol : #accessing,			#sourceCode : 'block: aBlock\r\tblock := aBlock',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '201' ],		#self : OmReference [ '202' ],		#time : DateAndTime [ '2020-01-07T02:12:42.461626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPDelegateParser subclass: #PPConditionalParser\r\tinstanceVariableNames: \'block\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',				#superclassName : 'PPDelegateParser'			},			#name : #PPConditionalParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPConditionalParser,						#isMetaSide : false					},					#name : #block,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPConditionalParser class\r\tinstanceVariableNames: \'\''				},				#name : #'PPConditionalParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPConditionalParser,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPConditionalParser is a delegate parser that evaluates a block and if that returns true, the delegate parser is invoked and its result returned. If the block evaluates to false, the PPFailure is returned.\r\rThe block accepts one argument, context.\r\rE.g.\r    (\'a\' asParser if: [ :ctx | (ctx propertyAt: #myProperty) isNotNil ]) parse: \'a\'',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #accessing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '202' ],		#self : OmReference [ '203' ],		#time : DateAndTime [ '2020-01-07T02:12:42.461626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPConditionalParser class',				#isMetaSide : true			},			#name : #'on:block:',			#protocol : #'as yet unclassified',			#sourceCode : 'on: aPPParser block: block\r\t^ (PPConditionalParser on: aPPParser)\r\t\tblock: block;\r\t\tyourself',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '203' ],		#self : OmReference [ '204' ],		#time : DateAndTime [ '2020-01-07T02:12:42.550626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPDelegateParser subclass: #PPConditionalParser\r\tinstanceVariableNames: \'block\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitParser-Parsers\'',				#superclassName : 'PPDelegateParser'			},			#name : #PPConditionalParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPConditionalParser,						#isMetaSide : false					},					#name : #block,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPConditionalParser class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPConditionalParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPConditionalParser,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Parsers,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '204' ],		#self : OmReference [ '205' ],		#time : DateAndTime [ '2020-01-07T02:12:42.552626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r\t"\r\t\tThe same implementation as a ReadStream. Implemented here for compatibility with Smalltalk/X\r\t\tthat has different implementation in a ReadStream\r\t"\r\t^readLimit',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #size,			#protocol : #'as yet unclassified',			#sourceCode : 'size\r\t"\r\t\tThe same implementation as a ReadStream. Implemented here for compatibility with Smalltalk/X\r\t\tthat has different implementation in a ReadStream\r\t"\r\t^readLimit',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '205' ],		#self : OmReference [ '206' ],		#time : DateAndTime [ '2020-01-07T02:12:42.552626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r\t"\r\t\tThe same implementation as a ReadStream. Implemented here for compatibility with Smalltalk/X\r\t\tthat has different implementation in a ReadStream\r\t"\r\t^readLimit',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '206' ],		#self : OmReference [ '207' ],		#time : DateAndTime [ '2020-01-07T02:12:42.556626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #'next:',			#protocol : #accessing,			#sourceCode : 'next: anInteger \r\t"Answer up to anInteger elements of my collection. Overridden for efficiency."\r\r\t| answer endPosition |\r\tendPosition := position + anInteger min: readLimit.\r\tanswer := collection copyFrom: position + 1 to: endPosition.\r\tposition := endPosition.\r\t^ answer',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #'next:',			#protocol : #'as yet unclassified',			#sourceCode : 'next: anInteger \r\t"Answer up to anInteger elements of my collection. Overridden for efficiency."\r\r\t| answer endPosition |\r\tendPosition := position + anInteger min: readLimit.\r\tanswer := collection copyFrom: position + 1 to: endPosition.\r\tposition := endPosition.\r\t^ answer',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '207' ],		#self : OmReference [ '208' ],		#time : DateAndTime [ '2020-01-07T02:12:42.557626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #'next:',			#protocol : #accessing,			#sourceCode : 'next: anInteger \r\t"Answer up to anInteger elements of my collection. Overridden for efficiency."\r\r\t| answer endPosition |\r\tendPosition := position + anInteger min: readLimit.\r\tanswer := collection copyFrom: position + 1 to: endPosition.\r\tposition := endPosition.\r\t^ answer',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '208' ],		#self : OmReference [ '209' ],		#time : DateAndTime [ '2020-01-07T02:12:42.560626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #newlines,			#protocol : #positioning,			#sourceCode : 'newlines\r\t^ newlines ifNil: [ \r\t\tnewlines := self fillNewlines.\r\t]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #newlines,			#protocol : #'as yet unclassified',			#sourceCode : 'newlines\r\t^ newlines ifNil: [ \r\t\tnewlines := self fillNewlines.\r\t]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '209' ],		#self : OmReference [ '210' ],		#time : DateAndTime [ '2020-01-07T02:12:42.560626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #newlines,			#protocol : #positioning,			#sourceCode : 'newlines\r\t^ newlines ifNil: [ \r\t\tnewlines := self fillNewlines.\r\t]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '210' ],		#self : OmReference [ '211' ],		#time : DateAndTime [ '2020-01-07T02:12:42.564626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #'line:',			#protocol : #positioning,			#sourceCode : 'line: pos\r\t| nl |\r\t(pos = -1) ifTrue: [  ^ 0 ].\r\t(pos > readLimit) ifTrue: [ ^ self error: \'Out of limit\' ].\r\t\r\tnl := self newlines.\r\tnl keysAndValuesDo: [ :index :value |\r\t\t(value > pos) ifTrue: [ ^ (index - 1)]\r\t].\t\r\r\t^ nl size',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #'line:',			#protocol : #'as yet unclassified',			#sourceCode : 'line: pos\r\t| nl |\r\t(pos = -1) ifTrue: [  ^ 0 ].\r\t(pos > readLimit) ifTrue: [ ^ self error: \'Out of limit\' ].\r\t\r\tnl := self newlines.\r\tnl keysAndValuesDo: [ :index :value |\r\t\t(value > pos) ifTrue: [ ^ (index - 1)]\r\t].\t\r\r\t^ nl size',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '211' ],		#self : OmReference [ '212' ],		#time : DateAndTime [ '2020-01-07T02:12:42.564626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #'line:',			#protocol : #positioning,			#sourceCode : 'line: pos\r\t| nl |\r\t(pos = -1) ifTrue: [  ^ 0 ].\r\t(pos > readLimit) ifTrue: [ ^ self error: \'Out of limit\' ].\r\t\r\tnl := self newlines.\r\tnl keysAndValuesDo: [ :index :value |\r\t\t(value > pos) ifTrue: [ ^ (index - 1)]\r\t].\t\r\r\t^ nl size',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '212' ],		#self : OmReference [ '213' ],		#time : DateAndTime [ '2020-01-07T02:12:42.568626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #line,			#protocol : #positioning,			#sourceCode : 'line\r\t^ self line: position',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #line,			#protocol : #'as yet unclassified',			#sourceCode : 'line\r\t^ self line: position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '213' ],		#self : OmReference [ '214' ],		#time : DateAndTime [ '2020-01-07T02:12:42.568626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #line,			#protocol : #positioning,			#sourceCode : 'line\r\t^ self line: position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '214' ],		#self : OmReference [ '215' ],		#time : DateAndTime [ '2020-01-07T02:12:42.572626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #isStartOfLine,			#protocol : #queries,			#sourceCode : 'isStartOfLine\r\t(position = 0) ifTrue: [ ^ true ].\r\r\tself insideCRLF ifTrue: [ ^ false ].\r\t\r\t^ (self peekBack = (Character codePoint: 13)) or: [ self peekBack = (Character codePoint: 10)].',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #isStartOfLine,			#protocol : #'as yet unclassified',			#sourceCode : 'isStartOfLine\r\t(position = 0) ifTrue: [ ^ true ].\r\r\tself insideCRLF ifTrue: [ ^ false ].\r\t\r\t^ (self peekBack = (Character codePoint: 13)) or: [ self peekBack = (Character codePoint: 10)].',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '215' ],		#self : OmReference [ '216' ],		#time : DateAndTime [ '2020-01-07T02:12:42.572626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #isStartOfLine,			#protocol : #queries,			#sourceCode : 'isStartOfLine\r\t(position = 0) ifTrue: [ ^ true ].\r\r\tself insideCRLF ifTrue: [ ^ false ].\r\t\r\t^ (self peekBack = (Character codePoint: 13)) or: [ self peekBack = (Character codePoint: 10)].',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '216' ],		#self : OmReference [ '217' ],		#time : DateAndTime [ '2020-01-07T02:12:42.576626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #isEndOfLine,			#protocol : #queries,			#sourceCode : 'isEndOfLine\r\tself atEnd ifTrue: [ ^ true ].\r\tself insideCRLF ifTrue: [ ^ false ].\r\t^ (self peek = (Character codePoint: 13) or: [ self peek = (Character codePoint: 10)]).',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #isEndOfLine,			#protocol : #'as yet unclassified',			#sourceCode : 'isEndOfLine\r\tself atEnd ifTrue: [ ^ true ].\r\tself insideCRLF ifTrue: [ ^ false ].\r\t^ (self peek = (Character codePoint: 13) or: [ self peek = (Character codePoint: 10)]).',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '217' ],		#self : OmReference [ '218' ],		#time : DateAndTime [ '2020-01-07T02:12:42.576626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #isEndOfLine,			#protocol : #queries,			#sourceCode : 'isEndOfLine\r\tself atEnd ifTrue: [ ^ true ].\r\tself insideCRLF ifTrue: [ ^ false ].\r\t^ (self peek = (Character codePoint: 13) or: [ self peek = (Character codePoint: 10)]).',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '218' ],		#self : OmReference [ '219' ],		#time : DateAndTime [ '2020-01-07T02:12:42.579626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #insideCRLF,			#protocol : #queries,			#sourceCode : 'insideCRLF\r\t(position < 1) ifTrue: [ ^ false ].\r\t\r\t^ (self peek = (Character codePoint: 10)) and: [ self peekBack = (Character codePoint: 13) ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #insideCRLF,			#protocol : #'as yet unclassified',			#sourceCode : 'insideCRLF\r\t(position < 1) ifTrue: [ ^ false ].\r\t\r\t^ (self peek = (Character codePoint: 10)) and: [ self peekBack = (Character codePoint: 13) ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '219' ],		#self : OmReference [ '220' ],		#time : DateAndTime [ '2020-01-07T02:12:42.580626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #insideCRLF,			#protocol : #queries,			#sourceCode : 'insideCRLF\r\t(position < 1) ifTrue: [ ^ false ].\r\t\r\t^ (self peek = (Character codePoint: 10)) and: [ self peekBack = (Character codePoint: 13) ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '220' ],		#self : OmReference [ '221' ],		#time : DateAndTime [ '2020-01-07T02:12:42.582626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ReadStream subclass: #PPStream\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'ReadStream'			},			#name : #PPStream,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPStream class\r\tinstanceVariableNames: \'\''				},				#name : #'PPStream class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPStream,					#isMetaSide : false				},				#parent : @8,				#content : 'A positional stream implementation used for parsing. It overrides some methods for optimization reasons.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #queries	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '221' ],		#self : OmReference [ '222' ],		#time : DateAndTime [ '2020-01-07T02:12:42.583626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #fillNewlines,			#protocol : #positioning,			#sourceCode : 'fillNewlines\r\t| tmp line |\r\tnewlines := OrderedCollection new.\t\r\t\r\ttmp := position.\r\tline := 0.\r\t\r\t(0 to: readLimit) do: [:index |\r\t\tposition := index.\r\t\tself isStartOfLine ifTrue: [ newlines add: position ]\r\t].\r\tposition := tmp.\r\tnewlines := newlines asArray.\r\t^ newlines',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #fillNewlines,			#protocol : #'as yet unclassified',			#sourceCode : 'fillNewlines\r\t| tmp line |\r\tnewlines := OrderedCollection new.\t\r\t\r\ttmp := position.\r\tline := 0.\r\t\r\t(0 to: readLimit) do: [:index |\r\t\tposition := index.\r\t\tself isStartOfLine ifTrue: [ newlines add: position ]\r\t].\r\tposition := tmp.\r\tnewlines := newlines asArray.\r\t^ newlines',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '222' ],		#self : OmReference [ '223' ],		#time : DateAndTime [ '2020-01-07T02:12:42.584626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #fillNewlines,			#protocol : #positioning,			#sourceCode : 'fillNewlines\r\t| tmp line |\r\tnewlines := OrderedCollection new.\t\r\t\r\ttmp := position.\r\tline := 0.\r\t\r\t(0 to: readLimit) do: [:index |\r\t\tposition := index.\r\t\tself isStartOfLine ifTrue: [ newlines add: position ]\r\t].\r\tposition := tmp.\r\tnewlines := newlines asArray.\r\t^ newlines',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '223' ],		#self : OmReference [ '224' ],		#time : DateAndTime [ '2020-01-07T02:12:42.587626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #'column:',			#protocol : #positioning,			#sourceCode : 'column: pos\r\t| nl |\r\t(pos = -1) ifTrue: [  ^ 0 ].\r\t(pos > readLimit) ifTrue: [ ^ self error: \'Out of limit\' ].\r\t\r\tnl := self newlines.\r\t1 to: nl size do: [ :index | \r\t\t((nl at: index) > pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1 ]\r\t].\r"\tnl keysAndValuesDo: [ :index :value |\r\t\t(value > pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1]\r\t].\t\r"\r\t^ pos - (nl at: (nl size )) + 1',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #'column:',			#protocol : #'as yet unclassified',			#sourceCode : 'column: pos\r\t| nl |\r\t(pos = -1) ifTrue: [  ^ 0 ].\r\t(pos > readLimit) ifTrue: [ ^ self error: \'Out of limit\' ].\r\t\r\tnl := self newlines.\r\t1 to: nl size do: [ :index | \r\t\t((nl at: index) > pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1 ]\r\t].\r"\tnl keysAndValuesDo: [ :index :value |\r\t\t(value > pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1]\r\t].\t\r"\r\t^ pos - (nl at: (nl size )) + 1',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '224' ],		#self : OmReference [ '225' ],		#time : DateAndTime [ '2020-01-07T02:12:42.588626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #'column:',			#protocol : #positioning,			#sourceCode : 'column: pos\r\t| nl |\r\t(pos = -1) ifTrue: [  ^ 0 ].\r\t(pos > readLimit) ifTrue: [ ^ self error: \'Out of limit\' ].\r\t\r\tnl := self newlines.\r\t1 to: nl size do: [ :index | \r\t\t((nl at: index) > pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1 ]\r\t].\r"\tnl keysAndValuesDo: [ :index :value |\r\t\t(value > pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1]\r\t].\t\r"\r\t^ pos - (nl at: (nl size )) + 1',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '225' ],		#self : OmReference [ '226' ],		#time : DateAndTime [ '2020-01-07T02:12:42.591626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #column,			#protocol : #positioning,			#sourceCode : 'column\r\t^ self column: position.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #column,			#protocol : #'as yet unclassified',			#sourceCode : 'column\r\t^ self column: position.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '226' ],		#self : OmReference [ '227' ],		#time : DateAndTime [ '2020-01-07T02:12:42.591626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPStream,				#isMetaSide : false			},			#name : #column,			#protocol : #positioning,			#sourceCode : 'column\r\t^ self column: position.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '227' ],		#self : OmReference [ '228' ],		#time : DateAndTime [ '2020-01-07T02:12:42.594626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ReadStream subclass: #PPStream\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'ReadStream'			},			#name : #PPStream,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPStream class\r\tinstanceVariableNames: \'\''				},				#name : #'PPStream class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPStream,					#isMetaSide : false				},				#parent : @8,				#content : 'A positional stream implementation used for parsing. It overrides some methods for optimization reasons.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #positioning	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '228' ],		#self : OmReference [ '229' ],		#time : DateAndTime [ '2020-01-07T02:12:42.594626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'stream:',			#protocol : #accessing,			#sourceCode : 'stream: aStream\r\tstream := aStream',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'stream:',			#protocol : #'as yet unclassified',			#sourceCode : 'stream: aStream\r\tstream := aStream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '229' ],		#self : OmReference [ '230' ],		#time : DateAndTime [ '2020-01-07T02:12:42.595626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'stream:',			#protocol : #accessing,			#sourceCode : 'stream: aStream\r\tstream := aStream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '230' ],		#self : OmReference [ '231' ],		#time : DateAndTime [ '2020-01-07T02:12:42.598626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #stream,			#protocol : #accessing,			#sourceCode : 'stream\r\t^ stream',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #stream,			#protocol : #'as yet unclassified',			#sourceCode : 'stream\r\t^ stream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '231' ],		#self : OmReference [ '232' ],		#time : DateAndTime [ '2020-01-07T02:12:42.598626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #stream,			#protocol : #accessing,			#sourceCode : 'stream\r\t^ stream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '232' ],		#self : OmReference [ '233' ],		#time : DateAndTime [ '2020-01-07T02:12:42.601626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'removeProperty:ifAbsent:',			#protocol : #'accessing - properties',			#sourceCode : 'removeProperty: aKey ifAbsent: aBlock\r\t"Remove the property with aKey. Answer the value or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t| answer |\r\tproperties isNil ifTrue: [ ^ aBlock value ].\r\tanswer := properties removeKey: aKey ifAbsent: aBlock.\r\tproperties isEmpty ifTrue: [ properties := nil ].\r\t^ answer',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'removeProperty:ifAbsent:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeProperty: aKey ifAbsent: aBlock\r\t"Remove the property with aKey. Answer the value or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t| answer |\r\tproperties isNil ifTrue: [ ^ aBlock value ].\r\tanswer := properties removeKey: aKey ifAbsent: aBlock.\r\tproperties isEmpty ifTrue: [ properties := nil ].\r\t^ answer',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '233' ],		#self : OmReference [ '234' ],		#time : DateAndTime [ '2020-01-07T02:12:42.601626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'removeProperty:ifAbsent:',			#protocol : #'accessing - properties',			#sourceCode : 'removeProperty: aKey ifAbsent: aBlock\r\t"Remove the property with aKey. Answer the value or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t| answer |\r\tproperties isNil ifTrue: [ ^ aBlock value ].\r\tanswer := properties removeKey: aKey ifAbsent: aBlock.\r\tproperties isEmpty ifTrue: [ properties := nil ].\r\t^ answer',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '234' ],		#self : OmReference [ '235' ],		#time : DateAndTime [ '2020-01-07T02:12:42.604626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'removeProperty:',			#protocol : #'accessing - properties',			#sourceCode : 'removeProperty: aKey\r\t"Remove the property with aKey. Answer the property or raise an error if aKey isn\'t found."\r\t\r\t^ self removeProperty: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'removeProperty:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeProperty: aKey\r\t"Remove the property with aKey. Answer the property or raise an error if aKey isn\'t found."\r\t\r\t^ self removeProperty: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '235' ],		#self : OmReference [ '236' ],		#time : DateAndTime [ '2020-01-07T02:12:42.605626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'removeProperty:',			#protocol : #'accessing - properties',			#sourceCode : 'removeProperty: aKey\r\t"Remove the property with aKey. Answer the property or raise an error if aKey isn\'t found."\r\t\r\t^ self removeProperty: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '236' ],		#self : OmReference [ '237' ],		#time : DateAndTime [ '2020-01-07T02:12:42.608626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:put:',			#protocol : #'accessing - properties',			#sourceCode : 'propertyAt: aKey put: anObject\r\t"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."\r\r\t^ (properties ifNil: [ properties := Dictionary new: 1 ])\r\t\tat: aKey put: (anObject copy)',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'propertyAt: aKey put: anObject\r\t"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."\r\r\t^ (properties ifNil: [ properties := Dictionary new: 1 ])\r\t\tat: aKey put: (anObject copy)',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '237' ],		#self : OmReference [ '238' ],		#time : DateAndTime [ '2020-01-07T02:12:42.608626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:put:',			#protocol : #'accessing - properties',			#sourceCode : 'propertyAt: aKey put: anObject\r\t"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."\r\r\t^ (properties ifNil: [ properties := Dictionary new: 1 ])\r\t\tat: aKey put: (anObject copy)',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '238' ],		#self : OmReference [ '239' ],		#time : DateAndTime [ '2020-01-07T02:12:42.611626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsentPut:',			#protocol : #'accessing - properties',			#sourceCode : 'propertyAt: aKey ifAbsentPut: aBlock\r\t"Answer the property associated with aKey or, if aKey isn\'t found store the result of evaluating aBlock as new value."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsentPut:',			#protocol : #'as yet unclassified',			#sourceCode : 'propertyAt: aKey ifAbsentPut: aBlock\r\t"Answer the property associated with aKey or, if aKey isn\'t found store the result of evaluating aBlock as new value."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '239' ],		#self : OmReference [ '240' ],		#time : DateAndTime [ '2020-01-07T02:12:42.611626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsentPut:',			#protocol : #'accessing - properties',			#sourceCode : 'propertyAt: aKey ifAbsentPut: aBlock\r\t"Answer the property associated with aKey or, if aKey isn\'t found store the result of evaluating aBlock as new value."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '240' ],		#self : OmReference [ '241' ],		#time : DateAndTime [ '2020-01-07T02:12:42.615626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsent:',			#protocol : #'accessing - properties',			#sourceCode : 'propertyAt: aKey ifAbsent: aBlock\r\t"Answer the property value associated with aKey or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\tproperties isNil\r\t\tifTrue: [ ^ aBlock value ]\r\t\tifFalse: [ \r\t\t\t(properties includesKey: aKey) ifTrue: [ \r\t\t\t\t^ (properties at: aKey) copy\r\t\t\t].\r\t\t\t^ aBlock value\r\t\t]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsent:',			#protocol : #'as yet unclassified',			#sourceCode : 'propertyAt: aKey ifAbsent: aBlock\r\t"Answer the property value associated with aKey or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\tproperties isNil\r\t\tifTrue: [ ^ aBlock value ]\r\t\tifFalse: [ \r\t\t\t(properties includesKey: aKey) ifTrue: [ \r\t\t\t\t^ (properties at: aKey) copy\r\t\t\t].\r\t\t\t^ aBlock value\r\t\t]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '241' ],		#self : OmReference [ '242' ],		#time : DateAndTime [ '2020-01-07T02:12:42.615626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsent:',			#protocol : #'accessing - properties',			#sourceCode : 'propertyAt: aKey ifAbsent: aBlock\r\t"Answer the property value associated with aKey or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\tproperties isNil\r\t\tifTrue: [ ^ aBlock value ]\r\t\tifFalse: [ \r\t\t\t(properties includesKey: aKey) ifTrue: [ \r\t\t\t\t^ (properties at: aKey) copy\r\t\t\t].\r\t\t\t^ aBlock value\r\t\t]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '242' ],		#self : OmReference [ '243' ],		#time : DateAndTime [ '2020-01-07T02:12:42.619626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:',			#protocol : #'accessing - properties',			#sourceCode : 'propertyAt: aKey\r\t"Answer the property value associated with aKey."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:',			#protocol : #'as yet unclassified',			#sourceCode : 'propertyAt: aKey\r\t"Answer the property value associated with aKey."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '243' ],		#self : OmReference [ '244' ],		#time : DateAndTime [ '2020-01-07T02:12:42.619626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'propertyAt:',			#protocol : #'accessing - properties',			#sourceCode : 'propertyAt: aKey\r\t"Answer the property value associated with aKey."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '244' ],		#self : OmReference [ '245' ],		#time : DateAndTime [ '2020-01-07T02:12:42.622626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #propertiesSize,			#protocol : #'accessing - properties',			#sourceCode : 'propertiesSize\r\tproperties ifNil: [ ^ 0 ].\r\t^ properties size.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #propertiesSize,			#protocol : #'as yet unclassified',			#sourceCode : 'propertiesSize\r\tproperties ifNil: [ ^ 0 ].\r\t^ properties size.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '245' ],		#self : OmReference [ '246' ],		#time : DateAndTime [ '2020-01-07T02:12:42.622626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #propertiesSize,			#protocol : #'accessing - properties',			#sourceCode : 'propertiesSize\r\tproperties ifNil: [ ^ 0 ].\r\t^ properties size.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '246' ],		#self : OmReference [ '247' ],		#time : DateAndTime [ '2020-01-07T02:12:42.625626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'position:',			#protocol : #accessing,			#sourceCode : 'position: anInteger\r\tposition := anInteger ',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'position:',			#protocol : #'as yet unclassified',			#sourceCode : 'position: anInteger\r\tposition := anInteger ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '247' ],		#self : OmReference [ '248' ],		#time : DateAndTime [ '2020-01-07T02:12:42.625626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'position:',			#protocol : #accessing,			#sourceCode : 'position: anInteger\r\tposition := anInteger ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '248' ],		#self : OmReference [ '249' ],		#time : DateAndTime [ '2020-01-07T02:12:42.628626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #position,			#protocol : #accessing,			#sourceCode : 'position\r\t^ position',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #position,			#protocol : #'as yet unclassified',			#sourceCode : 'position\r\t^ position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '249' ],		#self : OmReference [ '250' ],		#time : DateAndTime [ '2020-01-07T02:12:42.629626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #position,			#protocol : #accessing,			#sourceCode : 'position\r\t^ position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '250' ],		#self : OmReference [ '251' ],		#time : DateAndTime [ '2020-01-07T02:12:42.631626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContextMemento\r\tinstanceVariableNames: \'stream position properties\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContextMemento,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMemento,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMemento,						#isMetaSide : false					},					#name : #position,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMemento,						#isMetaSide : false					},					#name : #properties,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextMemento class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContextMemento class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContextMemento,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #accessing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '251' ],		#self : OmReference [ '252' ],		#time : DateAndTime [ '2020-01-07T02:12:42.632626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'keysAndValuesDo:',			#protocol : #'accessing - properties',			#sourceCode : 'keysAndValuesDo: aBlock\r\tproperties ifNil: [ ^ self ].\r\tproperties keysAndValuesDo: [ :key :value | aBlock value: key value: value copy ] ',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'keysAndValuesDo:',			#protocol : #'as yet unclassified',			#sourceCode : 'keysAndValuesDo: aBlock\r\tproperties ifNil: [ ^ self ].\r\tproperties keysAndValuesDo: [ :key :value | aBlock value: key value: value copy ] ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '252' ],		#self : OmReference [ '253' ],		#time : DateAndTime [ '2020-01-07T02:12:42.632626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'keysAndValuesDo:',			#protocol : #'accessing - properties',			#sourceCode : 'keysAndValuesDo: aBlock\r\tproperties ifNil: [ ^ self ].\r\tproperties keysAndValuesDo: [ :key :value | aBlock value: key value: value copy ] ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '253' ],		#self : OmReference [ '254' ],		#time : DateAndTime [ '2020-01-07T02:12:42.635626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #hash,			#protocol : #comparing,			#sourceCode : 'hash\r\t^ (position hash bitXor: stream hash) bitXor: properties hash.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #hash,			#protocol : #'as yet unclassified',			#sourceCode : 'hash\r\t^ (position hash bitXor: stream hash) bitXor: properties hash.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '254' ],		#self : OmReference [ '255' ],		#time : DateAndTime [ '2020-01-07T02:12:42.636626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #hash,			#protocol : #comparing,			#sourceCode : 'hash\r\t^ (position hash bitXor: stream hash) bitXor: properties hash.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '255' ],		#self : OmReference [ '256' ],		#time : DateAndTime [ '2020-01-07T02:12:42.639626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'hasProperty:',			#protocol : #'accessing - properties',			#sourceCode : 'hasProperty: aKey\r\t"Test if the property aKey is present."\r\t\r\t^ properties notNil and: [ properties includesKey: aKey ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'hasProperty:',			#protocol : #'as yet unclassified',			#sourceCode : 'hasProperty: aKey\r\t"Test if the property aKey is present."\r\t\r\t^ properties notNil and: [ properties includesKey: aKey ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '256' ],		#self : OmReference [ '257' ],		#time : DateAndTime [ '2020-01-07T02:12:42.639626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'hasProperty:',			#protocol : #'accessing - properties',			#sourceCode : 'hasProperty: aKey\r\t"Test if the property aKey is present."\r\t\r\t^ properties notNil and: [ properties includesKey: aKey ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '257' ],		#self : OmReference [ '258' ],		#time : DateAndTime [ '2020-01-07T02:12:42.642626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContextMemento\r\tinstanceVariableNames: \'stream position properties\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContextMemento,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMemento,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMemento,						#isMetaSide : false					},					#name : #position,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMemento,						#isMetaSide : false					},					#name : #properties,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextMemento class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContextMemento class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContextMemento,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #'accessing - properties'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '258' ],		#self : OmReference [ '259' ],		#time : DateAndTime [ '2020-01-07T02:12:42.643626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anObject\r\t\r\t(self == anObject) ifTrue: [ ^ true ].\r\t(anObject class = PPContextMemento) ifFalse: [ ^ false ].\r\t\r\t(anObject stream == stream) ifFalse: [ ^ false ].\r\t(anObject position == position) ifFalse: [ ^ false ].\r\t\r\t(self propertiesSize == anObject propertiesSize) ifFalse: [ ^ false ].\r\r\tself keysAndValuesDo: [ :key :value |\r\t\t(anObject hasProperty: key) ifFalse: [ ^ false ].\r\t\t((anObject propertyAt: key) = value) ifFalse: [ ^ false ]. \r \t].\r\t\r\t^ true.\r',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anObject\r\t\r\t(self == anObject) ifTrue: [ ^ true ].\r\t(anObject class = PPContextMemento) ifFalse: [ ^ false ].\r\t\r\t(anObject stream == stream) ifFalse: [ ^ false ].\r\t(anObject position == position) ifFalse: [ ^ false ].\r\t\r\t(self propertiesSize == anObject propertiesSize) ifFalse: [ ^ false ].\r\r\tself keysAndValuesDo: [ :key :value |\r\t\t(anObject hasProperty: key) ifFalse: [ ^ false ].\r\t\t((anObject propertyAt: key) = value) ifFalse: [ ^ false ]. \r \t].\r\t\r\t^ true.\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '259' ],		#self : OmReference [ '260' ],		#time : DateAndTime [ '2020-01-07T02:12:42.643626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContextMemento,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anObject\r\t\r\t(self == anObject) ifTrue: [ ^ true ].\r\t(anObject class = PPContextMemento) ifFalse: [ ^ false ].\r\t\r\t(anObject stream == stream) ifFalse: [ ^ false ].\r\t(anObject position == position) ifFalse: [ ^ false ].\r\t\r\t(self propertiesSize == anObject propertiesSize) ifFalse: [ ^ false ].\r\r\tself keysAndValuesDo: [ :key :value |\r\t\t(anObject hasProperty: key) ifFalse: [ ^ false ].\r\t\t((anObject propertyAt: key) = value) ifFalse: [ ^ false ]. \r \t].\r\t\r\t^ true.\r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '260' ],		#self : OmReference [ '261' ],		#time : DateAndTime [ '2020-01-07T02:12:42.645626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContextMemento\r\tinstanceVariableNames: \'stream position properties\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContextMemento,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMemento,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMemento,						#isMetaSide : false					},					#name : #position,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContextMemento,						#isMetaSide : false					},					#name : #properties,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextMemento class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContextMemento class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContextMemento,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #comparing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '261' ],		#self : OmReference [ '262' ],		#time : DateAndTime [ '2020-01-07T02:12:42.714626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContextMemento\r\tinstanceVariableNames: \'stream position properties\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContextMemento,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContextMemento,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContextMemento,						#isMetaSide : false					},					#name : #position,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContextMemento,						#isMetaSide : false					},					#name : #properties,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContextMemento class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPContextMemento class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPContextMemento,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '262' ],		#self : OmReference [ '263' ],		#time : DateAndTime [ '2020-01-07T02:12:42.716626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'upToAnyOf:',			#protocol : #'stream mimicry',			#sourceCode : 'upToAnyOf: whatever\r\t^ stream upToAnyOf: whatever',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'upToAnyOf:',			#protocol : #'as yet unclassified',			#sourceCode : 'upToAnyOf: whatever\r\t^ stream upToAnyOf: whatever',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '263' ],		#self : OmReference [ '264' ],		#time : DateAndTime [ '2020-01-07T02:12:42.716626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'upToAnyOf:',			#protocol : #'stream mimicry',			#sourceCode : 'upToAnyOf: whatever\r\t^ stream upToAnyOf: whatever',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '264' ],		#self : OmReference [ '265' ],		#time : DateAndTime [ '2020-01-07T02:12:42.719626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'upToAll:',			#protocol : #'stream mimicry',			#sourceCode : 'upToAll: whatever\r\t^ stream upToAll: whatever',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'upToAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'upToAll: whatever\r\t^ stream upToAll: whatever',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '265' ],		#self : OmReference [ '266' ],		#time : DateAndTime [ '2020-01-07T02:12:42.719626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'upToAll:',			#protocol : #'stream mimicry',			#sourceCode : 'upToAll: whatever\r\t^ stream upToAll: whatever',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '266' ],		#self : OmReference [ '267' ],		#time : DateAndTime [ '2020-01-07T02:12:42.723626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'upTo:',			#protocol : #'stream mimicry',			#sourceCode : 'upTo: anObject\r\t^ stream upTo: anObject',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'upTo:',			#protocol : #'as yet unclassified',			#sourceCode : 'upTo: anObject\r\t^ stream upTo: anObject',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '267' ],		#self : OmReference [ '268' ],		#time : DateAndTime [ '2020-01-07T02:12:42.723626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'upTo:',			#protocol : #'stream mimicry',			#sourceCode : 'upTo: anObject\r\t^ stream upTo: anObject',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '268' ],		#self : OmReference [ '269' ],		#time : DateAndTime [ '2020-01-07T02:12:42.727626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #uncheckedPeek,			#protocol : #'stream mimicry',			#sourceCode : 'uncheckedPeek\r\t^ stream uncheckedPeek',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #uncheckedPeek,			#protocol : #'as yet unclassified',			#sourceCode : 'uncheckedPeek\r\t^ stream uncheckedPeek',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '269' ],		#self : OmReference [ '270' ],		#time : DateAndTime [ '2020-01-07T02:12:42.727626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #uncheckedPeek,			#protocol : #'stream mimicry',			#sourceCode : 'uncheckedPeek\r\t^ stream uncheckedPeek',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '270' ],		#self : OmReference [ '271' ],		#time : DateAndTime [ '2020-01-07T02:12:42.730626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'stream:',			#protocol : #acessing,			#sourceCode : 'stream: aStream\r\tstream := aStream.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'stream:',			#protocol : #'as yet unclassified',			#sourceCode : 'stream: aStream\r\tstream := aStream.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '271' ],		#self : OmReference [ '272' ],		#time : DateAndTime [ '2020-01-07T02:12:42.730626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'stream:',			#protocol : #acessing,			#sourceCode : 'stream: aStream\r\tstream := aStream.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '272' ],		#self : OmReference [ '273' ],		#time : DateAndTime [ '2020-01-07T02:12:42.733626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #stream,			#protocol : #acessing,			#sourceCode : 'stream\r\t^ stream',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #stream,			#protocol : #'as yet unclassified',			#sourceCode : 'stream\r\t^ stream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '273' ],		#self : OmReference [ '274' ],		#time : DateAndTime [ '2020-01-07T02:12:42.733626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #stream,			#protocol : #acessing,			#sourceCode : 'stream\r\t^ stream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '274' ],		#self : OmReference [ '275' ],		#time : DateAndTime [ '2020-01-07T02:12:42.736626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skipToAnyOf:',			#protocol : #'stream mimicry',			#sourceCode : 'skipToAnyOf: aCharacterSet \r\t"Set the access position of the receiver to be past the next occurrence of\r\ta character in the character set. Answer whether a fitting character is found."\r\r\t[stream atEnd]\r\t\twhileFalse: [ (aCharacterSet includes: stream next) ifTrue: [^true]].\r\t^false',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skipToAnyOf:',			#protocol : #'as yet unclassified',			#sourceCode : 'skipToAnyOf: aCharacterSet \r\t"Set the access position of the receiver to be past the next occurrence of\r\ta character in the character set. Answer whether a fitting character is found."\r\r\t[stream atEnd]\r\t\twhileFalse: [ (aCharacterSet includes: stream next) ifTrue: [^true]].\r\t^false',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '275' ],		#self : OmReference [ '276' ],		#time : DateAndTime [ '2020-01-07T02:12:42.737626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skipToAnyOf:',			#protocol : #'stream mimicry',			#sourceCode : 'skipToAnyOf: aCharacterSet \r\t"Set the access position of the receiver to be past the next occurrence of\r\ta character in the character set. Answer whether a fitting character is found."\r\r\t[stream atEnd]\r\t\twhileFalse: [ (aCharacterSet includes: stream next) ifTrue: [^true]].\r\t^false',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '276' ],		#self : OmReference [ '277' ],		#time : DateAndTime [ '2020-01-07T02:12:42.739626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skipToAll:',			#protocol : #'stream mimicry',			#sourceCode : 'skipToAll: aString\r\t"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."\r\t| pattern startMatch |\r\tpattern := aString readStream.\r\tstartMatch := nil.\r\t[ pattern atEnd ] whileFalse: \r\t\t[ stream atEnd ifTrue: [ ^ false ].\r\t\tstream next = pattern next \r\t\t\tifTrue: [ pattern position = 1 ifTrue: [ startMatch := stream position ] ]\r\t\t\tifFalse: \r\t\t\t\t[ pattern position: 0.\r\t\t\t\tstartMatch ifNotNil: \r\t\t\t\t\t[ stream position: startMatch.\r\t\t\t\t\tstartMatch := nil ] ] ].\r\t^ true',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skipToAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'skipToAll: aString\r\t"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."\r\t| pattern startMatch |\r\tpattern := aString readStream.\r\tstartMatch := nil.\r\t[ pattern atEnd ] whileFalse: \r\t\t[ stream atEnd ifTrue: [ ^ false ].\r\t\tstream next = pattern next \r\t\t\tifTrue: [ pattern position = 1 ifTrue: [ startMatch := stream position ] ]\r\t\t\tifFalse: \r\t\t\t\t[ pattern position: 0.\r\t\t\t\tstartMatch ifNotNil: \r\t\t\t\t\t[ stream position: startMatch.\r\t\t\t\t\tstartMatch := nil ] ] ].\r\t^ true',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '277' ],		#self : OmReference [ '278' ],		#time : DateAndTime [ '2020-01-07T02:12:42.740626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skipToAll:',			#protocol : #'stream mimicry',			#sourceCode : 'skipToAll: aString\r\t"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."\r\t| pattern startMatch |\r\tpattern := aString readStream.\r\tstartMatch := nil.\r\t[ pattern atEnd ] whileFalse: \r\t\t[ stream atEnd ifTrue: [ ^ false ].\r\t\tstream next = pattern next \r\t\t\tifTrue: [ pattern position = 1 ifTrue: [ startMatch := stream position ] ]\r\t\t\tifFalse: \r\t\t\t\t[ pattern position: 0.\r\t\t\t\tstartMatch ifNotNil: \r\t\t\t\t\t[ stream position: startMatch.\r\t\t\t\t\tstartMatch := nil ] ] ].\r\t^ true',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '278' ],		#self : OmReference [ '279' ],		#time : DateAndTime [ '2020-01-07T02:12:42.742626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skipTo:',			#protocol : #'stream mimicry',			#sourceCode : 'skipTo: anObject \r\t^ stream skipTo: anObject ',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skipTo:',			#protocol : #'as yet unclassified',			#sourceCode : 'skipTo: anObject \r\t^ stream skipTo: anObject ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '279' ],		#self : OmReference [ '280' ],		#time : DateAndTime [ '2020-01-07T02:12:42.743626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skipTo:',			#protocol : #'stream mimicry',			#sourceCode : 'skipTo: anObject \r\t^ stream skipTo: anObject ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '280' ],		#self : OmReference [ '281' ],		#time : DateAndTime [ '2020-01-07T02:12:42.746626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skip:',			#protocol : #'stream mimicry',			#sourceCode : 'skip: anInteger \r\t^ stream skip: anInteger ',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skip:',			#protocol : #'as yet unclassified',			#sourceCode : 'skip: anInteger \r\t^ stream skip: anInteger ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '281' ],		#self : OmReference [ '282' ],		#time : DateAndTime [ '2020-01-07T02:12:42.746626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'skip:',			#protocol : #'stream mimicry',			#sourceCode : 'skip: anInteger \r\t^ stream skip: anInteger ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '282' ],		#self : OmReference [ '283' ],		#time : DateAndTime [ '2020-01-07T02:12:42.749626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #size,			#protocol : #memoization,			#sourceCode : 'size\r\t^ stream size',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #size,			#protocol : #'as yet unclassified',			#sourceCode : 'size\r\t^ stream size',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '283' ],		#self : OmReference [ '284' ],		#time : DateAndTime [ '2020-01-07T02:12:42.749626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #size,			#protocol : #memoization,			#sourceCode : 'size\r\t^ stream size',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '284' ],		#self : OmReference [ '285' ],		#time : DateAndTime [ '2020-01-07T02:12:42.752626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #root,			#protocol : #acessing,			#sourceCode : 'root\r\t^ root ',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #root,			#protocol : #'as yet unclassified',			#sourceCode : 'root\r\t^ root ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '285' ],		#self : OmReference [ '286' ],		#time : DateAndTime [ '2020-01-07T02:12:42.753626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #root,			#protocol : #acessing,			#sourceCode : 'root\r\t^ root ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '286' ],		#self : OmReference [ '287' ],		#time : DateAndTime [ '2020-01-07T02:12:42.755626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContext,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPContext is provides contextual information to the parsing function.\r\rInstance Variables\r\tglobals:\t\t<Dictionary>\r\tproperties:\t\t<Dictionar>\r\troot:\t\t<PPParser>\r\tstream:\t\t<PPStream>\r\rglobals\r\t- properties that are not restored after backtracking\r\rproperties\r\t- properties that are restored after backtracking\r\rroot\r\t- the root parser\r\rstream\r\t- input stream\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #acessing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '287' ],		#self : OmReference [ '288' ],		#time : DateAndTime [ '2020-01-07T02:12:42.756626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'restoreProperties:',			#protocol : #memoization,			#sourceCode : 'restoreProperties: aPPContextMemento\r\taPPContextMemento stream == stream ifFalse: [ self error: \'Oops!\' ].\r\t\r\tproperties ifNil: [ ^ self ].\r\t\r\tproperties keysDo: [ :key |\r\t\t(aPPContextMemento hasProperty: key)\r\t\t\tifTrue: [ properties at: key put: (aPPContextMemento propertyAt: key) ]\r\t\t\tifFalse: [ properties removeKey: key  ]. \r\t].\r\r\taPPContextMemento keysAndValuesDo: [ :key :value |\r\t\tproperties at: key put: value\r\t]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'restoreProperties:',			#protocol : #'as yet unclassified',			#sourceCode : 'restoreProperties: aPPContextMemento\r\taPPContextMemento stream == stream ifFalse: [ self error: \'Oops!\' ].\r\t\r\tproperties ifNil: [ ^ self ].\r\t\r\tproperties keysDo: [ :key |\r\t\t(aPPContextMemento hasProperty: key)\r\t\t\tifTrue: [ properties at: key put: (aPPContextMemento propertyAt: key) ]\r\t\t\tifFalse: [ properties removeKey: key  ]. \r\t].\r\r\taPPContextMemento keysAndValuesDo: [ :key :value |\r\t\tproperties at: key put: value\r\t]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '288' ],		#self : OmReference [ '289' ],		#time : DateAndTime [ '2020-01-07T02:12:42.756626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'restoreProperties:',			#protocol : #memoization,			#sourceCode : 'restoreProperties: aPPContextMemento\r\taPPContextMemento stream == stream ifFalse: [ self error: \'Oops!\' ].\r\t\r\tproperties ifNil: [ ^ self ].\r\t\r\tproperties keysDo: [ :key |\r\t\t(aPPContextMemento hasProperty: key)\r\t\t\tifTrue: [ properties at: key put: (aPPContextMemento propertyAt: key) ]\r\t\t\tifFalse: [ properties removeKey: key  ]. \r\t].\r\r\taPPContextMemento keysAndValuesDo: [ :key :value |\r\t\tproperties at: key put: value\r\t]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '289' ],		#self : OmReference [ '290' ],		#time : DateAndTime [ '2020-01-07T02:12:42.759626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'restore:',			#protocol : #memoization,			#sourceCode : 'restore: aPPContextMemento\r\taPPContextMemento stream == stream ifFalse: [ self error: \'Oops!\' ].\r\r\tstream position: aPPContextMemento position.\r\tself restoreProperties: aPPContextMemento.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'restore:',			#protocol : #'as yet unclassified',			#sourceCode : 'restore: aPPContextMemento\r\taPPContextMemento stream == stream ifFalse: [ self error: \'Oops!\' ].\r\r\tstream position: aPPContextMemento position.\r\tself restoreProperties: aPPContextMemento.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '290' ],		#self : OmReference [ '291' ],		#time : DateAndTime [ '2020-01-07T02:12:42.759626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'restore:',			#protocol : #memoization,			#sourceCode : 'restore: aPPContextMemento\r\taPPContextMemento stream == stream ifFalse: [ self error: \'Oops!\' ].\r\r\tstream position: aPPContextMemento position.\r\tself restoreProperties: aPPContextMemento.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '291' ],		#self : OmReference [ '292' ],		#time : DateAndTime [ '2020-01-07T02:12:42.762626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #reset,			#protocol : #initialization,			#sourceCode : 'reset\r\tproperties := nil.\r\tglobals := nil.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #reset,			#protocol : #'as yet unclassified',			#sourceCode : 'reset\r\tproperties := nil.\r\tglobals := nil.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '292' ],		#self : OmReference [ '293' ],		#time : DateAndTime [ '2020-01-07T02:12:42.763626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #reset,			#protocol : #initialization,			#sourceCode : 'reset\r\tproperties := nil.\r\tglobals := nil.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '293' ],		#self : OmReference [ '294' ],		#time : DateAndTime [ '2020-01-07T02:12:42.766626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeProperty:ifAbsent:',			#protocol : #accessing-properties,			#sourceCode : 'removeProperty: aKey ifAbsent: aBlock\r\t"Remove the property with aKey. Answer the value or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t| answer |\r\tproperties isNil ifTrue: [ ^ aBlock value ].\r\tanswer := properties removeKey: aKey ifAbsent: aBlock.\r\tproperties isEmpty ifTrue: [ properties := nil ].\r\t^ answer',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeProperty:ifAbsent:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeProperty: aKey ifAbsent: aBlock\r\t"Remove the property with aKey. Answer the value or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t| answer |\r\tproperties isNil ifTrue: [ ^ aBlock value ].\r\tanswer := properties removeKey: aKey ifAbsent: aBlock.\r\tproperties isEmpty ifTrue: [ properties := nil ].\r\t^ answer',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '294' ],		#self : OmReference [ '295' ],		#time : DateAndTime [ '2020-01-07T02:12:42.766626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeProperty:ifAbsent:',			#protocol : #accessing-properties,			#sourceCode : 'removeProperty: aKey ifAbsent: aBlock\r\t"Remove the property with aKey. Answer the value or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t| answer |\r\tproperties isNil ifTrue: [ ^ aBlock value ].\r\tanswer := properties removeKey: aKey ifAbsent: aBlock.\r\tproperties isEmpty ifTrue: [ properties := nil ].\r\t^ answer',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '295' ],		#self : OmReference [ '296' ],		#time : DateAndTime [ '2020-01-07T02:12:42.769626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeProperty:',			#protocol : #accessing-properties,			#sourceCode : 'removeProperty: aKey\r\t"Remove the property with aKey. Answer the property or raise an error if aKey isn\'t found."\r\t\r\t^ self removeProperty: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeProperty:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeProperty: aKey\r\t"Remove the property with aKey. Answer the property or raise an error if aKey isn\'t found."\r\t\r\t^ self removeProperty: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '296' ],		#self : OmReference [ '297' ],		#time : DateAndTime [ '2020-01-07T02:12:42.770626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeProperty:',			#protocol : #accessing-properties,			#sourceCode : 'removeProperty: aKey\r\t"Remove the property with aKey. Answer the property or raise an error if aKey isn\'t found."\r\t\r\t^ self removeProperty: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '297' ],		#self : OmReference [ '298' ],		#time : DateAndTime [ '2020-01-07T02:12:42.772626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeGlobal:ifAbsent:',			#protocol : #accessing-globals,			#sourceCode : 'removeGlobal: aKey ifAbsent: aBlock\r\t"Remove the global property with aKey. Answer the value or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t| answer |\r\tglobals isNil ifTrue: [ ^ aBlock value ].\r\tanswer := globals removeKey: aKey ifAbsent: aBlock.\r\tglobals isEmpty ifTrue: [ globals := nil ].\r\t^ answer',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeGlobal:ifAbsent:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeGlobal: aKey ifAbsent: aBlock\r\t"Remove the global property with aKey. Answer the value or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t| answer |\r\tglobals isNil ifTrue: [ ^ aBlock value ].\r\tanswer := globals removeKey: aKey ifAbsent: aBlock.\r\tglobals isEmpty ifTrue: [ globals := nil ].\r\t^ answer',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '298' ],		#self : OmReference [ '299' ],		#time : DateAndTime [ '2020-01-07T02:12:42.773626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeGlobal:ifAbsent:',			#protocol : #accessing-globals,			#sourceCode : 'removeGlobal: aKey ifAbsent: aBlock\r\t"Remove the global property with aKey. Answer the value or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t| answer |\r\tglobals isNil ifTrue: [ ^ aBlock value ].\r\tanswer := globals removeKey: aKey ifAbsent: aBlock.\r\tglobals isEmpty ifTrue: [ globals := nil ].\r\t^ answer',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '299' ],		#self : OmReference [ '300' ],		#time : DateAndTime [ '2020-01-07T02:12:42.776626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeGlobal:',			#protocol : #accessing-globals,			#sourceCode : 'removeGlobal: aKey\r\t"Remove the property with aKey. Answer the property or raise an error if aKey isn\'t found."\r\t\r\t^ self removeGlobal: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeGlobal:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeGlobal: aKey\r\t"Remove the property with aKey. Answer the property or raise an error if aKey isn\'t found."\r\t\r\t^ self removeGlobal: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '300' ],		#self : OmReference [ '301' ],		#time : DateAndTime [ '2020-01-07T02:12:42.776626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'removeGlobal:',			#protocol : #accessing-globals,			#sourceCode : 'removeGlobal: aKey\r\t"Remove the property with aKey. Answer the property or raise an error if aKey isn\'t found."\r\t\r\t^ self removeGlobal: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '301' ],		#self : OmReference [ '302' ],		#time : DateAndTime [ '2020-01-07T02:12:42.779626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'rememberProperties:',			#protocol : #memoization,			#sourceCode : 'rememberProperties: aPPContextMemento\r\tproperties ifNil: [ ^ self ].\r\t\r\tproperties keysAndValuesDo: [ :key :value |\r\t\taPPContextMemento propertyAt: key put: value\r\t].',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'rememberProperties:',			#protocol : #'as yet unclassified',			#sourceCode : 'rememberProperties: aPPContextMemento\r\tproperties ifNil: [ ^ self ].\r\t\r\tproperties keysAndValuesDo: [ :key :value |\r\t\taPPContextMemento propertyAt: key put: value\r\t].',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '302' ],		#self : OmReference [ '303' ],		#time : DateAndTime [ '2020-01-07T02:12:42.780626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'rememberProperties:',			#protocol : #memoization,			#sourceCode : 'rememberProperties: aPPContextMemento\r\tproperties ifNil: [ ^ self ].\r\t\r\tproperties keysAndValuesDo: [ :key :value |\r\t\taPPContextMemento propertyAt: key put: value\r\t].',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '303' ],		#self : OmReference [ '304' ],		#time : DateAndTime [ '2020-01-07T02:12:42.783626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #remember,			#protocol : #memoization,			#sourceCode : 'remember\r\t| memento |\r\tmemento := PPContextMemento new\r\t\tstream: stream;\r\t\tposition: stream position;\r\t\tyourself.\r\t\t\r\tself rememberProperties: memento.\r\t^ memento',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #remember,			#protocol : #'as yet unclassified',			#sourceCode : 'remember\r\t| memento |\r\tmemento := PPContextMemento new\r\t\tstream: stream;\r\t\tposition: stream position;\r\t\tyourself.\r\t\t\r\tself rememberProperties: memento.\r\t^ memento',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '304' ],		#self : OmReference [ '305' ],		#time : DateAndTime [ '2020-01-07T02:12:42.783626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #remember,			#protocol : #memoization,			#sourceCode : 'remember\r\t| memento |\r\tmemento := PPContextMemento new\r\t\tstream: stream;\r\t\tposition: stream position;\r\t\tyourself.\r\t\t\r\tself rememberProperties: memento.\r\t^ memento',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '305' ],		#self : OmReference [ '306' ],		#time : DateAndTime [ '2020-01-07T02:12:42.786626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:put:',			#protocol : #accessing-properties,			#sourceCode : 'propertyAt: aKey put: anObject\r\t"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."\r\r\t^ (properties ifNil: [ properties := Dictionary new: 1 ])\r\t\tat: aKey put: anObject',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'propertyAt: aKey put: anObject\r\t"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."\r\r\t^ (properties ifNil: [ properties := Dictionary new: 1 ])\r\t\tat: aKey put: anObject',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '306' ],		#self : OmReference [ '307' ],		#time : DateAndTime [ '2020-01-07T02:12:42.786626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:put:',			#protocol : #accessing-properties,			#sourceCode : 'propertyAt: aKey put: anObject\r\t"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."\r\r\t^ (properties ifNil: [ properties := Dictionary new: 1 ])\r\t\tat: aKey put: anObject',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '307' ],		#self : OmReference [ '308' ],		#time : DateAndTime [ '2020-01-07T02:12:42.789626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsentPut:',			#protocol : #accessing-properties,			#sourceCode : 'propertyAt: aKey ifAbsentPut: aBlock\r\t"Answer the property associated with aKey or, if aKey isn\'t found store the result of evaluating aBlock as new value."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsentPut:',			#protocol : #'as yet unclassified',			#sourceCode : 'propertyAt: aKey ifAbsentPut: aBlock\r\t"Answer the property associated with aKey or, if aKey isn\'t found store the result of evaluating aBlock as new value."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '308' ],		#self : OmReference [ '309' ],		#time : DateAndTime [ '2020-01-07T02:12:42.789626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsentPut:',			#protocol : #accessing-properties,			#sourceCode : 'propertyAt: aKey ifAbsentPut: aBlock\r\t"Answer the property associated with aKey or, if aKey isn\'t found store the result of evaluating aBlock as new value."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '309' ],		#self : OmReference [ '310' ],		#time : DateAndTime [ '2020-01-07T02:12:42.792626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsent:',			#protocol : #accessing-properties,			#sourceCode : 'propertyAt: aKey ifAbsent: aBlock\r\t"Answer the property value associated with aKey or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t^ properties isNil\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ properties at: aKey ifAbsent: aBlock ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsent:',			#protocol : #'as yet unclassified',			#sourceCode : 'propertyAt: aKey ifAbsent: aBlock\r\t"Answer the property value associated with aKey or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t^ properties isNil\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ properties at: aKey ifAbsent: aBlock ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '310' ],		#self : OmReference [ '311' ],		#time : DateAndTime [ '2020-01-07T02:12:42.793626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:ifAbsent:',			#protocol : #accessing-properties,			#sourceCode : 'propertyAt: aKey ifAbsent: aBlock\r\t"Answer the property value associated with aKey or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t^ properties isNil\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ properties at: aKey ifAbsent: aBlock ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '311' ],		#self : OmReference [ '312' ],		#time : DateAndTime [ '2020-01-07T02:12:42.796626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:',			#protocol : #accessing-properties,			#sourceCode : 'propertyAt: aKey\r\t"Answer the property value associated with aKey."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:',			#protocol : #'as yet unclassified',			#sourceCode : 'propertyAt: aKey\r\t"Answer the property value associated with aKey."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '312' ],		#self : OmReference [ '313' ],		#time : DateAndTime [ '2020-01-07T02:12:42.796626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'propertyAt:',			#protocol : #accessing-properties,			#sourceCode : 'propertyAt: aKey\r\t"Answer the property value associated with aKey."\r\t\r\t^ self propertyAt: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '313' ],		#self : OmReference [ '314' ],		#time : DateAndTime [ '2020-01-07T02:12:42.799626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #properties,			#protocol : #accessing-properties,			#sourceCode : 'properties\r\t^ properties ',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #properties,			#protocol : #'as yet unclassified',			#sourceCode : 'properties\r\t^ properties ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '314' ],		#self : OmReference [ '315' ],		#time : DateAndTime [ '2020-01-07T02:12:42.799626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #properties,			#protocol : #accessing-properties,			#sourceCode : 'properties\r\t^ properties ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '315' ],		#self : OmReference [ '316' ],		#time : DateAndTime [ '2020-01-07T02:12:42.801626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn: aStream.\r\taStream nextPut: $:.\r\taStream nextPut: $ .\r\tstream printOn: aStream',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'printOn: aStream\r\tsuper printOn: aStream.\r\taStream nextPut: $:.\r\taStream nextPut: $ .\r\tstream printOn: aStream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '316' ],		#self : OmReference [ '317' ],		#time : DateAndTime [ '2020-01-07T02:12:42.802626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn: aStream.\r\taStream nextPut: $:.\r\taStream nextPut: $ .\r\tstream printOn: aStream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '317' ],		#self : OmReference [ '318' ],		#time : DateAndTime [ '2020-01-07T02:12:42.804626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContext,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPContext is provides contextual information to the parsing function.\r\rInstance Variables\r\tglobals:\t\t<Dictionary>\r\tproperties:\t\t<Dictionar>\r\troot:\t\t<PPParser>\r\tstream:\t\t<PPStream>\r\rglobals\r\t- properties that are not restored after backtracking\r\rproperties\r\t- properties that are restored after backtracking\r\rroot\r\t- the root parser\r\rstream\r\t- input stream\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #printing	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '318' ],		#self : OmReference [ '319' ],		#time : DateAndTime [ '2020-01-07T02:12:42.805626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #postCopy,			#protocol : #copying,			#sourceCode : 'postCopy\r\tsuper postCopy.\r\tglobals := globals copy.\r\t',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #postCopy,			#protocol : #'as yet unclassified',			#sourceCode : 'postCopy\r\tsuper postCopy.\r\tglobals := globals copy.\r\t',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '319' ],		#self : OmReference [ '320' ],		#time : DateAndTime [ '2020-01-07T02:12:42.806626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #postCopy,			#protocol : #copying,			#sourceCode : 'postCopy\r\tsuper postCopy.\r\tglobals := globals copy.\r\t',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '320' ],		#self : OmReference [ '321' ],		#time : DateAndTime [ '2020-01-07T02:12:42.808626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContext,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPContext is provides contextual information to the parsing function.\r\rInstance Variables\r\tglobals:\t\t<Dictionary>\r\tproperties:\t\t<Dictionar>\r\troot:\t\t<PPParser>\r\tstream:\t\t<PPStream>\r\rglobals\r\t- properties that are not restored after backtracking\r\rproperties\r\t- properties that are restored after backtracking\r\rroot\r\t- the root parser\r\rstream\r\t- input stream\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #copying	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '321' ],		#self : OmReference [ '322' ],		#time : DateAndTime [ '2020-01-07T02:12:42.809626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'position:',			#protocol : #'stream mimicry',			#sourceCode : 'position: anInteger\r\t^ stream position: anInteger',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'position:',			#protocol : #'as yet unclassified',			#sourceCode : 'position: anInteger\r\t^ stream position: anInteger',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '322' ],		#self : OmReference [ '323' ],		#time : DateAndTime [ '2020-01-07T02:12:42.809626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'position:',			#protocol : #'stream mimicry',			#sourceCode : 'position: anInteger\r\t^ stream position: anInteger',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '323' ],		#self : OmReference [ '324' ],		#time : DateAndTime [ '2020-01-07T02:12:42.812626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #position,			#protocol : #'stream mimicry',			#sourceCode : 'position\r\t^ stream position',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #position,			#protocol : #'as yet unclassified',			#sourceCode : 'position\r\t^ stream position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '324' ],		#self : OmReference [ '325' ],		#time : DateAndTime [ '2020-01-07T02:12:42.813626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #position,			#protocol : #'stream mimicry',			#sourceCode : 'position\r\t^ stream position',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '325' ],		#self : OmReference [ '326' ],		#time : DateAndTime [ '2020-01-07T02:12:42.816626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #peekTwice,			#protocol : #'stream mimicry',			#sourceCode : 'peekTwice\r\t^ stream peekTwice',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #peekTwice,			#protocol : #'as yet unclassified',			#sourceCode : 'peekTwice\r\t^ stream peekTwice',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '326' ],		#self : OmReference [ '327' ],		#time : DateAndTime [ '2020-01-07T02:12:42.816626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #peekTwice,			#protocol : #'stream mimicry',			#sourceCode : 'peekTwice\r\t^ stream peekTwice',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '327' ],		#self : OmReference [ '328' ],		#time : DateAndTime [ '2020-01-07T02:12:42.819626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #peek,			#protocol : #'stream mimicry',			#sourceCode : 'peek\r\t^ stream peek',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #peek,			#protocol : #'as yet unclassified',			#sourceCode : 'peek\r\t^ stream peek',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '328' ],		#self : OmReference [ '329' ],		#time : DateAndTime [ '2020-01-07T02:12:42.819626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #peek,			#protocol : #'stream mimicry',			#sourceCode : 'peek\r\t^ stream peek',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '329' ],		#self : OmReference [ '330' ],		#time : DateAndTime [ '2020-01-07T02:12:42.822626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'noteFailure:',			#protocol : #failures,			#sourceCode : 'noteFailure: aPPFailure\r\t"record the furthest failure encountered while parsing the input stream "\r\r\t( furthestFailure isNil or: [ aPPFailure position > furthestFailure position ]) \r\t\tifTrue: [ furthestFailure := aPPFailure ].',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'noteFailure:',			#protocol : #'as yet unclassified',			#sourceCode : 'noteFailure: aPPFailure\r\t"record the furthest failure encountered while parsing the input stream "\r\r\t( furthestFailure isNil or: [ aPPFailure position > furthestFailure position ]) \r\t\tifTrue: [ furthestFailure := aPPFailure ].',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '330' ],		#self : OmReference [ '331' ],		#time : DateAndTime [ '2020-01-07T02:12:42.822626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'noteFailure:',			#protocol : #failures,			#sourceCode : 'noteFailure: aPPFailure\r\t"record the furthest failure encountered while parsing the input stream "\r\r\t( furthestFailure isNil or: [ aPPFailure position > furthestFailure position ]) \r\t\tifTrue: [ furthestFailure := aPPFailure ].',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '331' ],		#self : OmReference [ '332' ],		#time : DateAndTime [ '2020-01-07T02:12:42.826626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'next:',			#protocol : #'stream mimicry',			#sourceCode : 'next: anInteger\r\t^ stream next: anInteger',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'next:',			#protocol : #'as yet unclassified',			#sourceCode : 'next: anInteger\r\t^ stream next: anInteger',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '332' ],		#self : OmReference [ '333' ],		#time : DateAndTime [ '2020-01-07T02:12:42.826626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'next:',			#protocol : #'stream mimicry',			#sourceCode : 'next: anInteger\r\t^ stream next: anInteger',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '333' ],		#self : OmReference [ '334' ],		#time : DateAndTime [ '2020-01-07T02:12:42.829626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #next,			#protocol : #'stream mimicry',			#sourceCode : 'next\r\t^ stream next',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #next,			#protocol : #'as yet unclassified',			#sourceCode : 'next\r\t^ stream next',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '334' ],		#self : OmReference [ '335' ],		#time : DateAndTime [ '2020-01-07T02:12:42.829626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #next,			#protocol : #'stream mimicry',			#sourceCode : 'next\r\t^ stream next',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '335' ],		#self : OmReference [ '336' ],		#time : DateAndTime [ '2020-01-07T02:12:42.832626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #isStartOfLine,			#protocol : #'stream mimicry',			#sourceCode : 'isStartOfLine\r\t^ stream isStartOfLine',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #isStartOfLine,			#protocol : #'as yet unclassified',			#sourceCode : 'isStartOfLine\r\t^ stream isStartOfLine',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '336' ],		#self : OmReference [ '337' ],		#time : DateAndTime [ '2020-01-07T02:12:42.832626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #isStartOfLine,			#protocol : #'stream mimicry',			#sourceCode : 'isStartOfLine\r\t^ stream isStartOfLine',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '337' ],		#self : OmReference [ '338' ],		#time : DateAndTime [ '2020-01-07T02:12:42.836626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #isEndOfLine,			#protocol : #'stream mimicry',			#sourceCode : 'isEndOfLine\r\t^ stream isEndOfLine',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #isEndOfLine,			#protocol : #'as yet unclassified',			#sourceCode : 'isEndOfLine\r\t^ stream isEndOfLine',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '338' ],		#self : OmReference [ '339' ],		#time : DateAndTime [ '2020-01-07T02:12:42.836626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #isEndOfLine,			#protocol : #'stream mimicry',			#sourceCode : 'isEndOfLine\r\t^ stream isEndOfLine',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '339' ],		#self : OmReference [ '340' ],		#time : DateAndTime [ '2020-01-07T02:12:42.839626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'initializeFor:',			#protocol : #initialization,			#sourceCode : 'initializeFor: parser\r\troot := parser.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'initializeFor:',			#protocol : #'as yet unclassified',			#sourceCode : 'initializeFor: parser\r\troot := parser.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '340' ],		#self : OmReference [ '341' ],		#time : DateAndTime [ '2020-01-07T02:12:42.840626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'initializeFor:',			#protocol : #initialization,			#sourceCode : 'initializeFor: parser\r\troot := parser.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '341' ],		#self : OmReference [ '342' ],		#time : DateAndTime [ '2020-01-07T02:12:42.843626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tstream := nil.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r\tstream := nil.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '342' ],		#self : OmReference [ '343' ],		#time : DateAndTime [ '2020-01-07T02:12:42.843626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tstream := nil.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '343' ],		#self : OmReference [ '344' ],		#time : DateAndTime [ '2020-01-07T02:12:42.846626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContext,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPContext is provides contextual information to the parsing function.\r\rInstance Variables\r\tglobals:\t\t<Dictionary>\r\tproperties:\t\t<Dictionar>\r\troot:\t\t<PPParser>\r\tstream:\t\t<PPStream>\r\rglobals\r\t- properties that are not restored after backtracking\r\rproperties\r\t- properties that are restored after backtracking\r\rroot\r\t- the root parser\r\rstream\r\t- input stream\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #initialization	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '344' ],		#self : OmReference [ '345' ],		#time : DateAndTime [ '2020-01-07T02:12:42.847626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #identifier,			#protocol : #memoization,			#sourceCode : 'identifier\r\t"\r\t\tI provide an identifier that is used by memoizing parser to figure out if the\r\t\tcache should be flushed or not.\r\t"\r\t^ stream',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #identifier,			#protocol : #'as yet unclassified',			#sourceCode : 'identifier\r\t"\r\t\tI provide an identifier that is used by memoizing parser to figure out if the\r\t\tcache should be flushed or not.\r\t"\r\t^ stream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '345' ],		#self : OmReference [ '346' ],		#time : DateAndTime [ '2020-01-07T02:12:42.847626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #identifier,			#protocol : #memoization,			#sourceCode : 'identifier\r\t"\r\t\tI provide an identifier that is used by memoizing parser to figure out if the\r\t\tcache should be flushed or not.\r\t"\r\t^ stream',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '346' ],		#self : OmReference [ '347' ],		#time : DateAndTime [ '2020-01-07T02:12:42.849626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContext,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPContext is provides contextual information to the parsing function.\r\rInstance Variables\r\tglobals:\t\t<Dictionary>\r\tproperties:\t\t<Dictionar>\r\troot:\t\t<PPParser>\r\tstream:\t\t<PPStream>\r\rglobals\r\t- properties that are not restored after backtracking\r\rproperties\r\t- properties that are restored after backtracking\r\rroot\r\t- the root parser\r\rstream\r\t- input stream\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #memoization	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '347' ],		#self : OmReference [ '348' ],		#time : DateAndTime [ '2020-01-07T02:12:42.850626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'hasProperty:',			#protocol : #accessing-properties,			#sourceCode : 'hasProperty: aKey\r\t"Test if the property aKey is present."\r\t\r\t^ properties notNil and: [ properties includesKey: aKey ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'hasProperty:',			#protocol : #'as yet unclassified',			#sourceCode : 'hasProperty: aKey\r\t"Test if the property aKey is present."\r\t\r\t^ properties notNil and: [ properties includesKey: aKey ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '348' ],		#self : OmReference [ '349' ],		#time : DateAndTime [ '2020-01-07T02:12:42.850626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'hasProperty:',			#protocol : #accessing-properties,			#sourceCode : 'hasProperty: aKey\r\t"Test if the property aKey is present."\r\t\r\t^ properties notNil and: [ properties includesKey: aKey ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '349' ],		#self : OmReference [ '350' ],		#time : DateAndTime [ '2020-01-07T02:12:42.853626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContext,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPContext is provides contextual information to the parsing function.\r\rInstance Variables\r\tglobals:\t\t<Dictionary>\r\tproperties:\t\t<Dictionar>\r\troot:\t\t<PPParser>\r\tstream:\t\t<PPStream>\r\rglobals\r\t- properties that are not restored after backtracking\r\rproperties\r\t- properties that are restored after backtracking\r\rroot\r\t- the root parser\r\rstream\r\t- input stream\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #accessing-properties	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '350' ],		#self : OmReference [ '351' ],		#time : DateAndTime [ '2020-01-07T02:12:42.854626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'hasGlobal:',			#protocol : #accessing-globals,			#sourceCode : 'hasGlobal: aKey\r\t"Test if the global property aKey is present."\r\t\r\t^ globals notNil and: [ globals includesKey: aKey ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'hasGlobal:',			#protocol : #'as yet unclassified',			#sourceCode : 'hasGlobal: aKey\r\t"Test if the global property aKey is present."\r\t\r\t^ globals notNil and: [ globals includesKey: aKey ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '351' ],		#self : OmReference [ '352' ],		#time : DateAndTime [ '2020-01-07T02:12:42.854626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'hasGlobal:',			#protocol : #accessing-globals,			#sourceCode : 'hasGlobal: aKey\r\t"Test if the global property aKey is present."\r\t\r\t^ globals notNil and: [ globals includesKey: aKey ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '352' ],		#self : OmReference [ '353' ],		#time : DateAndTime [ '2020-01-07T02:12:42.857626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #globals,			#protocol : #accessing-globals,			#sourceCode : 'globals\r\t^ globals',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #globals,			#protocol : #'as yet unclassified',			#sourceCode : 'globals\r\t^ globals',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '353' ],		#self : OmReference [ '354' ],		#time : DateAndTime [ '2020-01-07T02:12:42.858626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #globals,			#protocol : #accessing-globals,			#sourceCode : 'globals\r\t^ globals',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '354' ],		#self : OmReference [ '355' ],		#time : DateAndTime [ '2020-01-07T02:12:42.860626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:put:',			#protocol : #accessing-globals,			#sourceCode : 'globalAt: aKey put: anObject\r\t"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."\r\r\t^ (globals ifNil: [ globals := Dictionary new: 1 ])\r\t\tat: aKey put: anObject',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'globalAt: aKey put: anObject\r\t"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."\r\r\t^ (globals ifNil: [ globals := Dictionary new: 1 ])\r\t\tat: aKey put: anObject',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '355' ],		#self : OmReference [ '356' ],		#time : DateAndTime [ '2020-01-07T02:12:42.861626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:put:',			#protocol : #accessing-globals,			#sourceCode : 'globalAt: aKey put: anObject\r\t"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."\r\r\t^ (globals ifNil: [ globals := Dictionary new: 1 ])\r\t\tat: aKey put: anObject',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '356' ],		#self : OmReference [ '357' ],		#time : DateAndTime [ '2020-01-07T02:12:42.864626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:ifAbsentPut:',			#protocol : #accessing-globals,			#sourceCode : 'globalAt: aKey ifAbsentPut: aBlock\r\t"Answer the global property associated with aKey or, if aKey isn\'t found store the result of evaluating aBlock as new value."\r\t\r\t^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:ifAbsentPut:',			#protocol : #'as yet unclassified',			#sourceCode : 'globalAt: aKey ifAbsentPut: aBlock\r\t"Answer the global property associated with aKey or, if aKey isn\'t found store the result of evaluating aBlock as new value."\r\t\r\t^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '357' ],		#self : OmReference [ '358' ],		#time : DateAndTime [ '2020-01-07T02:12:42.864626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:ifAbsentPut:',			#protocol : #accessing-globals,			#sourceCode : 'globalAt: aKey ifAbsentPut: aBlock\r\t"Answer the global property associated with aKey or, if aKey isn\'t found store the result of evaluating aBlock as new value."\r\t\r\t^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '358' ],		#self : OmReference [ '359' ],		#time : DateAndTime [ '2020-01-07T02:12:42.867626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:ifAbsent:',			#protocol : #accessing-globals,			#sourceCode : 'globalAt: aKey ifAbsent: aBlock\r\t"Answer the global property value associated with aKey or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t^ globals isNil\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ globals at: aKey ifAbsent: aBlock ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:ifAbsent:',			#protocol : #'as yet unclassified',			#sourceCode : 'globalAt: aKey ifAbsent: aBlock\r\t"Answer the global property value associated with aKey or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t^ globals isNil\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ globals at: aKey ifAbsent: aBlock ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '359' ],		#self : OmReference [ '360' ],		#time : DateAndTime [ '2020-01-07T02:12:42.867626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:ifAbsent:',			#protocol : #accessing-globals,			#sourceCode : 'globalAt: aKey ifAbsent: aBlock\r\t"Answer the global property value associated with aKey or, if aKey isn\'t found, answer the result of evaluating aBlock."\r\t\r\t^ globals isNil\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ globals at: aKey ifAbsent: aBlock ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '360' ],		#self : OmReference [ '361' ],		#time : DateAndTime [ '2020-01-07T02:12:42.870626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:',			#protocol : #accessing-globals,			#sourceCode : 'globalAt: aKey\r\t"Answer the global property value associated with aKey."\r\t\r\t^ self globalAt: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:',			#protocol : #'as yet unclassified',			#sourceCode : 'globalAt: aKey\r\t"Answer the global property value associated with aKey."\r\t\r\t^ self globalAt: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '361' ],		#self : OmReference [ '362' ],		#time : DateAndTime [ '2020-01-07T02:12:42.870626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #'globalAt:',			#protocol : #accessing-globals,			#sourceCode : 'globalAt: aKey\r\t"Answer the global property value associated with aKey."\r\t\r\t^ self globalAt: aKey ifAbsent: [ self error: \'Property not found\' ]',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '362' ],		#self : OmReference [ '363' ],		#time : DateAndTime [ '2020-01-07T02:12:42.872626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContext,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPContext is provides contextual information to the parsing function.\r\rInstance Variables\r\tglobals:\t\t<Dictionary>\r\tproperties:\t\t<Dictionar>\r\troot:\t\t<PPParser>\r\tstream:\t\t<PPStream>\r\rglobals\r\t- properties that are not restored after backtracking\r\rproperties\r\t- properties that are restored after backtracking\r\rroot\r\t- the root parser\r\rstream\r\t- input stream\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #accessing-globals	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '363' ],		#self : OmReference [ '364' ],		#time : DateAndTime [ '2020-01-07T02:12:42.874626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #furthestFailure,			#protocol : #failures,			#sourceCode : 'furthestFailure\r\t" the furthest failure encountered while parsing the input stream "\r\t\r\t"^ self globalAt: #furthestFailure ifAbsent: [ nil ]"\r\t"performance optimization:"\r\t^ furthestFailure',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #furthestFailure,			#protocol : #'as yet unclassified',			#sourceCode : 'furthestFailure\r\t" the furthest failure encountered while parsing the input stream "\r\t\r\t"^ self globalAt: #furthestFailure ifAbsent: [ nil ]"\r\t"performance optimization:"\r\t^ furthestFailure',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '364' ],		#self : OmReference [ '365' ],		#time : DateAndTime [ '2020-01-07T02:12:42.874626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #furthestFailure,			#protocol : #failures,			#sourceCode : 'furthestFailure\r\t" the furthest failure encountered while parsing the input stream "\r\t\r\t"^ self globalAt: #furthestFailure ifAbsent: [ nil ]"\r\t"performance optimization:"\r\t^ furthestFailure',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '365' ],		#self : OmReference [ '366' ],		#time : DateAndTime [ '2020-01-07T02:12:42.876626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContext,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPContext is provides contextual information to the parsing function.\r\rInstance Variables\r\tglobals:\t\t<Dictionary>\r\tproperties:\t\t<Dictionar>\r\troot:\t\t<PPParser>\r\tstream:\t\t<PPStream>\r\rglobals\r\t- properties that are not restored after backtracking\r\rproperties\r\t- properties that are restored after backtracking\r\rroot\r\t- the root parser\r\rstream\r\t- input stream\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #failures	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '366' ],		#self : OmReference [ '367' ],		#time : DateAndTime [ '2020-01-07T02:12:42.877626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #contents,			#protocol : #'stream mimicry',			#sourceCode : 'contents \r\t^ stream contents',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #contents,			#protocol : #'as yet unclassified',			#sourceCode : 'contents \r\t^ stream contents',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '367' ],		#self : OmReference [ '368' ],		#time : DateAndTime [ '2020-01-07T02:12:42.878626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #contents,			#protocol : #'stream mimicry',			#sourceCode : 'contents \r\t^ stream contents',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '368' ],		#self : OmReference [ '369' ],		#time : DateAndTime [ '2020-01-07T02:12:42.880626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #collection,			#protocol : #'stream mimicry',			#sourceCode : 'collection\r\t^ stream collection  ',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #collection,			#protocol : #'as yet unclassified',			#sourceCode : 'collection\r\t^ stream collection  ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '369' ],		#self : OmReference [ '370' ],		#time : DateAndTime [ '2020-01-07T02:12:42.881626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #collection,			#protocol : #'stream mimicry',			#sourceCode : 'collection\r\t^ stream collection  ',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '370' ],		#self : OmReference [ '371' ],		#time : DateAndTime [ '2020-01-07T02:12:42.884626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #back,			#protocol : #'stream mimicry',			#sourceCode : 'back\r\t^ stream back',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #back,			#protocol : #'as yet unclassified',			#sourceCode : 'back\r\t^ stream back',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '371' ],		#self : OmReference [ '372' ],		#time : DateAndTime [ '2020-01-07T02:12:42.884626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #back,			#protocol : #'stream mimicry',			#sourceCode : 'back\r\t^ stream back',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '372' ],		#self : OmReference [ '373' ],		#time : DateAndTime [ '2020-01-07T02:12:42.887626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #atEnd,			#protocol : #'stream mimicry',			#sourceCode : 'atEnd\r\t^ stream atEnd',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #atEnd,			#protocol : #'as yet unclassified',			#sourceCode : 'atEnd\r\t^ stream atEnd',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '373' ],		#self : OmReference [ '374' ],		#time : DateAndTime [ '2020-01-07T02:12:42.887626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPContext,				#isMetaSide : false			},			#name : #atEnd,			#protocol : #'stream mimicry',			#sourceCode : 'atEnd\r\t^ stream atEnd',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '374' ],		#self : OmReference [ '375' ],		#time : DateAndTime [ '2020-01-07T02:12:42.889626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'PPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPContext,					#isMetaSide : false				},				#parent : @8,				#content : 'A PPContext is provides contextual information to the parsing function.\r\rInstance Variables\r\tglobals:\t\t<Dictionary>\r\tproperties:\t\t<Dictionar>\r\troot:\t\t<PPParser>\r\tstream:\t\t<PPStream>\r\rglobals\r\t- properties that are not restored after backtracking\r\rproperties\r\t- properties that are restored after backtracking\r\rroot\r\t- the root parser\r\rstream\r\t- input stream\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#protocol : #'stream mimicry'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '375' ],		#self : OmReference [ '376' ],		#time : DateAndTime [ '2020-01-07T02:12:42.890626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPContext class',				#isMetaSide : true			},			#name : #'on:stream:',			#protocol : #'as yet unclassified',			#sourceCode : 'on: aPPParser stream: aStream\r\t^ self basicNew \r\t\tinitialize;\r\t\troot: aPPParser;\r\t\tstream: aStream asPetitStream;\r\t\tyourself',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '376' ],		#self : OmReference [ '377' ],		#time : DateAndTime [ '2020-01-07T02:12:42.963626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPContext\r\tinstanceVariableNames: \'stream root properties globals furthestFailure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'PetitParser-Core\'',				#superclassName : 'Object'			},			#name : #PPContext,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContext,						#isMetaSide : false					},					#name : #stream,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContext,						#isMetaSide : false					},					#name : #root,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContext,						#isMetaSide : false					},					#name : #properties,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContext,						#isMetaSide : false					},					#name : #globals,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoletePPContext,						#isMetaSide : false					},					#name : #furthestFailure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPContext class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoletePPContext class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoletePPContext,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Core,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '377' ],		#self : OmReference [ '378' ],		#time : DateAndTime [ '2020-01-07T02:12:42.965626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #startOfWord,			#protocol : #factory-objects,			#sourceCode : 'startOfWord\r\t\r\t^ PPStartOfWordParser new.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #startOfWord,			#protocol : #'as yet unclassified',			#sourceCode : 'startOfWord\r\t\r\t^ PPStartOfWordParser new.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '378' ],		#self : OmReference [ '379' ],		#time : DateAndTime [ '2020-01-07T02:12:42.966626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #startOfWord,			#protocol : #factory-objects,			#sourceCode : 'startOfWord\r\t\r\t^ PPStartOfWordParser new.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '379' ],		#self : OmReference [ '380' ],		#time : DateAndTime [ '2020-01-07T02:12:42.969626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #startOfLogicalLine,			#protocol : #factory-objects,			#sourceCode : 'startOfLogicalLine\r\t\r\t^ PPStartOfLogicalLineParser new.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #startOfLogicalLine,			#protocol : #'as yet unclassified',			#sourceCode : 'startOfLogicalLine\r\t\r\t^ PPStartOfLogicalLineParser new.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '380' ],		#self : OmReference [ '381' ],		#time : DateAndTime [ '2020-01-07T02:12:42.969626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #startOfLogicalLine,			#protocol : #factory-objects,			#sourceCode : 'startOfLogicalLine\r\t\r\t^ PPStartOfLogicalLineParser new.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '381' ],		#self : OmReference [ '382' ],		#time : DateAndTime [ '2020-01-07T02:12:42.973626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #startOfLine,			#protocol : #factory-objects,			#sourceCode : 'startOfLine\r\t\r\t^ PPStartOfLineParser new.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #startOfLine,			#protocol : #'as yet unclassified',			#sourceCode : 'startOfLine\r\t\r\t^ PPStartOfLineParser new.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '382' ],		#self : OmReference [ '383' ],		#time : DateAndTime [ '2020-01-07T02:12:42.973626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #startOfLine,			#protocol : #factory-objects,			#sourceCode : 'startOfLine\r\t\r\t^ PPStartOfLineParser new.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '383' ],		#self : OmReference [ '384' ],		#time : DateAndTime [ '2020-01-07T02:12:42.977626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #eof,			#protocol : #factory-objects,			#sourceCode : 'eof\r\t\r\t^ PPEndOfFileParser new',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #eof,			#protocol : #'as yet unclassified',			#sourceCode : 'eof\r\t\r\t^ PPEndOfFileParser new',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '384' ],		#self : OmReference [ '385' ],		#time : DateAndTime [ '2020-01-07T02:12:42.977626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #eof,			#protocol : #factory-objects,			#sourceCode : 'eof\r\t\r\t^ PPEndOfFileParser new',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '385' ],		#self : OmReference [ '386' ],		#time : DateAndTime [ '2020-01-07T02:12:42.981626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #endOfLine,			#protocol : #factory-objects,			#sourceCode : 'endOfLine\r\t\r\t^ PPEndOfLineParser new.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #endOfLine,			#protocol : #'as yet unclassified',			#sourceCode : 'endOfLine\r\t\r\t^ PPEndOfLineParser new.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '386' ],		#self : OmReference [ '387' ],		#time : DateAndTime [ '2020-01-07T02:12:42.981626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #endOfLine,			#protocol : #factory-objects,			#sourceCode : 'endOfLine\r\t\r\t^ PPEndOfLineParser new.',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '387' ],		#self : OmReference [ '388' ],		#time : DateAndTime [ '2020-01-07T02:12:42.985626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #'cacheAt:ifAbsentPut:',			#protocol : #cache,			#sourceCode : 'cacheAt: aSymbol ifAbsentPut: aBlock\r\r\tcache ifNil: [ cache := Dictionary new ].\r\t^(cache\r\t\tat: aSymbol\r\t\tifAbsentPut: aBlock) copy',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #'cacheAt:ifAbsentPut:',			#protocol : #'as yet unclassified',			#sourceCode : 'cacheAt: aSymbol ifAbsentPut: aBlock\r\r\tcache ifNil: [ cache := Dictionary new ].\r\t^(cache\r\t\tat: aSymbol\r\t\tifAbsentPut: aBlock) copy',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '388' ],		#self : OmReference [ '389' ],		#time : DateAndTime [ '2020-01-07T02:12:42.985626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #'cacheAt:ifAbsentPut:',			#protocol : #cache,			#sourceCode : 'cacheAt: aSymbol ifAbsentPut: aBlock\r\r\tcache ifNil: [ cache := Dictionary new ].\r\t^(cache\r\t\tat: aSymbol\r\t\tifAbsentPut: aBlock) copy',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '389' ],		#self : OmReference [ '390' ],		#time : DateAndTime [ '2020-01-07T02:12:42.988626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGMetaclassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPPredicateObjectParser class\r\tinstanceVariableNames: \'\''			},			#name : #'PPPredicateObjectParser class',			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#baseClass : RGClassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPPredicateParser subclass: #PPPredicateObjectParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Parsers\'',					#superclassName : 'PPPredicateParser'				},				#name : #PPPredicateObjectParser,				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#metaClass : @8,				#comment : RGCommentDefinition {					#annotations : IdentityDictionary {						#className : #PPPredicateObjectParser,						#isMetaSide : false					},					#parent : @13,					#content : 'A parser that accepts if a given predicate on one element of the input sequence holds.',					#stamp : ''				},				#classVariables : OrderedCollection [ ],				#category : #PetitParser-Parsers,				#package : #PetitParser,				#sharedPools : OrderedCollection [ ]			}		},		#protocol : #cache	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '390' ],		#self : OmReference [ '391' ],		#time : DateAndTime [ '2020-01-07T02:12:42.989626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemento,				#isMetaSide : false			},			#name : #'contextMemento:',			#protocol : #accessing,			#sourceCode : 'contextMemento: aPPContextMemento\r\tcontext  := aPPContextMemento \r',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemento,				#isMetaSide : false			},			#name : #'contextMemento:',			#protocol : #'as yet unclassified',			#sourceCode : 'contextMemento: aPPContextMemento\r\tcontext  := aPPContextMemento \r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '391' ],		#self : OmReference [ '392' ],		#time : DateAndTime [ '2020-01-07T02:12:42.989626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemento,				#isMetaSide : false			},			#name : #'contextMemento:',			#protocol : #accessing,			#sourceCode : 'contextMemento: aPPContextMemento\r\tcontext  := aPPContextMemento \r',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '392' ],		#self : OmReference [ '393' ],		#time : DateAndTime [ '2020-01-07T02:12:42.992626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemento,				#isMetaSide : false			},			#name : #contextMemento,			#protocol : #accessing,			#sourceCode : 'contextMemento\r\t^ context',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemento,				#isMetaSide : false			},			#name : #contextMemento,			#protocol : #'as yet unclassified',			#sourceCode : 'contextMemento\r\t^ context',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '393' ],		#self : OmReference [ '394' ],		#time : DateAndTime [ '2020-01-07T02:12:42.993626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemento,				#isMetaSide : false			},			#name : #contextMemento,			#protocol : #accessing,			#sourceCode : 'contextMemento\r\t^ context',			#stamp : '',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '394' ],		#self : OmReference [ '395' ],		#time : DateAndTime [ '2020-01-07T02:12:42.995626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpCategoryRemoval {		#classCategoryName : 'PetitTests',		#affectedPackageName : #PetitTests	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '395' ],		#self : OmReference [ '396' ],		#time : DateAndTime [ '2020-01-07T02:12:42.996626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpCategoryRemoval {		#classCategoryName : 'PetitParser',		#affectedPackageName : #PetitParser	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '396' ],		#self : OmReference [ '397' ],		#time : DateAndTime [ '2020-01-07T02:12:43.010626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTrimmingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| memento element trimContext |\r\tmemento := aPPContext remember.\r\ttrimContext := aPPContext copy.\r\t[ (trimmer parseOn: trimContext) isPetitFailure ]\r\t\twhileFalse.\r\telement := parser parseOn: aPPContext.\r\telement isPetitFailure ifTrue: [\r\t\taPPContext restore: memento.\r\t\t^ element ].\r\t[ (trimmer parseOn: trimContext) isPetitFailure ]\r\t\twhileFalse.\r\t^ element',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTrimmingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| position element |\r\tposition := aStream position.\r\t[ (trimmer parseOn: aStream) isPetitFailure ]\r\t\twhileFalse.\r\telement := parser parseOn: aStream.\r\telement isPetitFailure ifTrue: [\r\t\taStream position: position.\r\t\t^ element ].\r\t[ (trimmer parseOn: aStream) isPetitFailure ]\r\t\twhileFalse.\r\t^ element',			#stamp : 'lr 8/1/2010 17:11',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '397' ],		#self : OmReference [ '398' ],		#time : DateAndTime [ '2020-01-07T02:12:43.020626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPGreedyRepeatingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| memento element elements positions |\r\tmemento := aPPContext remember.\r\telements := OrderedCollection new.\r\t[ elements size < min ] whileTrue: [ \r\t\t(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [ \r\t\t\taPPContext restore: memento.\r\t\t\t^ element ].\r\t\telements addLast: element ].\r\tpositions := OrderedCollection with: aPPContext remember.\r\t[ elements size < max and: [ (element := parser parseOn: aPPContext) isPetitFailure not ] ] whileTrue: [\r\t\telements addLast: element.\r\t\tpositions addLast: aPPContext remember ].\r\t[ positions isEmpty ] whileFalse: [\r\t\taPPContext restore: positions last.\r\t\telement := limit parseOn: aPPContext.\r\t\telement isPetitFailure ifFalse: [\r\t\t\taPPContext restore: positions last.\r\t\t\t^ elements asArray ].\r\t\telements isEmpty ifTrue: [\r\t\t\taPPContext restore: memento.\r\t\t\t^ element ].\r\t\telements removeLast.\r\t\tpositions removeLast ].\r\taPPContext restore: memento.\r\t^ PPFailure message: \'overflow\' context: aPPContext at: memento position',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPGreedyRepeatingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| start element elements positions |\r\tstart := aStream position.\r\telements := OrderedCollection new.\r\t[ elements size < min ] whileTrue: [ \r\t\t(element := parser parseOn: aStream) isPetitFailure ifTrue: [ \r\t\t\taStream position: start.\r\t\t\t^ element ].\r\t\telements addLast: element ].\r\tpositions := OrderedCollection with: aStream position.\r\t[ elements size < max and: [ (element := parser parseOn: aStream) isPetitFailure not ] ] whileTrue: [\r\t\telements addLast: element.\r\t\tpositions addLast: aStream position ].\r\t[ positions isEmpty ] whileFalse: [\r\t\taStream position: positions last.\r\t\telement := limit parseOn: aStream.\r\t\telement isPetitFailure ifFalse: [\r\t\t\taStream position: positions last.\r\t\t\t^ elements asArray ].\r\t\telements isEmpty ifTrue: [\r\t\t\taStream position: start.\r\t\t\t^ element ].\r\t\telements removeLast.\r\t\tpositions removeLast ].\r\taStream position: start.\r\t^ PPFailure message: \'overflow\' at: start',			#stamp : 'lr 4/2/2011 15:54',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '398' ],		#self : OmReference [ '399' ],		#time : DateAndTime [ '2020-01-07T02:12:43.022626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPSequenceParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t"This is optimized code that avoids unnecessary block activations, do not change."\r\t\r\t| memento elements element |\r\tmemento := aPPContext remember.\r\telements := Array new: parsers size.\r\t1 to: parsers size do: [ :index |\r\t\telement := (parsers at: index) \r\t\t\tparseOn: aPPContext.\r\t\telement isPetitFailure ifTrue: [\r\t\t\taPPContext restore: memento.\r\t\t\t^ element ].\r\t\telements at: index put: element ].\r\t^ elements',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPSequenceParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t"This is optimized code that avoids unnecessary block activations, do not change."\r\t\r\t| start elements element |\r\tstart := aStream position.\r\telements := Array new: parsers size.\r\t1 to: parsers size do: [ :index |\r\t\telement := (parsers at: index) \r\t\t\tparseOn: aStream.\r\t\telement isPetitFailure ifTrue: [\r\t\t\taStream position: start.\r\t\t\t^ element ].\r\t\telements at: index put: element ].\r\t^ elements',			#stamp : 'lr 5/6/2010 10:47',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '399' ],		#self : OmReference [ '400' ],		#time : DateAndTime [ '2020-01-07T02:12:43.024626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testAction,			#protocol : #testing-mapping,			#sourceCode : 'testAction\r\t| block parser |\r\tblock := [ :char | char asUppercase ].\r\tparser := #any asParser ==> block.\r\tself assert: parser block equals: block.\r\tself assert: parser parse: \'a\' to: $A.\r\tself assert: parser parse: \'b\' to: $B',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testAction,			#protocol : #testing-mapping,			#sourceCode : 'testAction\r\t| block parser |\r\tblock := [ :char | char asUppercase ].\r\tparser := #any asParser ==> block.\r\tself assert: parser block = block.\r\r\tself assert: parser parse: \'a\' to: $A.\r\tself assert: parser parse: \'b\' to: $B',			#stamp : 'lr 5/2/2010 12:22',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '400' ],		#self : OmReference [ '401' ],		#time : DateAndTime [ '2020-01-07T02:12:43.025626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testAnd,			#protocol : #testing,			#sourceCode : 'testAnd\r\t| parser |\r\tparser := \'foo\' asParser flatten , \'bar\' asParser flatten and.\r\tself\r\t\tassert: parser\r\t\tparse: \'foobar\'\r\t\tto: #(\'foo\' \'bar\')\r\t\tend: 3.\r\tself assert: parser fail: \'foobaz\'.\r\tparser := \'foo\' asParser and.\r\tself assert: parser and equals: parser',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testAnd,			#protocol : #testing,			#sourceCode : 'testAnd\r\t| parser |\r\tparser := \'foo\' asParser flatten , \'bar\' asParser flatten and.\r\t\r\tself assert: parser parse: \'foobar\' to: #(\'foo\' \'bar\') end: 3.\r\tself assert: parser fail: \'foobaz\'.\r\t\r\tparser := \'foo\' asParser and.\r\tself assert: parser and = parser',			#stamp : 'lr 6/24/2011 06:15',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '401' ],		#self : OmReference [ '402' ],		#time : DateAndTime [ '2020-01-07T02:12:43.027626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testChildren,			#protocol : #testing-utilities,			#sourceCode : 'testChildren\r\t| p1 p2 p3 |\r\tp1 := #lowercase asParser.\r\tp2 := p1 ==> #asUppercase.\r\tp3 := PPUnresolvedParser new.\r\tp3 def: p2 / p3.\r\tself assert: p1 children isEmpty.\r\tself assert: p2 children size equals: 1.\r\tself assert: p3 children size equals: 2',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testChildren,			#protocol : #testing-utilities,			#sourceCode : 'testChildren\r\t| p1 p2 p3 |\r\tp1 := #lowercase asParser.\r\tp2 := p1 ==> #asUppercase.\r\tp3 := PPUnresolvedParser new.\r\tp3 def: p2 / p3.\r\tself assert: p1 children isEmpty.\r\tself assert: p2 children size = 1.\r\tself assert: p3 children size = 2',			#stamp : 'lr 2/7/2010 22:15',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '402' ],		#self : OmReference [ '403' ],		#time : DateAndTime [ '2020-01-07T02:12:43.029626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testEndOfInput,			#protocol : #testing,			#sourceCode : 'testEndOfInput\r\t| parser |\r\tparser := PPEndOfInputParser on: $a asParser.\r\tself assert: parser end equals: parser.\r\tself assert: parser parse: \'a\' to: $a.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'aa\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testEndOfInput,			#protocol : #testing,			#sourceCode : 'testEndOfInput\r\t| parser |\r\tparser := PPEndOfInputParser on: $a asParser.\r\tself assert: parser end = parser.\r\t\r\tself assert: parser parse: \'a\' to: $a.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'aa\'',			#stamp : 'lr 1/29/2010 11:39',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '403' ],		#self : OmReference [ '404' ],		#time : DateAndTime [ '2020-01-07T02:12:43.031626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testFailing,			#protocol : #testing,			#sourceCode : 'testFailing\r\t| parser result |\r\tparser := PPFailingParser message: \'Plonk\'.\r\tself assert: parser message equals: \'Plonk\'.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'aa\'.\r\tresult := parser parse: \'a\'.\r\tself assert: result message equals: \'Plonk\'.\r\tself assert: result printString equals: \'Plonk at 0\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testFailing,			#protocol : #testing,			#sourceCode : 'testFailing\r\t| parser result |\r\tparser := PPFailingParser message: \'Plonk\'.\r\tself assert: parser message = \'Plonk\'.\r\t\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'aa\'.\r\t\r\tresult := parser parse: \'a\'.\r\tself assert: result message = \'Plonk\'.\r\tself assert: result printString = \'Plonk at 0\'',			#stamp : 'lr 5/5/2010 14:10',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '404' ],		#self : OmReference [ '405' ],		#time : DateAndTime [ '2020-01-07T02:12:43.033626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testFailure,			#protocol : #testing-utilities,			#sourceCode : 'testFailure\r\t| failure |\r\tfailure := PPFailure message: \'Error\' context: PPContext new at: 3.\r\tself assert: failure message equals: \'Error\'.\r\tself assert: failure position equals: 3.\r\tself assert: failure isPetitFailure.\r\tself deny: 4 isPetitFailure.\r\tself deny: \'foo\' isPetitFailure',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testFailure,			#protocol : #testing-utilities,			#sourceCode : 'testFailure\r\t| failure |\r\tfailure := PPFailure message: \'Error\' at: 3.\r\t\r\tself assert: failure message = \'Error\'.\r\tself assert: failure position = 3.\r\tself assert: failure isPetitFailure.\r\r\tself deny: 4 isPetitFailure.\r\tself deny: \'foo\' isPetitFailure',			#stamp : 'lr 5/5/2010 13:58',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '405' ],		#self : OmReference [ '406' ],		#time : DateAndTime [ '2020-01-07T02:12:43.035626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testListConstructor,			#protocol : #testing-utilities,			#sourceCode : 'testListConstructor\r\t| p1 p2 p3 |\r\tp1 := PPChoiceParser with: $a asParser.\r\tp2 := PPChoiceParser with: $a asParser with: $b asParser.\r\tp3 := PPChoiceParser withAll: (Array with: $a asParser with: $b asParser with: $c asParser).\r\tself assert: p1 children size equals: 1.\r\tself assert: p2 children size equals: 2.\r\tself assert: p3 children size equals: 3',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testListConstructor,			#protocol : #testing-utilities,			#sourceCode : 'testListConstructor\r\t| p1 p2 p3 |\r\tp1 := PPChoiceParser with: $a asParser.\r\tp2 := PPChoiceParser with: $a asParser with: $b asParser.\r\tp3 := PPChoiceParser withAll: (Array with: $a asParser with: $b asParser with: $c asParser).\r\t\r\tself assert: p1 children size = 1.\r\tself assert: p2 children size = 2.\r\tself assert: p3 children size = 3',			#stamp : 'lr 5/31/2010 19:27',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '406' ],		#self : OmReference [ '407' ],		#time : DateAndTime [ '2020-01-07T02:12:43.038626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testLiteralObject,			#protocol : #testing,			#sourceCode : 'testLiteralObject\r\t| parser |\r\tparser := PPLiteralObjectParser on: $a message: \'letter "a" expected\'.\r\tself assert: parser literal equals: $a.\r\tself assert: parser message equals: \'letter "a" expected\'.\r\tself assert: parser parse: \'a\' to: $a.\r\tself assert: parser fail: \'b\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testLiteralObject,			#protocol : #testing,			#sourceCode : 'testLiteralObject\r\t| parser |\r\tparser := PPLiteralObjectParser \r\t\ton: $a\r\t\tmessage: \'letter "a" expected\'.\r\tself assert: parser literal = $a.\r\tself assert: parser message = \'letter "a" expected\'.\r\t\r\tself assert: parser parse: \'a\' to: $a.\r\tself assert: parser fail: \'b\'\r\t',			#stamp : 'lr 5/2/2010 18:20',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '407' ],		#self : OmReference [ '408' ],		#time : DateAndTime [ '2020-01-07T02:12:43.041626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testLiteralSequence,			#protocol : #testing,			#sourceCode : 'testLiteralSequence\r\t| parser |\r\tparser := PPLiteralSequenceParser on: \'abc\' message: \'sequence "abc" expected\'.\r\tself assert: parser size equals: 3.\r\tself assert: parser literal equals: \'abc\'.\r\tself assert: parser message equals: \'sequence "abc" expected\'.\r\tself assert: parser parse: \'abc\' to: \'abc\'.\r\tself assert: parser fail: \'ab\'.\r\tself assert: parser fail: \'abd\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testLiteralSequence,			#protocol : #testing,			#sourceCode : 'testLiteralSequence\r\t| parser |\r\tparser := PPLiteralSequenceParser \r\t\ton: \'abc\'\r\t\tmessage: \'sequence "abc" expected\'.\r\tself assert: parser size = 3.\r\tself assert: parser literal = \'abc\'.\r\tself assert: parser message = \'sequence "abc" expected\'.\r\t\r\tself assert: parser parse: \'abc\' to: \'abc\'.\r\tself assert: parser fail: \'ab\'.\r\tself assert: parser fail: \'abd\'',			#stamp : 'lr 9/15/2010 12:00',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '408' ],		#self : OmReference [ '409' ],		#time : DateAndTime [ '2020-01-07T02:12:43.043626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesIn,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesIn\r\t| parser result |\r\tparser := $a asParser.\r\tresult := parser matchesIn: \'abba\'.\r\tself assert: result size equals: 2.\r\tself assert: result first equals: $a.\r\tself assert: result last equals: $a.\r\tresult := parser matchesIn: \'baaah\'.\r\tself assert: result size equals: 3.\r\tself assert: result first equals: $a.\r\tself assert: result last equals: $a',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesIn,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesIn\r\t| parser result |\r\tparser := $a asParser.\r\t\r\tresult := parser matchesIn: \'abba\'.\r\tself assert: result size = 2.\r\tself assert: result first = $a.\r\tself assert: result last = $a.\r\t\r\tresult := parser matchesIn: \'baaah\'.\r\tself assert: result size = 3.\r\tself assert: result first = $a.\r\tself assert: result last = $a',			#stamp : 'lr 2/8/2010 00:32',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '409' ],		#self : OmReference [ '410' ],		#time : DateAndTime [ '2020-01-07T02:12:43.045626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesInEmpty,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesInEmpty\r\t"Empty matches should properly advance and match at each position and at the end."\r\r\t| parser result |\r\tparser := [ :stream | stream position ] asParser.\r\tresult := parser matchesIn: \'123\'.\r\tself assert: result asArray equals: #(0 1 2 3)',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesInEmpty,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesInEmpty\r\t"Empty matches should properly advance and match at each position and at the end."\r\r\t| parser result |\r\tparser := [ :stream | stream position ] asParser.\r\t\r\tresult := parser matchesIn: \'123\'.\r\tself assert: result asArray = #(0 1 2 3)',			#stamp : 'lr 3/3/2010 15:33',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '410' ],		#self : OmReference [ '411' ],		#time : DateAndTime [ '2020-01-07T02:12:43.047626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesInOverlapping,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesInOverlapping\r\t"Matches that overlap should be properly reported."\r\r\t| parser result |\r\tparser := #digit asParser , #digit asParser.\r\tresult := parser matchesIn: \'a123b\'.\r\tself assert: result size equals: 2.\r\tself assert: result first equals: #($1 $2).\r\tself assert: result last equals: #($2 $3)',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesInOverlapping,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesInOverlapping\r\t"Matches that overlap should be properly reported."\r\r\t| parser result |\r\tparser := #digit asParser , #digit asParser.\r\t\r\tresult := parser matchesIn: \'a123b\'.\r\tself assert: result size = 2.\r\tself assert: result first = #($1 $2).\r\tself assert: result last = #($2 $3)',			#stamp : 'lr 3/3/2010 15:31',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '411' ],		#self : OmReference [ '412' ],		#time : DateAndTime [ '2020-01-07T02:12:43.049626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesSkipIn,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesSkipIn\r\t| parser result |\r\tparser := $a asParser.\r\tresult := parser matchesSkipIn: \'abba\'.\r\tself assert: result size equals: 2.\r\tself assert: result first equals: $a.\r\tself assert: result last equals: $a.\r\tresult := parser matchesSkipIn: \'baaah\'.\r\tself assert: result size equals: 3.\r\tself assert: result first equals: $a.\r\tself assert: result last equals: $a',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesSkipIn,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesSkipIn\r\t| parser result |\r\tparser := $a asParser.\r\t\r\tresult := parser matchesSkipIn: \'abba\'.\r\tself assert: result size = 2.\r\tself assert: result first = $a.\r\tself assert: result last = $a.\r\t\r\tresult := parser matchesSkipIn: \'baaah\'.\r\tself assert: result size = 3.\r\tself assert: result first = $a.\r\tself assert: result last = $a',			#stamp : 'lr 8/16/2011 07:27',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '412' ],		#self : OmReference [ '413' ],		#time : DateAndTime [ '2020-01-07T02:12:43.051626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesSkipInOverlapping,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesSkipInOverlapping\r\t"Matches that overlap should be properly reported."\r\r\t| parser result |\r\tparser := #digit asParser , #digit asParser.\r\tresult := parser matchesSkipIn: \'a123b\'.\r\tself assert: result size equals: 1.\r\tself assert: result first equals: #($1 $2)',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchesSkipInOverlapping,			#protocol : #testing-utilities,			#sourceCode : 'testMatchesSkipInOverlapping\r\t"Matches that overlap should be properly reported."\r\r\t| parser result |\r\tparser := #digit asParser , #digit asParser.\r\t\r\tresult := parser matchesSkipIn: \'a123b\'.\r\tself assert: result size = 1.\r\tself assert: result first = #($1 $2)',			#stamp : 'lr 8/16/2011 07:28',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '413' ],		#self : OmReference [ '414' ],		#time : DateAndTime [ '2020-01-07T02:12:43.053626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchingRangesIn,			#protocol : #testing-utilities,			#sourceCode : 'testMatchingRangesIn\r\t| input parser result |\r\tinput := \'a12b3\'.\r\tparser := #digit asParser plus.\r\tresult := parser matchingRangesIn: input.\r\tresult := result collect: [ :each | input copyFrom: each first to: each last ].\r\tself assert: result size equals: 3.\r\tself assert: result first equals: \'12\'.\r\tself assert: result second equals: \'2\'.\r\tself assert: result last equals: \'3\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchingRangesIn,			#protocol : #testing-utilities,			#sourceCode : 'testMatchingRangesIn\r\t| input parser result |\r\tinput := \'a12b3\'.\r\tparser := #digit asParser plus.\r\tresult := parser matchingRangesIn: input.\r\tresult := result collect: [ :each | input copyFrom: each first to: each last ].\r\tself assert: result size = 3.\r\tself assert: result first = \'12\'.\r\tself assert: result second = \'2\'.\r\tself assert: result last = \'3\'',			#stamp : 'lr 10/30/2011 12:13',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '414' ],		#self : OmReference [ '415' ],		#time : DateAndTime [ '2020-01-07T02:12:43.054626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchingSkipRangesIn,			#protocol : #testing-utilities,			#sourceCode : 'testMatchingSkipRangesIn\r\t| input parser result |\r\tinput := \'a12b3\'.\r\tparser := #digit asParser plus.\r\tresult := parser matchingSkipRangesIn: input.\r\tresult := result collect: [ :each | input copyFrom: each first to: each last ].\r\tself assert: result size equals: 2.\r\tself assert: result first equals: \'12\'.\r\tself assert: result last equals: \'3\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMatchingSkipRangesIn,			#protocol : #testing-utilities,			#sourceCode : 'testMatchingSkipRangesIn\r\t| input parser result |\r\tinput := \'a12b3\'.\r\tparser := #digit asParser plus.\r\tresult := parser matchingSkipRangesIn: input.\r\tresult := result collect: [ :each | input copyFrom: each first to: each last ].\r\tself assert: result size = 2.\r\tself assert: result first = \'12\'.\r\tself assert: result last = \'3\'',			#stamp : 'lr 10/30/2011 12:12',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '415' ],		#self : OmReference [ '416' ],		#time : DateAndTime [ '2020-01-07T02:12:43.057626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMax,			#protocol : #testing,			#sourceCode : 'testMax\r\t| parser printString suffix |\r\tparser := $a asParser max: 2.\r\tself assert: parser min equals: 0.\r\tself assert: parser max equals: 2.\r\tself assert: parser parse: \'\' to: #().\r\tself assert: parser parse: \'a\' to: #($a).\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself\r\t\tassert: parser\r\t\tparse: \'aaa\'\r\t\tto: #($a $a)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'aaaa\'\r\t\tto: #($a $a)\r\t\tend: 2.\r\tprintString := parser printString.\r\tsuffix := printString copyFrom: printString size - 5 to: printString size.\r\tself assert: suffix = \'[0, 2]\'\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMax,			#protocol : #testing,			#sourceCode : 'testMax\r\t| parser |\r\tparser := $a asParser max: 2.\r\tself assert: parser min = 0.\r\tself assert: parser max = 2.\r\r\tself assert: parser parse: \'\' to: #().\r\tself assert: parser parse: \'a\' to: #($a).\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself assert: parser parse: \'aaa\' to: #($a $a) end: 2.\r\tself assert: parser parse: \'aaaa\' to: #($a $a) end: 2.\r\t\r\tself assert: (parser printString endsWith: \'[0, 2]\')',			#stamp : 'lr 5/2/2010 12:18',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '416' ],		#self : OmReference [ '417' ],		#time : DateAndTime [ '2020-01-07T02:12:43.058626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMemoized,			#protocol : #testing,			#sourceCode : 'testMemoized\r\t| count parser twice |\r\tcount := 0.\r\tparser := [ :s | \r\tcount := count + 1.\r\ts next ] asParser memoized.\r\ttwice := parser and , parser.\r\tcount := 0.\r\tself assert: parser parse: \'a\' to: $a.\r\tself assert: count equals: 1.\r\tcount := 0.\r\tself assert: twice parse: \'a\' to: #($a $a).\r\tself assert: count equals: 1.\r\tself assert: parser memoized equals: parser',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMemoized,			#protocol : #testing,			#sourceCode : 'testMemoized\r\t| count parser twice |\r\tcount := 0.\r\tparser := [ :s | count := count + 1. s next ] asParser memoized.\r\ttwice := parser and , parser.\r\t\r\tcount := 0.\r\tself assert: parser parse: \'a\' to: $a.\r\tself assert: count = 1.\r\r\tcount := 0.\r\tself assert: twice parse: \'a\' to: #($a $a).\r\tself assert: count = 1.\r\t\r\tself assert: parser memoized = parser',			#stamp : 'lr 4/2/2009 20:35',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '417' ],		#self : OmReference [ '418' ],		#time : DateAndTime [ '2020-01-07T02:12:43.060626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMin,			#protocol : #testing,			#sourceCode : 'testMin\r\t| parser printString suffix |\r\tparser := $a asParser min: 2.\r\tself assert: parser min equals: 2.\r\tself assert: parser max > parser min.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself assert: parser parse: \'aaa\' to: #($a $a $a).\r\tself assert: parser parse: \'aaaa\' to: #($a $a $a $a).\r\tprintString := parser printString.\r\tsuffix := printString copyFrom: printString size - 5 to: printString size.\r\tself assert: suffix = \'[2, *]\'\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMin,			#protocol : #testing,			#sourceCode : 'testMin\r\t| parser |\r\tparser := $a asParser min: 2.\r\tself assert: parser min = 2.\r\tself assert: parser max > parser min.\r\t\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself assert: parser parse: \'aaa\' to: #($a $a $a).\r\tself assert: parser parse: \'aaaa\' to: #($a $a $a $a).\r\t\r\tself assert: (parser printString endsWith: \'[2, *]\')',			#stamp : 'lr 5/2/2010 12:18',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '418' ],		#self : OmReference [ '419' ],		#time : DateAndTime [ '2020-01-07T02:12:43.062626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMinMax,			#protocol : #testing,			#sourceCode : 'testMinMax\r\t| parser printString suffix |\r\tparser := $a asParser min: 2 max: 4.\r\tself assert: parser min equals: 2.\r\tself assert: parser max equals: 4.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself assert: parser parse: \'aaa\' to: #($a $a $a).\r\tself assert: parser parse: \'aaaa\' to: #($a $a $a $a).\r\tself\r\t\tassert: parser\r\t\tparse: \'aaaaa\'\r\t\tto: #($a $a $a $a)\r\t\tend: 4.\r\tself\r\t\tassert: parser\r\t\tparse: \'aaaaaa\'\r\t\tto: #($a $a $a $a)\r\t\tend: 4.\r\tprintString := parser printString.\r\tsuffix := printString copyFrom: printString size - 5 to: printString size.\r\tself assert: suffix = \'[2, 4]\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testMinMax,			#protocol : #testing,			#sourceCode : 'testMinMax\r\t| parser |\r\tparser := $a asParser min: 2 max: 4.\r\tself assert: parser min = 2.\r\tself assert: parser max = 4.\r\t\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself assert: parser parse: \'aaa\' to: #($a $a $a).\r\tself assert: parser parse: \'aaaa\' to: #($a $a $a $a).\r\tself assert: parser parse: \'aaaaa\' to: #($a $a $a $a) end: 4.\r\tself assert: parser parse: \'aaaaaa\' to: #($a $a $a $a) end: 4.\r\t\r\tself assert: (parser printString endsWith: \'[2, 4]\')',			#stamp : 'lr 5/2/2010 12:19',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '419' ],		#self : OmReference [ '420' ],		#time : DateAndTime [ '2020-01-07T02:12:43.063626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testNamed,			#protocol : #testing-accessing,			#sourceCode : 'testNamed\r\t| parser |\r\tparser := PPSequenceParser new.\r\tself assert: parser name isNil.\r\tparser := PPChoiceParser named: \'choice\'.\r\tself assert: parser name equals: \'choice\'.\r\tparser := $* asParser name: \'star\'.\r\tself assert: parser name equals: \'star\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testNamed,			#protocol : #testing-accessing,			#sourceCode : 'testNamed\r\t| parser |\r\tparser := PPSequenceParser new.\r\tself assert: parser name isNil.\r\t\r\tparser := PPChoiceParser named: \'choice\'.\r\tself assert: parser name = \'choice\'.\r\t\r\tparser := $* asParser name: \'star\'.\r\tself assert: parser name = \'star\'',			#stamp : 'lr 3/30/2009 16:36',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '420' ],		#self : OmReference [ '421' ],		#time : DateAndTime [ '2020-01-07T02:12:43.065626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testParse,			#protocol : #testing-utilities,			#sourceCode : 'testParse\r\t| parser result |\r\tparser := $a asParser.\r\tself assert: (parser parse: \'a\') equals: $a.\r\tself assert: (result := parser parse: \'b\') isPetitFailure.\r\tself assert: result message includesSubstring: $a printString.\r\tself assert: result message includesSubstring: \'expected\'.\r\tself assert: result position equals: 0.\r\tself assert: (parser parse: \'a\' readStream) equals: $a.\r\tself assert: (result := parser parse: \'b\' readStream) isPetitFailure.\r\tself assert: result message includesSubstring: $a printString.\r\tself assert: result message includesSubstring: \'expected\'.\r\tself assert: result position equals: 0',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testParse,			#protocol : #testing-utilities,			#sourceCode : 'testParse\r\t| parser result |\r\tparser := $a asParser.\r\t\r\tself assert: (parser parse: \'a\') = $a.\r\tself assert: (result := parser parse: \'b\') isPetitFailure.\r\tself assert: (result message findString: \'$a\') > 0.\r\tself assert: (result message findString: \'expected\') > 0.\r\tself assert: (result position = 0).\r\t\r\tself assert: (parser parse: \'a\' readStream) = $a.\r\tself assert: (result := parser parse: \'b\' readStream) isPetitFailure.\r\tself assert: (result message findString: \'$a\') > 0.\r\tself assert: (result message findString: \'expected\') > 0.\r\tself assert: (result position = 0)',			#stamp : 'lr 3/17/2013 08:54',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '421' ],		#self : OmReference [ '422' ],		#time : DateAndTime [ '2020-01-07T02:12:43.067626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testParseOnError0,			#protocol : #testing-utilities,			#sourceCode : 'testParseOnError0\r\t| parser result seen |\r\tparser := $a asParser.\r\tresult := parser parse: \'a\' onError: [ self signalFailure: \'Not supposed to report an error\' ].\r\tself assert: result equals: $a.\r\tresult := parser parse: \'b\' onError: [ seen := true ].\r\tself assert: result.\r\tself assert: seen',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testParseOnError0,			#protocol : #testing-utilities,			#sourceCode : 'testParseOnError0\r\t| parser result seen |\r\tparser := $a asParser.\r\r\tresult := parser parse: \'a\' onError: [ self signalFailure: \'Not supposed to report an error\' ].\r\tself assert: result = $a.\r\r\tresult := parser parse: \'b\' onError: [ seen := true ].\r\tself assert: result.\r\tself assert: seen',			#stamp : 'lr 2/7/2010 23:00',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '422' ],		#self : OmReference [ '423' ],		#time : DateAndTime [ '2020-01-07T02:12:43.069626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testParseOnError1,			#protocol : #testing-utilities,			#sourceCode : 'testParseOnError1\r\t| parser result seen |\r\tparser := $a asParser.\r\tresult := parser parse: \'a\' onError: [ self signalFailure: \'Not supposed to report an error\' ].\r\tself assert: result equals: $a.\r\tresult := parser\r\t\tparse: \'b\'\r\t\tonError: [ :failure | \r\t\t\tself assert: failure position equals: 0.\r\t\t\tself assert: failure message includesSubstring: $a printString.\r\t\t\tself assert: failure message includesSubstring: \'expected\'.\r\t\t\tseen := true ].\r\tself assert: result.\r\tself assert: seen',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testParseOnError1,			#protocol : #testing-utilities,			#sourceCode : 'testParseOnError1\r\t| parser result seen |\r\tparser := $a asParser.\r\r\tresult := parser parse: \'a\' onError: [ self signalFailure: \'Not supposed to report an error\' ].\r\tself assert: result = $a.\r\t\r\tresult := parser parse: \'b\' onError: [ :failure | \r\t\tself assert: (failure position = 0).\r\t\tself assert: (failure message findString: \'$a\') > 0.\r\t\tself assert: (failure message findString: \'expected\') > 0.\r\t\tseen := true ].\r\tself assert: result.\r\tself assert: seen',			#stamp : 'lr 3/17/2013 08:56',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '423' ],		#self : OmReference [ '424' ],		#time : DateAndTime [ '2020-01-07T02:12:43.071626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testParseOnError2,			#protocol : #testing-utilities,			#sourceCode : 'testParseOnError2\r\t| parser result seen |\r\tparser := $a asParser.\r\tresult := parser parse: \'a\' onError: [ self signalFailure: \'Not supposed to report an error\' ].\r\tself assert: result equals: $a.\r\tresult := parser\r\t\tparse: \'b\'\r\t\tonError: [ :msg :pos | \r\t\t\tself assert: msg includesSubstring: $a printString.\r\t\t\tself assert: msg includesSubstring: \'expected\'.\r\t\t\tself assert: pos equals: 0.\r\t\t\tseen := true ].\r\tself assert: result.\r\tself assert: seen',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testParseOnError2,			#protocol : #testing-utilities,			#sourceCode : 'testParseOnError2\r\t| parser result seen |\r\tparser := $a asParser.\r\t\r\tresult := parser parse: \'a\' onError: [ self signalFailure: \'Not supposed to report an error\' ].\r\tself assert: result = $a.\r\r\tresult := parser parse: \'b\' onError: [ :msg :pos | \r\t\tself assert: (msg findString: \'$a\') > 0.\r\t\tself assert: (msg findString: \'expected\') > 0.\r\t\tself assert: pos = 0.\r\t\tseen := true ].\r\tself assert: result.\r\tself assert: seen',			#stamp : 'lr 3/17/2013 08:53',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '424' ],		#self : OmReference [ '425' ],		#time : DateAndTime [ '2020-01-07T02:12:43.073626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPluggable,			#protocol : #testing,			#sourceCode : 'testPluggable\r\t| block parser |\r\tblock := [ :stream | stream position ].\r\tparser := block asParser.\r\tself assert: parser block equals: block',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPluggable,			#protocol : #testing,			#sourceCode : 'testPluggable\r\t| block parser |\r\tblock := [ :stream | stream position ].\r\tparser := block asParser.\r\tself assert: parser block = block',			#stamp : 'lr 5/2/2010 12:26',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '425' ],		#self : OmReference [ '426' ],		#time : DateAndTime [ '2020-01-07T02:12:43.074626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPlus,			#protocol : #testing,			#sourceCode : 'testPlus\r\t| parser |\r\tparser := $a asParser plus.\r\tself assert: parser min equals: 1.\r\tself assert: parser max > parser min.\r\tself assert: parser parse: \'a\' to: #($a).\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself assert: parser parse: \'aaa\' to: #($a $a $a).\r\tself\r\t\tassert: parser\r\t\tparse: \'ab\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'aab\'\r\t\tto: #($a $a)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'aaab\'\r\t\tto: #($a $a $a)\r\t\tend: 3.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'b\'.\r\tself assert: parser fail: \'ba\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPlus,			#protocol : #testing,			#sourceCode : 'testPlus\r\t| parser |\r\tparser := $a asParser plus.\r\t\r\tself assert: parser min = 1.\r\tself assert: parser max > parser min.\r\t\r\tself assert: parser parse: \'a\' to: #($a).\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself assert: parser parse: \'aaa\' to: #($a $a $a).\r\t\r\tself assert: parser parse: \'ab\' to: #($a) end: 1.\r\tself assert: parser parse: \'aab\' to: #($a $a) end: 2.\r\tself assert: parser parse: \'aaab\' to: #($a $a $a) end: 3.\r\t\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'b\'.\r\tself assert: parser fail: \'ba\'',			#stamp : 'lr 8/17/2011 10:01',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '426' ],		#self : OmReference [ '427' ],		#time : DateAndTime [ '2020-01-07T02:12:43.076626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPlusGreedy,			#protocol : #testing,			#sourceCode : 'testPlusGreedy\r\t| limit parser |\r\tlimit := #digit asParser.\r\tparser := #word asParser plusGreedy: limit.\r\tself assert: parser min equals: 1.\r\tself assert: parser max > parser min.\r\tself assert: parser limit equals: limit.\r\tself assert: parser children size equals: 2.\r\tself assert: parser children last equals: limit.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'1\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'ab\'.\r\tself\r\t\tassert: parser\r\t\tparse: \'a1\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab1\'\r\t\tto: #($a $b)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc1\'\r\t\tto: #($a $b $c)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'a12\'\r\t\tto: #($a $1)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab12\'\r\t\tto: #($a $b $1)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc12\'\r\t\tto: #($a $b $c $1)\r\t\tend: 4.\r\tself\r\t\tassert: parser\r\t\tparse: \'a123\'\r\t\tto: #($a $1 $2)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab123\'\r\t\tto: #($a $b $1 $2)\r\t\tend: 4.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc123\'\r\t\tto: #($a $b $c $1 $2)\r\t\tend: 5',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPlusGreedy,			#protocol : #testing,			#sourceCode : 'testPlusGreedy\r\t| limit parser |\r\tlimit := #digit asParser.\r\tparser := #word asParser plusGreedy: limit.\r\t\r\tself assert: parser min = 1.\r\tself assert: parser max > parser min.\t\r\tself assert: parser limit = limit.\r\tself assert: parser children size = 2.\r\tself assert: parser children last = limit.\r\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'1\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'ab\'.\r\r\tself assert: parser parse: \'a1\' to: #($a) end: 1.\r\tself assert: parser parse: \'ab1\' to: #($a $b) end: 2.\r\tself assert: parser parse: \'abc1\' to: #($a $b $c) end: 3.\r\tself assert: parser parse: \'a12\' to: #($a $1) end: 2.\r\tself assert: parser parse: \'ab12\' to: #($a $b $1) end: 3.\r\tself assert: parser parse: \'abc12\' to: #($a $b $c $1) end: 4.\r\tself assert: parser parse: \'a123\' to: #($a $1 $2) end: 3.\r\tself assert: parser parse: \'ab123\' to: #($a $b $1 $2) end: 4.\r\tself assert: parser parse: \'abc123\' to: #($a $b $c $1 $2) end: 5.',			#stamp : 'lr 8/17/2011 10:01',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '427' ],		#self : OmReference [ '428' ],		#time : DateAndTime [ '2020-01-07T02:12:43.079626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPlusLazy,			#protocol : #testing,			#sourceCode : 'testPlusLazy\r\t| limit parser |\r\tlimit := #digit asParser.\r\tparser := #word asParser plusLazy: limit.\r\tself assert: parser min equals: 1.\r\tself assert: parser max > parser min.\r\tself assert: parser limit equals: limit.\r\tself assert: parser children size equals: 2.\r\tself assert: parser children last equals: limit.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'1\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'ab\'.\r\tself\r\t\tassert: parser\r\t\tparse: \'a1\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab1\'\r\t\tto: #($a $b)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc1\'\r\t\tto: #($a $b $c)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'a12\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab12\'\r\t\tto: #($a $b)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc12\'\r\t\tto: #($a $b $c)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'a123\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab123\'\r\t\tto: #($a $b)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc123\'\r\t\tto: #($a $b $c)\r\t\tend: 3',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPlusLazy,			#protocol : #testing,			#sourceCode : 'testPlusLazy\r\t| limit parser |\r\tlimit := #digit asParser.\r\tparser := #word asParser plusLazy: limit.\r\t\r\tself assert: parser min = 1.\r\tself assert: parser max > parser min.\t\r\tself assert: parser limit = limit.\r\tself assert: parser children size = 2.\r\tself assert: parser children last = limit.\r\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'1\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'ab\'.\r\r\tself assert: parser parse: \'a1\' to: #($a) end: 1.\r\tself assert: parser parse: \'ab1\' to: #($a $b) end: 2.\r\tself assert: parser parse: \'abc1\' to: #($a $b $c) end: 3.\r\tself assert: parser parse: \'a12\' to: #($a) end: 1.\r\tself assert: parser parse: \'ab12\' to: #($a $b) end: 2.\r\tself assert: parser parse: \'abc12\' to: #($a $b $c) end: 3.\r\tself assert: parser parse: \'a123\' to: #($a) end: 1.\r\tself assert: parser parse: \'ab123\' to: #($a $b) end: 2.\r\tself assert: parser parse: \'abc123\' to: #($a $b $c) end: 3',			#stamp : 'lr 8/17/2011 10:01',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '428' ],		#self : OmReference [ '429' ],		#time : DateAndTime [ '2020-01-07T02:12:43.080626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPrint,			#protocol : #testing-accessing,			#sourceCode : 'testPrint\r\t| parser |\r\tparser := PPParser new.\r\tself assert: parser printString includesSubstring: \'PPParser\'.\r\t\r\tparser := PPParser named: \'choice\'.\r\tself assert: parser printString includesSubstring: \'PPParser(choice\'.\r\t\r\tparser := PPLiteralObjectParser on: $a.\r\tself assert: parser printString includesSubstring: $a printString.\r\t\r\tparser := PPFailingParser message: \'error\'.\r\tself assert: parser printString includesSubstring: \'error\'.\r\t\r\tparser := PPPredicateObjectParser on: [ :c | true ] message: \'error\'.\r\tself assert: parser printString includesSubstring: \'error\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testPrint,			#protocol : #testing-accessing,			#sourceCode : 'testPrint\r\t| parser |\r\tparser := PPParser new.\r\tself assert: (parser printString findString: \'PPParser\') > 0.\r\t\r\tparser := PPParser named: \'choice\'.\r\tself assert: (parser printString findString: \'PPParser(choice\') > 0.\r\t\r\tparser := PPLiteralObjectParser on: $a.\r\tself assert: (parser printString findString: \'$a\') > 0.\r\t\r\tparser := PPFailingParser message: \'error\'.\r\tself assert: (parser printString findString: \'error\') > 0.\r\t\r\tparser := PPPredicateObjectParser on: [ :c | true ] message: \'error\'.\r\tself assert: (parser printString findString: \'error\') > 0',			#stamp : 'lr 3/17/2013 08:53',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '429' ],		#self : OmReference [ '430' ],		#time : DateAndTime [ '2020-01-07T02:12:43.082626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testStar,			#protocol : #testing,			#sourceCode : 'testStar\r\t| parser |\r\tparser := $a asParser star.\r\tself assert: parser min equals: 0.\r\tself assert: parser max > parser min.\r\tself assert: parser parse: \'\' to: #().\r\tself assert: parser parse: \'a\' to: #($a).\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself assert: parser parse: \'aaa\' to: #($a $a $a).\r\tself\r\t\tassert: parser\r\t\tparse: \'b\'\r\t\tto: #()\r\t\tend: 0.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'aab\'\r\t\tto: #($a $a)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'aaab\'\r\t\tto: #($a $a $a)\r\t\tend: 3',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testStar,			#protocol : #testing,			#sourceCode : 'testStar\r\t| parser |\r\tparser := $a asParser star.\r\t\r\tself assert: parser min = 0.\r\tself assert: parser max > parser min.\r\t\r\tself assert: parser parse: \'\' to: #().\r\tself assert: parser parse: \'a\' to: #($a).\r\tself assert: parser parse: \'aa\' to: #($a $a).\r\tself assert: parser parse: \'aaa\' to: #($a $a $a).\r\t\r\tself assert: parser parse: \'b\' to: #() end: 0.\r\tself assert: parser parse: \'ab\' to: #($a) end: 1.\r\tself assert: parser parse: \'aab\' to: #($a $a) end: 2.\r\tself assert: parser parse: \'aaab\' to: #($a $a $a) end: 3',			#stamp : 'lr 8/17/2011 10:02',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '430' ],		#self : OmReference [ '431' ],		#time : DateAndTime [ '2020-01-07T02:12:43.084626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testStarGreedy,			#protocol : #testing,			#sourceCode : 'testStarGreedy\r\t| limit parser |\r\tlimit := #digit asParser.\r\tparser := #word asParser starGreedy: limit.\r\tself assert: parser min equals: 0.\r\tself assert: parser max > parser min.\r\tself assert: parser limit equals: limit.\r\tself assert: parser children size equals: 2.\r\tself assert: parser children last equals: limit.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'ab\'.\r\tself\r\t\tassert: parser\r\t\tparse: \'1\'\r\t\tto: #()\r\t\tend: 0.\r\tself\r\t\tassert: parser\r\t\tparse: \'a1\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab1\'\r\t\tto: #($a $b)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc1\'\r\t\tto: #($a $b $c)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'12\'\r\t\tto: #($1)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'a12\'\r\t\tto: #($a $1)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab12\'\r\t\tto: #($a $b $1)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc12\'\r\t\tto: #($a $b $c $1)\r\t\tend: 4.\r\tself\r\t\tassert: parser\r\t\tparse: \'123\'\r\t\tto: #($1 $2)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'a123\'\r\t\tto: #($a $1 $2)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab123\'\r\t\tto: #($a $b $1 $2)\r\t\tend: 4.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc123\'\r\t\tto: #($a $b $c $1 $2)\r\t\tend: 5',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testStarGreedy,			#protocol : #testing,			#sourceCode : 'testStarGreedy\r\t| limit parser |\r\tlimit := #digit asParser.\r\tparser := #word asParser starGreedy: limit.\r\t\r\tself assert: parser min = 0.\r\tself assert: parser max > parser min.\r\tself assert: parser limit = limit.\r\tself assert: parser children size = 2.\r\tself assert: parser children last = limit.\r\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'ab\'.\r\r\tself assert: parser parse: \'1\' to: #() end: 0.\r\tself assert: parser parse: \'a1\' to: #($a) end: 1.\r\tself assert: parser parse: \'ab1\' to: #($a $b) end: 2.\r\tself assert: parser parse: \'abc1\' to: #($a $b $c) end: 3.\r\tself assert: parser parse: \'12\' to: #($1) end: 1.\r\tself assert: parser parse: \'a12\' to: #($a $1) end: 2.\r\tself assert: parser parse: \'ab12\' to: #($a $b $1) end: 3.\r\tself assert: parser parse: \'abc12\' to: #($a $b $c $1) end: 4.\r\tself assert: parser parse: \'123\' to: #($1 $2) end: 2.\r\tself assert: parser parse: \'a123\' to: #($a $1 $2) end: 3.\r\tself assert: parser parse: \'ab123\' to: #($a $b $1 $2) end: 4.\r\tself assert: parser parse: \'abc123\' to: #($a $b $c $1 $2) end: 5',			#stamp : 'lr 8/17/2011 10:02',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '431' ],		#self : OmReference [ '432' ],		#time : DateAndTime [ '2020-01-07T02:12:43.085626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testStarLazy,			#protocol : #testing,			#sourceCode : 'testStarLazy\r\t| limit parser |\r\tlimit := #digit asParser.\r\tparser := #word asParser starLazy: limit.\r\tself assert: parser min equals: 0.\r\tself assert: parser max > parser min.\r\tself assert: parser limit equals: limit.\r\tself assert: parser children size equals: 2.\r\tself assert: parser children last equals: limit.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'ab\'.\r\tself\r\t\tassert: parser\r\t\tparse: \'1\'\r\t\tto: #()\r\t\tend: 0.\r\tself\r\t\tassert: parser\r\t\tparse: \'a1\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab1\'\r\t\tto: #($a $b)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc1\'\r\t\tto: #($a $b $c)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'12\'\r\t\tto: #()\r\t\tend: 0.\r\tself\r\t\tassert: parser\r\t\tparse: \'a12\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab12\'\r\t\tto: #($a $b)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc12\'\r\t\tto: #($a $b $c)\r\t\tend: 3.\r\tself\r\t\tassert: parser\r\t\tparse: \'123\'\r\t\tto: #()\r\t\tend: 0.\r\tself\r\t\tassert: parser\r\t\tparse: \'a123\'\r\t\tto: #($a)\r\t\tend: 1.\r\tself\r\t\tassert: parser\r\t\tparse: \'ab123\'\r\t\tto: #($a $b)\r\t\tend: 2.\r\tself\r\t\tassert: parser\r\t\tparse: \'abc123\'\r\t\tto: #($a $b $c)\r\t\tend: 3',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testStarLazy,			#protocol : #testing,			#sourceCode : 'testStarLazy\r\t| limit parser |\r\tlimit := #digit asParser.\r\tparser := #word asParser starLazy: limit.\r\t\r\tself assert: parser min = 0.\r\tself assert: parser max > parser min.\r\tself assert: parser limit = limit.\r\tself assert: parser children size = 2.\r\tself assert: parser children last = limit.\r\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'a\'.\r\tself assert: parser fail: \'ab\'.\r\r\tself assert: parser parse: \'1\' to: #() end: 0.\r\tself assert: parser parse: \'a1\' to: #($a) end: 1.\r\tself assert: parser parse: \'ab1\' to: #($a $b) end: 2.\r\tself assert: parser parse: \'abc1\' to: #($a $b $c) end: 3.\r\tself assert: parser parse: \'12\' to: #() end: 0.\r\tself assert: parser parse: \'a12\' to: #($a) end: 1.\r\tself assert: parser parse: \'ab12\' to: #($a $b) end: 2.\r\tself assert: parser parse: \'abc12\' to: #($a $b $c) end: 3.\r\tself assert: parser parse: \'123\' to: #() end: 0.\r\tself assert: parser parse: \'a123\' to: #($a) end: 1.\r\tself assert: parser parse: \'ab123\' to: #($a $b) end: 2.\r\tself assert: parser parse: \'abc123\' to: #($a $b $c) end: 3',			#stamp : 'lr 8/17/2011 10:02',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '432' ],		#self : OmReference [ '433' ],		#time : DateAndTime [ '2020-01-07T02:12:43.087626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testToken,			#protocol : #testing-mapping,			#sourceCode : 'testToken\r\t| parser |\r\tparser := $a asParser token.\r\tself assert: parser tokenClass equals: PPToken.\r\tself\r\t\tassert: parser\r\t\tparse: \'a\'\r\t\ttoToken: 1\r\t\tstop: 1.\r\tself assert: parser fail: \'b\'.\r\tself assert: parser fail: \'\'.\r\tparser := $a asParser token: PPToken.\r\tself assert: parser tokenClass equals: PPToken.\r\tself\r\t\tassert: parser\r\t\tparse: \'a\'\r\t\ttoToken: 1\r\t\tstop: 1.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'b\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testToken,			#protocol : #testing-mapping,			#sourceCode : 'testToken\r\t| parser |\r\tparser := $a asParser token.\r\tself assert: parser tokenClass = PPToken.\r\tself assert: parser parse: \'a\' toToken: 1 stop: 1.\t\r\tself assert: parser fail: \'b\'.\r\tself assert: parser fail: \'\'.\r\t\r\tparser := $a asParser token: PPToken.\r\tself assert: parser tokenClass = PPToken.\r\tself assert: parser parse: \'a\' toToken: 1 stop: 1.\t\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'b\'',			#stamp : 'lr 4/6/2010 19:47',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '433' ],		#self : OmReference [ '434' ],		#time : DateAndTime [ '2020-01-07T02:12:43.089626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testWrapping,			#protocol : #testing-mapping,			#sourceCode : 'testWrapping\r\t| parser result |\r\tparser := #digit asParser plus >=> [ :stream :cc | Array with: stream position with: cc value with: stream position ].\r\tself assert: parser parse: \'1\' to: #(0 #($1) 1).\r\tself assert: parser parse: \'12\' to: #(0 #($1 $2) 2).\r\tself assert: parser parse: \'123\' to: #(0 #($1 $2 $3) 3).\r\tresult := parser parse: \'a\'.\r\tself assert: result first equals: 0.\r\tself assert: result second isPetitFailure.\r\tself assert: result last equals: 0',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParserTest,				#isMetaSide : false			},			#name : #testWrapping,			#protocol : #testing-mapping,			#sourceCode : 'testWrapping\r\t| parser result |\r\tparser := #digit asParser plus >=> [ :stream :cc | \r\t\tArray \r\t\t\twith: stream position \r\t\t\twith: cc value \r\t\t\twith: stream position ].\r\r\tself assert: parser parse: \'1\' to: #(0 ($1) 1).\r\tself assert: parser parse: \'12\' to: #(0 ($1 $2) 2).\r\tself assert: parser parse: \'123\' to: #(0 ($1 $2 $3) 3).\r\t\r\tresult := parser parse: \'a\'.\r\tself assert: result first = 0.\r\tself assert: result second isPetitFailure.\r\tself assert: result last = 0',			#stamp : 'lr 5/12/2010 20:40',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '434' ],		#self : OmReference [ '435' ],		#time : DateAndTime [ '2020-01-07T02:12:43.092626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser accepting the receiving object."\r\r\t^ PPPredicateObjectParser expect: self',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser accepting the receiving object."\r\r\t^ PPPredicateObjectParser expect: self',			#stamp : 'lr 12/18/2011 15:58',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '435' ],		#self : OmReference [ '436' ],		#time : DateAndTime [ '2020-01-07T02:12:43.097626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser\r\t"Answer a parser accepting the receiving object."\r\r\t^ PPPredicateObjectParser expect: self',			#stamp : 'lr 12/18/2011 15:58',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser accepting the receiving object."\r\r\t^ PPPredicateObjectParser expect: self',			#stamp : 'lr 12/18/2011 15:58',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '436' ],		#self : OmReference [ '437' ],		#time : DateAndTime [ '2020-01-07T02:12:43.099626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #isPetitFailure,			#protocol : #'*petitparser-core-testing',			#sourceCode : 'isPetitFailure\r\t^ false',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #isPetitFailure,			#protocol : #'*petitparser-core-testing',			#sourceCode : 'isPetitFailure\r\t^ false',			#stamp : 'lr 2/7/2010 20:54',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '437' ],		#self : OmReference [ '438' ],		#time : DateAndTime [ '2020-01-07T02:12:43.105626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #isPetitFailure,			#protocol : #'*PetitParser',			#sourceCode : 'isPetitFailure\r\t^ false',			#stamp : 'lr 2/7/2010 20:54',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #isPetitFailure,			#protocol : #'*petitparser-core-testing',			#sourceCode : 'isPetitFailure\r\t^ false',			#stamp : 'lr 2/7/2010 20:54',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '438' ],		#self : OmReference [ '439' ],		#time : DateAndTime [ '2020-01-07T02:12:43.106626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #isPetitParser,			#protocol : #'*petitparser-core-testing',			#sourceCode : 'isPetitParser\r\t^ false',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #isPetitParser,			#protocol : #'*petitparser-core-testing',			#sourceCode : 'isPetitParser\r\t^ false',			#stamp : 'lr 8/6/2010 16:44',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '439' ],		#self : OmReference [ '440' ],		#time : DateAndTime [ '2020-01-07T02:12:43.112626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #isPetitParser,			#protocol : #'*PetitParser',			#sourceCode : 'isPetitParser\r\t^ false',			#stamp : 'lr 8/6/2010 16:44',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Object,				#isMetaSide : false			},			#name : #isPetitParser,			#protocol : #'*petitparser-core-testing',			#sourceCode : 'isPetitParser\r\t^ false',			#stamp : 'lr 8/6/2010 16:44',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '440' ],		#self : OmReference [ '441' ],		#time : DateAndTime [ '2020-01-07T02:12:43.113626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:at:',			#protocol : #'instance creation',			#sourceCode : 'message: aString at: anInteger\r\t"One should not use this method if the furthest failure is supposed to be reported correctly"\r\t^ self basicNew initializeMessage: aString at: anInteger',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPFailure class',				#isMetaSide : true			},			#name : #'message:at:',			#protocol : #'instance creation',			#sourceCode : 'message: aString at: anInteger\r\t^ self basicNew initializeMessage: aString at: anInteger',			#stamp : 'lr 5/5/2010 13:56',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '441' ],		#self : OmReference [ '442' ],		#time : DateAndTime [ '2020-01-07T02:12:43.115626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:at:',			#protocol : #initialization,			#sourceCode : 'initializeMessage: aString at: anInteger\r\t"One should not use this method if the furthest failure is supposed to be reported correctly"\r\tmessage := aString.\r\tposition := anInteger.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'initializeMessage:at:',			#protocol : #initialization,			#sourceCode : 'initializeMessage: aString at: anInteger\r\tmessage := aString.\r\tposition := anInteger',			#stamp : 'lr 5/5/2010 13:55',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '442' ],		#self : OmReference [ '443' ],		#time : DateAndTime [ '2020-01-07T02:12:43.117626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream \r\t\tnextPutAll: (self message ifNil: [\'<message not specified>\']); \r\t\tnextPutAll: \' at \'; print: self position',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailure,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream nextPutAll: self message; nextPutAll: \' at \'; print: position',			#stamp : 'lr 5/5/2010 14:01',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '443' ],		#self : OmReference [ '444' ],		#time : DateAndTime [ '2020-01-07T02:12:43.118626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemento,				#isMetaSide : false			},			#name : #position,			#protocol : #accessing,			#sourceCode : 'position\r\t^ position',			#stamp : 'lr 4/22/2008 18:23',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '444' ],		#self : OmReference [ '445' ],		#time : DateAndTime [ '2020-01-07T02:12:43.119626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemento,				#isMetaSide : false			},			#name : #'position:',			#protocol : #accessing,			#sourceCode : 'position: anInteger\r\tposition := anInteger',			#stamp : 'lr 4/26/2008 15:48',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '445' ],		#self : OmReference [ '446' ],		#time : DateAndTime [ '2020-01-07T02:12:43.120626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t^ PPFailure message: message context: aPPContext',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t^ PPFailure message: message at: aStream position',			#stamp : 'lr 5/5/2010 13:57',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '446' ],		#self : OmReference [ '447' ],		#time : DateAndTime [ '2020-01-07T02:12:43.122626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #pp-context,			#sourceCode : 'parseOn: aStream\r\t^ PPFailure message: message at: aStream position',			#stamp : 'lr 5/5/2010 13:57',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFailingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t^ PPFailure message: message at: aStream position',			#stamp : 'lr 5/5/2010 13:57',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '447' ],		#self : OmReference [ '448' ],		#time : DateAndTime [ '2020-01-07T02:12:43.124626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPListParser class',				#isMetaSide : true			},			#name : #'withAll:',			#protocol : #'instance creation',			#sourceCode : 'withAll: aCollection\r\t^ self basicNew initialize;\r\t\tsetParsers: aCollection',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPListParser class',				#isMetaSide : true			},			#name : #'withAll:',			#protocol : #'instance creation',			#sourceCode : 'withAll: aCollection\r\t^ self basicNew setParsers: aCollection',			#stamp : 'lr 4/29/2010 10:12',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '448' ],		#self : OmReference [ '449' ],		#time : DateAndTime [ '2020-01-07T02:12:43.125626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parse:',			#protocol : #parsing,			#sourceCode : 'parse: anObject\r\t"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."\r\r\t^ self parse: anObject withContext: PPContext new',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parse:',			#protocol : #parsing,			#sourceCode : 'parse: anObject\r\t"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."\r\t\r\t^ self parseOn: anObject asPetitStream',			#stamp : 'lr 2/7/2010 20:53',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '449' ],		#self : OmReference [ '450' ],		#time : DateAndTime [ '2020-01-07T02:12:43.127626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t"Parse aStream with the receiving parser and answer the parse-result or an instance of PPFailure. Override this method in subclasses to specify custom parse behavior. Do not call this method from outside, instead use #parse:."\r\t\r\tself subclassResponsibility',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t"Parse aStream with the receiving parser and answer the parse-result or an instance of PPFailure. Override this method in subclasses to specify custom parse behavior. Do not call this method from outside, instead use #parse:."\r\t\r\tself subclassResponsibility',			#stamp : 'lr 2/7/2010 22:18',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '450' ],		#self : OmReference [ '451' ],		#time : DateAndTime [ '2020-01-07T02:12:43.128626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPluggableParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| memento result |\r\tmemento := aPPContext remember.\r\tresult := block value: aPPContext.\r\tresult isPetitFailure\r\t\tifTrue: [ aPPContext restore: memento ].\r\t^ result',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPluggableParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| position result |\r\tposition := aStream position.\r\tresult := block value: aStream.\r\tresult isPetitFailure\r\t\tifTrue: [ aStream position: position ].\r\t^ result',			#stamp : 'lr 2/7/2010 20:54',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '451' ],		#self : OmReference [ '452' ],		#time : DateAndTime [ '2020-01-07T02:12:43.130626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPToken class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Platform independent newline sequence. LF: Unix, CR+LF: Windows, and CR: Apple."\r\t| cr lf |\r\tcr := Character codePoint: 13.\r\tlf := Character codePoint: 10.\r\tNewLineParser := lf asParser / (cr asParser , lf asParser optional)',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPToken class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Platform independent newline sequence. LF: Unix, CR+LF: Windows, and CR: Apple."\r\r\tNewLineParser := (Character lf asParser) / (Character cr asParser , Character lf asParser optional)',			#stamp : 'lr 11/29/2011 20:42',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '452' ],		#self : OmReference [ '453' ],		#time : DateAndTime [ '2020-01-07T02:12:43.132626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPToken,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anObject\r\t^ self class = anObject class and: [ self inputValue = anObject inputValue ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPToken,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anObject\r\t^ self class = anObject class and: [ self parsedValue = anObject parsedValue ]',			#stamp : 'lr 2/26/2013 00:34',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '453' ],		#self : OmReference [ '454' ],		#time : DateAndTime [ '2020-01-07T02:12:43.134626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPToken,				#isMetaSide : false			},			#name : #hash,			#protocol : #comparing,			#sourceCode : 'hash\r\t^ self inputValue hash',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPToken,				#isMetaSide : false			},			#name : #hash,			#protocol : #comparing,			#sourceCode : 'hash\r\t^ self parsedValue hash',			#stamp : 'lr 2/26/2013 00:34',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '454' ],		#self : OmReference [ '455' ],		#time : DateAndTime [ '2020-01-07T02:12:43.135626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPToken,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn: aStream.\r\taStream nextPut: $[; print: self start; nextPut: $,; print: self stop; nextPut: $].\r\taStream nextPut: $(; print: self inputValue; nextPut: $)',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPToken,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn: aStream.\r\taStream nextPut: $[; print: self start; nextPut: $,; print: self stop; nextPut: $].\r\taStream nextPut: $(; print: self parsedValue; nextPut: $)',			#stamp : 'lr 2/26/2013 00:37',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '455' ],		#self : OmReference [ '456' ],		#time : DateAndTime [ '2020-01-07T02:12:43.137626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPToken,				#isMetaSide : false			},			#name : #value,			#protocol : #accessing-values,			#sourceCode : 'value\r\tself notify: \'Token>>#value is no longer supported. Instead use Token>>#inputValue\'.\r\t^ self inputValue',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPToken,				#isMetaSide : false			},			#name : #value,			#protocol : #accessing-values,			#sourceCode : 'value\r\tself notify: \'Token>>#value is no longer supported. Instead use Token>>#inputValue or the more pragmatic #parsedValue.\'.\r\t^ self inputValue',			#stamp : 'lr 2/26/2013 00:34',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '456' ],		#self : OmReference [ '457' ],		#time : DateAndTime [ '2020-01-07T02:12:43.139626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPossessiveRepeatingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| memento element elements |\r\tmemento := aPPContext remember.\r\telements := OrderedCollection new.\r\t[ elements size < min ] whileTrue: [\r\t\t(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [\r\t\t\taPPContext restore: memento.\r\t\t\t^ element ].\r\t\telements addLast: element ].\r\t[ elements size < max ] whileTrue: [\r\t \t(element := parser parseOn: aPPContext) isPetitFailure\r\t\t\tifTrue: [ ^ elements asArray ].\r\t\telements addLast: element ].\r\t^ elements asArray',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPossessiveRepeatingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| start element elements |\r\tstart := aStream position.\r\telements := OrderedCollection new.\r\t[ elements size < min ] whileTrue: [\r\t\t(element := parser parseOn: aStream) isPetitFailure ifTrue: [\r\t\t\taStream position: start.\r\t\t\t^ element ].\r\t\telements addLast: element ].\r\t[ elements size < max ] whileTrue: [\r\t \t(element := parser parseOn: aStream) isPetitFailure\r\t\t\tifTrue: [ ^ elements asArray ].\r\t\telements addLast: element ].\r\t^ elements asArray',			#stamp : 'lr 4/2/2011 09:52',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '457' ],		#self : OmReference [ '458' ],		#time : DateAndTime [ '2020-01-07T02:12:43.140626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testClosure,			#protocol : #testing-parser,			#sourceCode : 'testClosure\r\t| parser |\r\tparser := [ :stream | stream upTo: $s ] asParser.\r\tself assert: parser parse: \'\' to: \'\'.\r\tself assert: parser parse: \'a\' to: \'a\'.\r\tself assert: parser parse: \'aa\' to: \'aa\'.\r\tself assert: parser parse: \'s\' to: \'\'.\r\tself assert: parser parse: \'as\' to: \'a\'.\r\tself assert: parser parse: \'aas\' to: \'aa\'.\r\tself assert: parser parse: \'sa\' to: \'\' end: 1.\r\tself assert: parser parse: \'saa\' to: \'\' end: 1.\r\t\r\tparser := [ :stream | stream upTo: $s. PPFailure message: \'stream\' context: stream ] asParser.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'s\'.\r\tself assert: parser fail: \'as\'\r\t',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testClosure,			#protocol : #testing-parser,			#sourceCode : 'testClosure\r\t| parser |\r\tparser := [ :stream | stream upTo: $s ] asParser.\r\tself assert: parser parse: \'\' to: \'\'.\r\tself assert: parser parse: \'a\' to: \'a\'.\r\tself assert: parser parse: \'aa\' to: \'aa\'.\r\tself assert: parser parse: \'s\' to: \'\'.\r\tself assert: parser parse: \'as\' to: \'a\'.\r\tself assert: parser parse: \'aas\' to: \'aa\'.\r\tself assert: parser parse: \'sa\' to: \'\' end: 1.\r\tself assert: parser parse: \'saa\' to: \'\' end: 1.\r\t\r\tparser := [ :stream | stream upTo: $s. PPFailure message: \'stream\' at: stream position ] asParser.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'s\'.\r\tself assert: parser fail: \'as\'\r\t',			#stamp : 'lr 5/5/2010 14:03',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '458' ],		#self : OmReference [ '459' ],		#time : DateAndTime [ '2020-01-07T02:12:43.142626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testEpsilon,			#protocol : #testing-parser,			#sourceCode : 'testEpsilon\r\t| parser |\r\tparser := nil asParser.\r\tself assert: parser asParser equals: parser',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testEpsilon,			#protocol : #testing-parser,			#sourceCode : 'testEpsilon\r\t| parser |\r\tparser := nil asParser.\r\tself assert: parser asParser = parser',			#stamp : 'lr 11/20/2009 15:29',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '459' ],		#self : OmReference [ '460' ],		#time : DateAndTime [ '2020-01-07T02:12:43.144626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testParser,			#protocol : #testing-parser,			#sourceCode : 'testParser\r\t| parser |\r\tparser := $a asParser.\r\tself assert: parser asParser equals: parser',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testParser,			#protocol : #testing-parser,			#sourceCode : 'testParser\r\t| parser |\r\tparser := $a asParser.\r\tself assert: parser asParser = parser',			#stamp : 'lr 11/20/2009 15:30',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '460' ],		#self : OmReference [ '461' ],		#time : DateAndTime [ '2020-01-07T02:12:43.146626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testRange,			#protocol : #testing-parser,			#sourceCode : 'testRange\r\t| parser |\r\tparser := ($a to: $c) asParser.\r\tself assert: parser parse: \'a\' to: $a.\r\tself assert: parser parse: \'b\' to: $b.\r\tself assert: parser parse: \'c\' to: $c.\r\tself assert: parser fail: \'d\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testRange,			#protocol : #testing-parser,			#sourceCode : 'testRange\r\t| parser |\r\tparser := $a - $c.\r\tself assert: parser parse: \'a\' to: $a.\r\tself assert: parser parse: \'b\' to: $b.\r\tself assert: parser parse: \'c\' to: $c.\r\tself assert: parser fail: \'d\'',			#stamp : 'lr 9/17/2008 22:48',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '461' ],		#self : OmReference [ '462' ],		#time : DateAndTime [ '2020-01-07T02:12:43.147626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testStream,			#protocol : #testing-stream,			#sourceCode : 'testStream\r\t| dot stream |\r\tdot := (Character codePoint: 183) asString.\r\tstream := \'abc\' readStream asPetitStream.\r\tself assert: stream class equals: PPStream.\r\tself assert: stream printString equals: dot , \'abc\'.\r\tself assert: stream peek equals: $a.\r\tself assert: stream uncheckedPeek equals: $a.\r\tself assert: stream next equals: $a.\r\tself assert: stream printString equals: \'a\' , dot , \'bc\'.\r\tself assert: stream asPetitStream equals: stream',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testStream,			#protocol : #testing-stream,			#sourceCode : 'testStream\r\t| stream |\r\tstream := \'abc\' readStream asPetitStream.\r\tself assert: (stream class = PPStream).\r\tself assert: (stream printString = \'abc\').\r\tself assert: (stream peek) = $a.\r\tself assert: (stream uncheckedPeek = $a).\r\tself assert: (stream next) = $a.\r\tself assert: (stream printString = \'abc\').\r\tself assert: (stream asPetitStream = stream)',			#stamp : 'lr 9/30/2010 11:12',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '462' ],		#self : OmReference [ '463' ],		#time : DateAndTime [ '2020-01-07T02:12:43.149626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testText,			#protocol : #testing-stream,			#sourceCode : 'testText\r\t| stream |\r\tstream := \'abc\' asText asPetitStream.\r\tself assert: stream class equals: PPStream',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExtensionTest,				#isMetaSide : false			},			#name : #testText,			#protocol : #testing-stream,			#sourceCode : 'testText\r\t| stream |\r\tstream := \'abc\' asText asPetitStream.\r\tself assert: stream class = PPStream',			#stamp : 'lr 2/7/2010 20:53',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '463' ],		#self : OmReference [ '464' ],		#time : DateAndTime [ '2020-01-07T02:12:43.151626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParser,				#isMetaSide : false			},			#name : #abstraction,			#protocol : #productions,			#sourceCode : 'abstraction\r\t^ $\\ asParser trim , variable , $. asParser trim , expression \r\t\t==> [ :node | Array with: (node at: 2) with: (node at: 4) ]',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParser,				#isMetaSide : false			},			#name : #abstraction,			#protocol : #productions,			#sourceCode : 'abstraction\r\t^ $\\ asParser trim , variable , $. asParser trim , expression ==> [ :node | Array with: node second with: node fourth ]',			#stamp : 'lr 2/25/2013 23:43',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '464' ],		#self : OmReference [ '465' ],		#time : DateAndTime [ '2020-01-07T02:12:43.153626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParser,				#isMetaSide : false			},			#name : #application,			#protocol : #productions,			#sourceCode : 'application\r\t^ $( asParser trim , expression , expression , $) asParser trim \r\t\t\t==> [ :node | Array with: (node at: 2) with: (node at: 3) ]',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParser,				#isMetaSide : false			},			#name : #application,			#protocol : #productions,			#sourceCode : 'application\r\t^ $( asParser trim , expression , expression , $) asParser trim ==> [ :node | Array with: node second with: node third ]',			#stamp : 'lr 2/25/2013 23:43',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '465' ],		#self : OmReference [ '466' ],		#time : DateAndTime [ '2020-01-07T02:12:43.154626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFlattenParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| start element |\r\tstart := aPPContext position.\r\telement := parser parseOn: aPPContext.\r\telement isPetitFailure ifTrue: [ ^ element ].\r\t^ self on: aPPContext stream collection start: start + 1 stop: aPPContext position value: element',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPFlattenParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| start element |\r\tstart := aStream position.\r\telement := parser parseOn: aStream.\r\telement isPetitFailure ifTrue: [ ^ element ].\r\t^ self on: aStream collection start: start + 1 stop: aStream position value: element',			#stamp : 'lr 2/25/2013 23:30',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '466' ],		#self : OmReference [ '467' ],		#time : DateAndTime [ '2020-01-07T02:12:43.157626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPScriptingTest,				#isMetaSide : false			},			#name : #expressionInterpreter,			#protocol : #examples,			#sourceCode : 'expressionInterpreter\r\t"Same as #expressionInterpreter but with semantic actions."\r\t\r\t| mul prim add dec |\r\tadd := PPUnresolvedParser new.\r\tmul := PPUnresolvedParser new.\r\tprim := PPUnresolvedParser new.\r\tdec := ($0 to: $9) asParser ==> [ :token | token codePoint - $0 codePoint ].\r\tadd def: ((mul , $+ asParser , add) ==> [ :nodes | (nodes at: 1) + (nodes at: 3) ])\r\t\t/ mul.\r\tmul def: ((prim , $* asParser , mul) ==> [ :nodes | (nodes at: 1) * (nodes at: 3) ])\r\t\t/ prim.\r\tprim def: (($( asParser , add , $) asParser) ==> [ :nodes | nodes at: 2 ])\r\t\t/ dec.\r\t^ add end',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPScriptingTest,				#isMetaSide : false			},			#name : #expressionInterpreter,			#protocol : #examples,			#sourceCode : 'expressionInterpreter\r\t"Same as #expressionInterpreter but with semantic actions."\r\t\r\t| mul prim add dec |\r\tadd := PPUnresolvedParser new.\r\tmul := PPUnresolvedParser new.\r\tprim := PPUnresolvedParser new.\r\tdec := ($0 - $9) ==> [ :token | token codePoint - $0 codePoint ].\r\tadd def: ((mul , $+ asParser , add) ==> [ :nodes | (nodes at: 1) + (nodes at: 3) ])\r\t\t/ mul.\r\tmul def: ((prim , $* asParser , mul) ==> [ :nodes | (nodes at: 1) * (nodes at: 3) ])\r\t\t/ prim.\r\tprim def: (($( asParser , add , $) asParser) ==> [ :nodes | nodes at: 2 ])\r\t\t/ dec.\r\t^ add end',			#stamp : 'lr 6/12/2010 08:30',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '467' ],		#self : OmReference [ '468' ],		#time : DateAndTime [ '2020-01-07T02:12:43.158626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPScriptingTest,				#isMetaSide : false			},			#name : #expressionParser,			#protocol : #examples,			#sourceCode : 'expressionParser\r\t"Simple demo of scripting an expression parser."\r\t\r\t| mul prim add dec |\r\tadd := PPUnresolvedParser new.\r\tmul := PPUnresolvedParser new.\r\tprim := PPUnresolvedParser new.\r\tdec := ($0 to: $9) asParser.\r\tadd def: (mul , $+ asParser , add)\r\t\t/ mul.\r\tmul def: (prim , $* asParser , mul)\r\t\t/ prim.\r\tprim def: ($( asParser , add , $) asParser)\r\t\t/ dec.\r\t^ add end',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPScriptingTest,				#isMetaSide : false			},			#name : #expressionParser,			#protocol : #examples,			#sourceCode : 'expressionParser\r\t"Simple demo of scripting an expression parser."\r\t\r\t| mul prim add dec |\r\tadd := PPUnresolvedParser new.\r\tmul := PPUnresolvedParser new.\r\tprim := PPUnresolvedParser new.\r\tdec := ($0 - $9).\r\tadd def: (mul , $+ asParser , add)\r\t\t/ mul.\r\tmul def: (prim , $* asParser , mul)\r\t\t/ prim.\r\tprim def: ($( asParser , add , $) asParser)\r\t\t/ dec.\r\t^ add end',			#stamp : 'lr 6/12/2010 08:30',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '468' ],		#self : OmReference [ '469' ],		#time : DateAndTime [ '2020-01-07T02:12:43.160626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPScriptingTest,				#isMetaSide : false			},			#name : #straightLineParser,			#protocol : #examples,			#sourceCode : 'straightLineParser\r\t| goal stm stmList id char dec exp expList mulExp primExp nonzero num lower upper |\r\tgoal := PPUnresolvedParser new.\r\tstmList := PPUnresolvedParser new.\r\tstm := PPUnresolvedParser new.\r\texp := PPUnresolvedParser new.\r\texpList := PPUnresolvedParser new.\r\tmulExp := PPUnresolvedParser new.\r\tprimExp := PPUnresolvedParser new.\r\t\r\tlower := ($a to: $z) asParser.\r\tupper := ($A to: $Z) asParser.\r\tchar := lower / upper.\r\tnonzero := ($1 to: $9) asParser.\r\tdec := ($0 to: $9) asParser.\r\tid := char, ( char / dec ) star.\r\tnum := $0 asParser / ( nonzero, dec star).\r\r\tgoal def: stmList end.\r\tstmList def: stm , ( $; asParser, stm ) star.\r\tstm def: ( id, \':=\' asParser, exp )\r\t\t/ ( \'print\' asParser, $( asParser, expList, $) asParser ). \r\texp def: mulExp, ( ( $+ asParser / $- asParser ), mulExp ) star.\r\texpList def: exp, ( $, asParser, exp ) star.\r\tmulExp def: primExp, ( ( $* asParser / $/ asParser ), primExp ) star.\r\tprimExp def: id\r\t\t/ num\r\t\t/ ( $( asParser, stmList, $, asParser, exp, $) asParser ).\r\t^ goal\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPScriptingTest,				#isMetaSide : false			},			#name : #straightLineParser,			#protocol : #examples,			#sourceCode : 'straightLineParser\r\t| goal stm stmList id char dec exp expList mulExp primExp nonzero num lower upper |\r\tgoal := PPUnresolvedParser new.\r\tstmList := PPUnresolvedParser new.\r\tstm := PPUnresolvedParser new.\r\texp := PPUnresolvedParser new.\r\texpList := PPUnresolvedParser new.\r\tmulExp := PPUnresolvedParser new.\r\tprimExp := PPUnresolvedParser new.\r\t\r\tlower := $a - $z.\r\tupper := $A - $Z.\r\tchar := lower / upper.\r\tnonzero := $1 - $9.\r\tdec := $0 - $9.\r\tid := char, ( char / dec ) star.\r\tnum := $0 asParser / ( nonzero, dec star).\r\r\tgoal def: stmList end.\r\tstmList def: stm , ( $; asParser, stm ) star.\r\tstm def: ( id, \':=\' asParser, exp )\r\t\t/ ( \'print\' asParser, $( asParser, expList, $) asParser ). \r\texp def: mulExp, ( ( $+ asParser / $- asParser ), mulExp ) star.\r\texpList def: exp, ( $, asParser, exp ) star.\r\tmulExp def: primExp, ( ( $* asParser / $/ asParser ), primExp ) star.\r\tprimExp def: id\r\t\t/ num\r\t\t/ ( $( asParser, stmList, $, asParser, exp, $) asParser ).\r\t^ goal\r',			#stamp : 'lr 10/20/2008 13:27',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '469' ],		#self : OmReference [ '470' ],		#time : DateAndTime [ '2020-01-07T02:12:43.162626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Stream,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asPetitStream\r\t^ self contents asPetitStream',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Stream,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asPetitStream\r\t^ self contents asPetitStream',			#stamp : 'lr 4/8/2010 14:46',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '470' ],		#self : OmReference [ '471' ],		#time : DateAndTime [ '2020-01-07T02:12:43.168626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Stream,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*PetitParser',			#sourceCode : 'asPetitStream\r\t^ self contents asPetitStream',			#stamp : 'lr 4/8/2010 14:46',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Stream,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asPetitStream\r\t^ self contents asPetitStream',			#stamp : 'lr 4/8/2010 14:46',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '471' ],		#self : OmReference [ '472' ],		#time : DateAndTime [ '2020-01-07T02:12:43.169626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPChoiceParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."\r\r\t| element |\r\t1 to: parsers size do: [ :index |\r\t\telement := (parsers at: index)\r\t\t\tparseOn: aPPContext.\r\t\telement isPetitFailure\r\t\t\tifFalse: [ ^ element ] ].\r\t^ element',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPChoiceParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."\r\r\t| element |\r\t1 to: parsers size do: [ :index |\r\t\telement := (parsers at: index)\r\t\t\tparseOn: aStream.\r\t\telement isPetitFailure\r\t\t\tifFalse: [ ^ element ] ].\r\t^ element',			#stamp : 'lr 5/22/2010 11:48',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '472' ],		#self : OmReference [ '473' ],		#time : DateAndTime [ '2020-01-07T02:12:43.171626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLazyRepeatingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| memento element elements |\r\tmemento := aPPContext remember.\r\telements := OrderedCollection new.\r\t[ elements size < min ] whileTrue: [\r\t\t(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [\r\t\t\taPPContext restore: memento.\r\t\t\t^ element ].\r\t\telements addLast: element ].\r\t[ self matchesLimitOn: aPPContext ] whileFalse: [\r\t\telements size < max ifFalse: [\r\t\t\taPPContext restore: memento.\r\t\t\t^ PPFailure message: \'overflow\' context: aPPContext at: memento position ].\r\t\telement := parser parseOn: aPPContext.\r\t\telement isPetitFailure ifTrue: [\r\t\t\taPPContext restore: memento.\r\t\t\t^ element ].\r\t\telements addLast: element ].\r\t^ elements asArray',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLazyRepeatingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| start element elements |\r\tstart := aStream position.\r\telements := OrderedCollection new.\r\t[ elements size < min ] whileTrue: [\r\t\t(element := parser parseOn: aStream) isPetitFailure ifTrue: [\r\t\t\taStream position: start.\r\t\t\t^ element ].\r\t\telements addLast: element ].\r\t[ self matchesLimitOn: aStream ] whileFalse: [\r\t\telements size < max ifFalse: [\r\t\t\taStream position: start.\r\t\t\t^ PPFailure message: \'overflow\' at: start ].\r\t\telement := parser parseOn: aStream.\r\t\telement isPetitFailure ifTrue: [\r\t\t\taStream position: start.\r\t\t\t^ element ].\r\t\telements addLast: element ].\r\t^ elements asArray',			#stamp : 'lr 4/2/2011 10:14',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '473' ],		#self : OmReference [ '474' ],		#time : DateAndTime [ '2020-01-07T02:12:43.173626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser that accepts the receiving string."\r\r\t^ PPLiteralSequenceParser on: self',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser that accepts the receiving string."\r\r\t^ PPLiteralSequenceParser on: self',			#stamp : 'lr 11/29/2011 20:48',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '474' ],		#self : OmReference [ '475' ],		#time : DateAndTime [ '2020-01-07T02:12:43.179626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser\r\t"Answer a parser that accepts the receiving string."\r\r\t^ PPLiteralSequenceParser on: self',			#stamp : 'lr 11/29/2011 20:48',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser that accepts the receiving string."\r\r\t^ PPLiteralSequenceParser on: self',			#stamp : 'lr 11/29/2011 20:48',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '475' ],		#self : OmReference [ '476' ],		#time : DateAndTime [ '2020-01-07T02:12:43.180626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExpressionParser,				#isMetaSide : false			},			#name : #'build:prefix:',			#protocol : #private,			#sourceCode : 'build: aParser prefix: aChoiceParser\r\t^ aChoiceParser star , aParser map: [ :ops :term | ops reverse inject: term into: [ :result :operator | operator first value: operator second value: result ] ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPExpressionParser,				#isMetaSide : false			},			#name : #'build:prefix:',			#protocol : #private,			#sourceCode : 'build: aParser prefix: aChoiceParser\r\t^ aChoiceParser star , aParser map: [ :ops :term | ops reversed inject: term into: [ :result :operator | operator first value: operator second value: result ] ]',			#stamp : 'lr 12/4/2009 17:39',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '476' ],		#self : OmReference [ '477' ],		#time : DateAndTime [ '2020-01-07T02:12:43.182626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Symbol,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."\r\r\t^ PPPredicateObjectParser perform: self',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Symbol,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."\r\r\t^ PPPredicateObjectParser perform: self',			#stamp : 'lr 12/18/2011 15:58',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '477' ],		#self : OmReference [ '478' ],		#time : DateAndTime [ '2020-01-07T02:12:43.187626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Symbol,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser\r\t"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."\r\r\t^ PPPredicateObjectParser perform: self',			#stamp : 'lr 12/18/2011 15:58',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Symbol,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."\r\r\t^ PPPredicateObjectParser perform: self',			#stamp : 'lr 12/18/2011 15:58',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '478' ],		#self : OmReference [ '479' ],		#time : DateAndTime [ '2020-01-07T02:12:43.188626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #any,			#protocol : #factory-objects,			#sourceCode : 'any\r\t^self\r\t\tcacheAt: #\'any\'\r\t\tifAbsentPut: [ self\r\t\t\ton: [ :each | true ] message: \'input expected\'\r\t\t\tnegated: [ :each | false ] message: \'no input expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #any,			#protocol : #factory-objects,			#sourceCode : 'any\r\t^ self\r\t\ton: [ :each | true ] message: \'input expected\'\r\t\tnegated: [ :each | false ] message: \'no input expected\'',			#stamp : 'lr 6/12/2010 09:10',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '479' ],		#self : OmReference [ '480' ],		#time : DateAndTime [ '2020-01-07T02:12:43.190626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #blank,			#protocol : #factory-chars,			#sourceCode : 'blank\r\t^self\r\t\tcacheAt: #\'blank\'\r\t\tifAbsentPut: [ self\r\t\t\tchars: (String with: Character space with: Character tab) message: \'blank expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #blank,			#protocol : #factory-chars,			#sourceCode : 'blank\r\t^ self chars: (String with: Character space with: Character tab) message: \'blank expected\'',			#stamp : 'lr 8/25/2010 11:02',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '480' ],		#self : OmReference [ '481' ],		#time : DateAndTime [ '2020-01-07T02:12:43.192626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #cr,			#protocol : #factory-chars,			#sourceCode : 'cr\r\t^self\r\t\tcacheAt: #\'cr\'\r\t\tifAbsentPut: [ self char: (Character codePoint: 13) message: \'carriage return expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #cr,			#protocol : #factory-chars,			#sourceCode : 'cr\r\t^ self char: Character cr message: \'carriage return expected\'',			#stamp : 'lr 8/25/2010 11:02',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '481' ],		#self : OmReference [ '482' ],		#time : DateAndTime [ '2020-01-07T02:12:43.195626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #digit,			#protocol : #factory-chars,			#sourceCode : 'digit\r\t^self\r\t\tcacheAt: #\'digit\'\r\t\tifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isDigit ]) message: \'digit expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #digit,			#protocol : #factory-chars,			#sourceCode : 'digit\r\t^ self on: (PPCharSetPredicate on: [ :char | char isDigit ]) message: \'digit expected\'',			#stamp : 'lr 8/25/2010 11:06',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '482' ],		#self : OmReference [ '483' ],		#time : DateAndTime [ '2020-01-07T02:12:43.196626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #hex,			#protocol : #factory-chars,			#sourceCode : 'hex\r\t^self\r\t\tcacheAt: #\'hex\'\r\t\tifAbsentPut: [ self\r\t\ton: (PPCharSetPredicate on: [ :char | \r\t\t\t(char between: $0 and: $9) \r\t\t\t\tor: [ (char between: $a and: $f) \r\t\t\t\tor: [ (char between: $A and: $F) ] ] ])\r\t\tmessage: \'hex digit expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #hex,			#protocol : #factory-chars,			#sourceCode : 'hex\r\t^ self \r\t\ton: (PPCharSetPredicate on: [ :char | \r\t\t\t(char between: $0 and: $9) \r\t\t\t\tor: [ (char between: $a and: $f) \r\t\t\t\tor: [ (char between: $A and: $F) ] ] ])\r\t\tmessage: \'hex digit expected\'',			#stamp : 'lr 8/25/2010 11:06',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '483' ],		#self : OmReference [ '484' ],		#time : DateAndTime [ '2020-01-07T02:12:43.198626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #letter,			#protocol : #factory-chars,			#sourceCode : 'letter\r\t^self\r\t\tcacheAt: #\'letter\'\r\t\tifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isLetter ]) message: \'letter expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #letter,			#protocol : #factory-chars,			#sourceCode : 'letter\r\t^ self on: (PPCharSetPredicate on: [ :char | char isLetter ]) message: \'letter expected\'',			#stamp : 'lr 8/25/2010 11:05',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '484' ],		#self : OmReference [ '485' ],		#time : DateAndTime [ '2020-01-07T02:12:43.200626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #lf,			#protocol : #factory-chars,			#sourceCode : 'lf\r\t^self\r\t\tcacheAt: #\'lf\'\r\t\tifAbsentPut: [ self char: (Character codePoint: 10) ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #lf,			#protocol : #factory-chars,			#sourceCode : 'lf\r\t^ self char: Character lf',			#stamp : 'lr 6/12/2010 09:10',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '485' ],		#self : OmReference [ '486' ],		#time : DateAndTime [ '2020-01-07T02:12:43.202626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #lowercase,			#protocol : #factory-chars,			#sourceCode : 'lowercase\r\t^self\r\t\tcacheAt: #\'lowercase\'\r\t\tifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isLowercase ]) message: \'lowercase letter expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #lowercase,			#protocol : #factory-chars,			#sourceCode : 'lowercase\r\t^ self on: (PPCharSetPredicate on: [ :char | char isLowercase ]) message: \'lowercase letter expected\'',			#stamp : 'lr 8/25/2010 11:06',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '486' ],		#self : OmReference [ '487' ],		#time : DateAndTime [ '2020-01-07T02:12:43.204626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #newline,			#protocol : #factory-chars,			#sourceCode : 'newline\r\t^self\r\t\tcacheAt: #\'newline\'\r\t\tifAbsentPut: [ self chars: (String with: (Character codePoint: 13) with: (Character codePoint: 10)) message: \'newline expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #newline,			#protocol : #factory-chars,			#sourceCode : 'newline\r\t^ self chars: (String with: Character cr with: Character lf) message: \'newline expected\'',			#stamp : 'lr 8/25/2010 11:04',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '487' ],		#self : OmReference [ '488' ],		#time : DateAndTime [ '2020-01-07T02:12:43.207626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #punctuation,			#protocol : #factory-chars,			#sourceCode : 'punctuation\r\t^self\r\t\tcacheAt: #\'punctuation\'\r\t\tifAbsentPut: [ self chars: \'.,"\'\'?!;:#$%&()*+-/<>=@[]\\^_{}|~\' message: \'punctuation expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #punctuation,			#protocol : #factory-chars,			#sourceCode : 'punctuation\r\t^ self chars: \'.,"\'\'?!;:#$%&()*+-/<>=@[]\\^_{}|~\' message: \'punctuation expected\'',			#stamp : 'lr 8/25/2010 11:04',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '488' ],		#self : OmReference [ '489' ],		#time : DateAndTime [ '2020-01-07T02:12:43.209626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #space,			#protocol : #factory-chars,			#sourceCode : 'space\r\t^self\r\t\tcacheAt: #\'space\'\r\t\tifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isSeparator ]) message: \'separator expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #space,			#protocol : #factory-chars,			#sourceCode : 'space\r\t^ self on: (PPCharSetPredicate on: [ :char | char isSeparator ]) message: \'separator expected\'',			#stamp : 'lr 8/25/2010 11:06',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '489' ],		#self : OmReference [ '490' ],		#time : DateAndTime [ '2020-01-07T02:12:43.211626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #tab,			#protocol : #factory-chars,			#sourceCode : 'tab\r\t^self\r\t\tcacheAt: #\'tab\'\r\t\tifAbsentPut: [ self char: Character tab message: \'tab expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #tab,			#protocol : #factory-chars,			#sourceCode : 'tab\r\t^ self char: Character tab message: \'tab expected\'',			#stamp : 'lr 8/25/2010 11:04',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '490' ],		#self : OmReference [ '491' ],		#time : DateAndTime [ '2020-01-07T02:12:43.213626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #uppercase,			#protocol : #factory-chars,			#sourceCode : 'uppercase\r\t^self\r\t\tcacheAt: #\'uppercase\'\r\t\tifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isUppercase ]) message: \'uppercase letter expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #uppercase,			#protocol : #factory-chars,			#sourceCode : 'uppercase\r\t^ self on: (PPCharSetPredicate on: [ :char | char isUppercase ]) message: \'uppercase letter expected\'',			#stamp : 'lr 8/25/2010 11:06',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '491' ],		#self : OmReference [ '492' ],		#time : DateAndTime [ '2020-01-07T02:12:43.214626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #word,			#protocol : #factory-chars,			#sourceCode : 'word\r\t^self\r\t\tcacheAt: #\'word\'\r\t\tifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isAlphaNumeric ]) message: \'letter or digit expected\' ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'PPPredicateObjectParser class',				#isMetaSide : true			},			#name : #word,			#protocol : #factory-chars,			#sourceCode : 'word\r\t^ self on: (PPCharSetPredicate on: [ :char | char isAlphaNumeric ]) message: \'letter or digit expected\'',			#stamp : 'lr 8/25/2010 11:06',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '492' ],		#self : OmReference [ '493' ],		#time : DateAndTime [ '2020-01-07T02:12:43.216626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateObjectParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t^ (aPPContext atEnd not and: [ predicate value: aPPContext uncheckedPeek ])\r\t\tifFalse: [ PPFailure message: predicateMessage context: aPPContext ]\r\t\tifTrue: [ aPPContext next ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateObjectParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t^ (aStream atEnd not and: [ predicate value: aStream uncheckedPeek ])\r\t\tifFalse: [ PPFailure message: predicateMessage at: aStream position ]\r\t\tifTrue: [ aStream next ]',			#stamp : 'lr 9/30/2010 11:05',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '493' ],		#self : OmReference [ '494' ],		#time : DateAndTime [ '2020-01-07T02:12:43.219626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateSequenceParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| memento result |\r\tmemento := aPPContext remember.\r\tresult := aPPContext stream next: size.\r\t(result size = size and: [ predicate value: result ])\r\t\tifTrue: [ ^ result ].\r\taPPContext restore: memento.\r\t^ PPFailure message: predicateMessage context: aPPContext',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateSequenceParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| position result |\r\tposition := aStream position.\r\tresult := aStream next: size.\r\t(result size = size and: [ predicate value: result ])\r\t\tifTrue: [ ^ result ].\r\taStream position: position.\r\t^ PPFailure message: predicateMessage at: aStream position',			#stamp : 'lr 6/12/2010 09:25',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '494' ],		#self : OmReference [ '495' ],		#time : DateAndTime [ '2020-01-07T02:12:43.220626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testCollection,			#protocol : #testing,			#sourceCode : 'testCollection\r\t| input result |\r\tinput := \'foo    \'.\r\tresult := self parse: input using: self identifier.\r\tself assert: result collection equals: input.\r\tself assert: result collection == input',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testCollection,			#protocol : #testing,			#sourceCode : 'testCollection\r\t| input result |\r\tinput := \'foo    \'.\r\tresult := self \r\t\tparse: input\r\t\tusing: self identifier.\r\tself assert: (result collection = input).\r\tself assert: (result collection == input)',			#stamp : 'lr 4/3/2009 08:49',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '495' ],		#self : OmReference [ '496' ],		#time : DateAndTime [ '2020-01-07T02:12:43.222626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testColumn,			#protocol : #testing-querying,			#sourceCode : 'testColumn\r\t| input parser result |\r\tinput := \'1\' , (String with: (Character codePoint: 13)) , \'12\' , (String with: (Character codePoint: 13) with: (Character codePoint: 10)) , \'123\'\r\t\t, (String with: (Character codePoint: 10)) , \'1234\'.\r\tparser := #any asParser token star.\r\tresult := parser parse: input.\r\tresult with: #(1 2 1 2 3 4 1 2 3 4 1 2 3 4) do: [ :token :line | self assert: token column equals: line ]',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testColumn,			#protocol : #testing-querying,			#sourceCode : 'testColumn\r\t| input parser result |\r\tinput := \'1\' , (String with: Character cr) , \'12\' , (String with: Character cr with: Character lf) , \'123\' , (String with: Character lf) , \'1234\'.\r\tparser := #any asParser token star.\r\tresult := parser parse: input.\r\tresult \r\t\twith:  #(1 2 1 2 3 4 1 2 3 4 1 2 3 4)\r\t\tdo: [ :token :line | self assert: token column = line ]',			#stamp : 'lr 6/16/2010 08:08',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '496' ],		#self : OmReference [ '497' ],		#time : DateAndTime [ '2020-01-07T02:12:43.224626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testCopyFromTo,			#protocol : #testing-copying,			#sourceCode : 'testCopyFromTo\r\t| result other |\r\tresult := PPToken on: \'abc\'.\r\tother := result copyFrom: 2 to: 2.\r\tself assert: other size equals: 1.\r\tself assert: other start equals: 2.\r\tself assert: other stop equals: 2.\r\tself assert: other collection equals: result collection',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testCopyFromTo,			#protocol : #testing-copying,			#sourceCode : 'testCopyFromTo\r\t| result other |\r\tresult := PPToken on: \'abc\'.\r\tother := result copyFrom: 2 to: 2.\r\t\r\tself assert: other size = 1.\r\tself assert: other start = 2.\r\tself assert: other stop = 2.\r\tself assert: other collection = result collection',			#stamp : 'lr 4/21/2009 08:50',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '497' ],		#self : OmReference [ '498' ],		#time : DateAndTime [ '2020-01-07T02:12:43.225626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testEquality,			#protocol : #testing-comparing,			#sourceCode : 'testEquality\r\t| token1 token2 |\r\ttoken1 := self parse: \'foo\' using: self identifier.\r\ttoken2 := self parse: \'foo\' using: self identifier.\r\tself deny: token1 == token2.\r\tself assert: token1 equals: token2.\r\tself assert: token1 hash equals: token2 hash',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testEquality,			#protocol : #testing-comparing,			#sourceCode : 'testEquality\r\t| token1 token2 |\r\ttoken1 := self  parse: \'foo\' using: self identifier.\r\ttoken2 := self  parse: \'foo\' using: self identifier.\r\tself deny: token1 == token2.\r\tself assert: token1 = token2.\r\tself assert: token1 hash = token2 hash.',			#stamp : 'lr 10/23/2009 11:37',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '498' ],		#self : OmReference [ '499' ],		#time : DateAndTime [ '2020-01-07T02:12:43.227626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testInputValue,			#protocol : #testing-values,			#sourceCode : 'testInputValue\r\t| input result |\r\tinput := \'foo\'.\r\tresult := self parse: input using: self identifier.\r\tself assert: result inputValue equals: input.\r\tself deny: result inputValue == input',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testInputValue,			#protocol : #testing-values,			#sourceCode : 'testInputValue\r\t| input result |\r\tinput := \'foo\'.\r\tresult := self \r\t\tparse: input\r\t\tusing: self identifier.\r\tself assert: result inputValue = input.\r\tself deny: result inputValue == input',			#stamp : 'lr 2/26/2013 00:38',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '499' ],		#self : OmReference [ '500' ],		#time : DateAndTime [ '2020-01-07T02:12:43.229626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testLine,			#protocol : #testing-querying,			#sourceCode : 'testLine\r\t| input parser result |\r\tinput := \'1\' , (String with: (Character codePoint: 13)) , \'12\' , (String with: (Character codePoint: 13) with: (Character codePoint: 10)) , \'123\'\r\t\t, (String with: (Character codePoint: 10)) , \'1234\'.\r\tparser := #any asParser token star.\r\tresult := parser parse: input.\r\tresult with: #(1 1 2 2 2 2 3 3 3 3 4 4 4 4) do: [ :token :line | self assert: token line equals: line ]',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testLine,			#protocol : #testing-querying,			#sourceCode : 'testLine\r\t| input parser result |\r\tinput := \'1\' , (String with: Character cr) , \'12\' , (String with: Character cr with: Character lf) , \'123\' , (String with: Character lf) , \'1234\'.\r\tparser := #any asParser token star.\r\tresult := parser parse: input.\r\tresult \r\t\twith: #(1 1 2 2 2 2 3 3 3 3 4 4 4 4) \r\t\tdo: [ :token :line | self assert: token line = line ]',			#stamp : 'lr 6/16/2010 08:05',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '500' ],		#self : OmReference [ '501' ],		#time : DateAndTime [ '2020-01-07T02:12:43.231626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testParsedValue,			#protocol : #testing-values,			#sourceCode : 'testParsedValue\r\t| input result |\r\tinput := \'foo\'.\r\tresult := self parse: input using: self identifier.\r\tself assert: result parsedValue equals: #($f $o $o)',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testParsedValue,			#protocol : #testing-values,			#sourceCode : 'testParsedValue\r\t| input result |\r\tinput := \'foo\'.\r\tresult := self \r\t\tparse: input\r\t\tusing: self identifier.\r\tself assert: result parsedValue = #($f $o $o)',			#stamp : 'lr 2/26/2013 00:39',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '501' ],		#self : OmReference [ '502' ],		#time : DateAndTime [ '2020-01-07T02:12:43.232626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testPrinting,			#protocol : #testing,			#sourceCode : 'testPrinting\r\t| result |\r\tresult := PPToken on: \'var\'.\r\tself assert: result printString includesSubstring: \'PPToken[1,3]\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testPrinting,			#protocol : #testing,			#sourceCode : 'testPrinting\r\t| result |\r\tresult := PPToken on: \'var\'.\r\tself assert: (result printString findString: \'PPToken[1,3]\') > 0',			#stamp : 'lr 3/17/2013 08:38',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '502' ],		#self : OmReference [ '503' ],		#time : DateAndTime [ '2020-01-07T02:12:43.234626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testSize,			#protocol : #testing,			#sourceCode : 'testSize\r\t| result |\r\tresult := self parse: \'foo\' using: self identifier.\r\tself assert: result size equals: 3',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testSize,			#protocol : #testing,			#sourceCode : 'testSize\r\t| result |\r\tresult := self \r\t\tparse: \'foo\'\r\t\tusing: self identifier.\r\tself assert: result size = 3',			#stamp : 'TestRunner 12/4/2009 19:16',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '503' ],		#self : OmReference [ '504' ],		#time : DateAndTime [ '2020-01-07T02:12:43.235626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testStart,			#protocol : #testing,			#sourceCode : 'testStart\r\t| result |\r\tresult := self parse: \'foo\' using: self identifier.\r\tself assert: result start equals: 1',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testStart,			#protocol : #testing,			#sourceCode : 'testStart\r\t| result |\r\tresult := self \r\t\tparse: \'foo\'\r\t\tusing: self identifier.\r\tself assert: result start = 1',			#stamp : 'TestRunner 12/4/2009 19:16',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '504' ],		#self : OmReference [ '505' ],		#time : DateAndTime [ '2020-01-07T02:12:43.237626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testStop,			#protocol : #testing,			#sourceCode : 'testStop\r\t| result |\r\tresult := self parse: \'foo\' using: self identifier.\r\tself assert: result stop equals: 3',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPTokenTest,				#isMetaSide : false			},			#name : #testStop,			#protocol : #testing,			#sourceCode : 'testStop\r\t| result |\r\tresult := self \r\t\tparse: \'foo\'\r\t\tusing: self identifier.\r\tself assert: result stop = 3',			#stamp : 'TestRunner 12/4/2009 19:16',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '505' ],		#self : OmReference [ '506' ],		#time : DateAndTime [ '2020-01-07T02:12:43.240626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Character,				#isMetaSide : false			},			#name : #-,			#protocol : #'*petitparser-core-operators',			#sourceCode : '- aCharacter\r\t"Create a range of characters between the receiver and the argument."\r\t\r\t^ PPPredicateObjectParser between: self and: aCharacter',			#stamp : 'lr 6/12/2010 09:04',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '506' ],		#self : OmReference [ '507' ],		#time : DateAndTime [ '2020-01-07T02:12:43.243626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Character,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser that accepts the receiving character."\r\t\r\t^ PPLiteralObjectParser on: self',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Character,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser that accepts the receiving character."\r\t\r\t^ PPLiteralObjectParser on: self',			#stamp : 'lr 12/18/2011 15:58',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '507' ],		#self : OmReference [ '508' ],		#time : DateAndTime [ '2020-01-07T02:12:43.247626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Character,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser\r\t"Answer a parser that accepts the receiving character."\r\t\r\t^ PPLiteralObjectParser on: self',			#stamp : 'lr 12/18/2011 15:58',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Character,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser that accepts the receiving character."\r\t\r\t^ PPLiteralObjectParser on: self',			#stamp : 'lr 12/18/2011 15:58',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '508' ],		#self : OmReference [ '509' ],		#time : DateAndTime [ '2020-01-07T02:12:43.248626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPDelegateParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t^ parser parseOn: aPPContext',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPDelegateParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t^ parser parseOn: aStream',			#stamp : 'lr 2/7/2010 20:47',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '509' ],		#self : OmReference [ '510' ],		#time : DateAndTime [ '2020-01-07T02:12:43.251626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| memento contextMemento  aStream |\r\t"TODO: JK memoizing needs review!"\r\tself check: aPPContext.\r\tcontextMemento := aPPContext remember.\r\tmemento := (buffer at: contextMemento ifAbsentPut: [ PPMemento new ]).\r\t\r\tmemento contextMemento isNil\r\t\tifTrue: [\r\t\t\taStream := aPPContext stream.\r\t\t\tmemento result: (aStream size - aStream position + 2 < memento count\r\t\t\t\tifTrue: [ PPFailure message: \'overflow\' context: aPPContext ]\r\t\t\t\tifFalse: [ memento increment. parser parseOn: aPPContext ]).\r\t\t\tmemento contextMemento: aPPContext remember ]\r\t\tifFalse: [ aPPContext restore: memento contextMemento ].\r\t^ memento result.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| memento |\r\tstream == aStream\r\t\tifFalse: [ self reset: aStream ].\r\tmemento := (buffer at: stream position + 1)\r\t\tifNil: [ buffer at: stream position + 1 put: PPMemento new ].\r\tmemento position isNil\r\t\tifTrue: [\r\t\t\tmemento result: (stream size - stream position + 2 < memento count\r\t\t\t\tifTrue: [ PPFailure message: \'overflow\' at: stream position ]\r\t\t\t\tifFalse: [ memento increment. parser parseOn: stream ]).\r\t\t\tmemento position: stream position ]\r\t\tifFalse: [ stream position: memento position ].\r\t^ memento result',			#stamp : 'lr 8/1/2010 17:11',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '510' ],		#self : OmReference [ '511' ],		#time : DateAndTime [ '2020-01-07T02:12:43.253626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #'reset:',			#protocol : #private,			#sourceCode : 'reset: aPPContext\r\tbuffer := Dictionary new.\r\tidentifier := aPPContext identifier.',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #'reset:',			#protocol : #private,			#sourceCode : 'reset: aStream\r\tstream := aStream.\r\tbuffer := Array new: aStream size + 1',			#stamp : 'lr 4/2/2009 19:22',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '511' ],		#self : OmReference [ '512' ],		#time : DateAndTime [ '2020-01-07T02:12:43.255626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #'reset:',			#protocol : #parsing,			#sourceCode : 'reset: aStream\r\tstream := aStream.\r\tbuffer := Array new: aStream size + 1',			#stamp : 'lr 4/2/2009 19:22',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPMemoizedParser,				#isMetaSide : false			},			#name : #'reset:',			#protocol : #private,			#sourceCode : 'reset: aStream\r\tstream := aStream.\r\tbuffer := Array new: aStream size + 1',			#stamp : 'lr 4/2/2009 19:22',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '512' ],		#self : OmReference [ '513' ],		#time : DateAndTime [ '2020-01-07T02:12:43.256626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLiteralObjectParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t^ (aPPContext stream atEnd not and: [ literal = aPPContext stream uncheckedPeek ])\r\t\tifFalse: [ PPFailure message: message context: aPPContext ]\r\t\tifTrue: [ aPPContext next ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLiteralObjectParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t^ (aStream atEnd not and: [ literal = aStream uncheckedPeek ])\r\t\tifFalse: [ PPFailure message: message at: aStream position ]\r\t\tifTrue: [ aStream next ]',			#stamp : 'lr 10/30/2010 11:48',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '513' ],		#self : OmReference [ '514' ],		#time : DateAndTime [ '2020-01-07T02:12:43.257626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPActionParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| element |\r\t^ (element := parser parseOn: aPPContext) isPetitFailure\r\t\tifFalse: [ block value: element ]\r\t\tifTrue: [ element ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPActionParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| element |\r\t^ (element := parser parseOn: aStream) isPetitFailure\r\t\tifFalse: [ block value: element ]\r\t\tifTrue: [ element ]',			#stamp : 'lr 8/1/2010 17:10',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '514' ],		#self : OmReference [ '515' ],		#time : DateAndTime [ '2020-01-07T02:12:43.259626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLiteralSequenceParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| memento result |\r\tmemento := aPPContext remember.\r\tresult := aPPContext next: size.\r\tliteral = result ifTrue: [ ^ result ].\r\taPPContext restore: memento.\r\t^ PPFailure message: message context: aPPContext',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLiteralSequenceParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| position result |\r\tposition := aStream position.\r\tresult := aStream next: size.\r\tliteral = result ifTrue: [ ^ result ].\r\taStream position: position.\r\t^ PPFailure message: message at: aStream position',			#stamp : 'lr 10/30/2010 11:48',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '515' ],		#self : OmReference [ '516' ],		#time : DateAndTime [ '2020-01-07T02:12:43.261626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPNotParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| element memento |\r\tmemento := aPPContext remember.\r\telement := parser parseOn: aPPContext.\r\taPPContext restore: memento.\r\t^ element isPetitFailure\r\t\tifFalse: [ PPFailure message: \'\' context: aPPContext ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPNotParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| element position |\r\tposition := aStream position.\r\telement := parser parseOn: aStream.\r\taStream position: position.\r\t^ element isPetitFailure\r\t\tifFalse: [ PPFailure message: \'\' at: aStream position ]',			#stamp : 'lr 8/1/2010 17:11',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '516' ],		#self : OmReference [ '517' ],		#time : DateAndTime [ '2020-01-07T02:12:43.263626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCharSetPredicate,				#isMetaSide : false			},			#name : #'initializeOn:',			#protocol : #initialization,			#sourceCode : 'initializeOn: aBlock\r\tblock := aBlock.\r\tclassification := Array new: 255.\r\t1 to: classification size do: [ :index |\r\t\tclassification at: index put: (block\r\t\t\tvalue: (Character codePoint: index)) ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCharSetPredicate,				#isMetaSide : false			},			#name : #'initializeOn:',			#protocol : #initialization,			#sourceCode : 'initializeOn: aBlock\r\tblock := aBlock.\r\tclassification := Array new: 255.\r\t1 to: classification size do: [ :index |\r\t\tclassification at: index put: (block\r\t\t\tvalue: (Character value: index)) ]',			#stamp : 'lr 8/30/2010 12:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '517' ],		#self : OmReference [ '518' ],		#time : DateAndTime [ '2020-01-07T02:12:43.264626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAndParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| element memento |\r\tmemento := aPPContext remember.\r\telement := parser parseOn: aPPContext.\r\taPPContext restore: memento.\r\t^ element',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAndParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| element position |\r\tposition := aStream position.\r\telement := parser parseOn: aStream.\r\taStream position: position.\r\t^ element',			#stamp : 'lr 8/1/2010 17:10',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '518' ],		#self : OmReference [ '519' ],		#time : DateAndTime [ '2020-01-07T02:12:43.266626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Text,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asPetitStream\r\t^ string asPetitStream',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Text,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asPetitStream\r\t^ string asPetitStream',			#stamp : 'lr 2/7/2010 20:53',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '519' ],		#self : OmReference [ '520' ],		#time : DateAndTime [ '2020-01-07T02:12:43.272626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Text,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*PetitParser',			#sourceCode : 'asPetitStream\r\t^ string asPetitStream',			#stamp : 'lr 2/7/2010 20:53',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Text,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asPetitStream\r\t^ string asPetitStream',			#stamp : 'lr 2/7/2010 20:53',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '520' ],		#self : OmReference [ '521' ],		#time : DateAndTime [ '2020-01-07T02:12:43.273626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPWrappingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t^ block value: aPPContext value: [ parser parseOn: aPPContext ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPWrappingParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t^ block value: aStream value: [ parser parseOn: aStream ]',			#stamp : 'lr 5/12/2010 20:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '521' ],		#self : OmReference [ '522' ],		#time : DateAndTime [ '2020-01-07T02:12:43.275626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #'parsedCharacterSet:',			#protocol : #utilities,			#sourceCode : 'parsedCharacterSet: aParser\r\t| result |\r\tresult := WriteStream on: String new.\r\tself charactersDo: [ :char |\r\t\t(aParser matches: (char asString))\r\t\t\tifTrue: [ result nextPut: char ] ].\r\t^ result contents',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #'parsedCharacterSet:',			#protocol : #utilities,			#sourceCode : 'parsedCharacterSet: aParser\r\t| result |\r\tresult := WriteStream on: String new.\r\tself charactersDo: [ :char |\r\t\t(aParser matches: (String with: char))\r\t\t\tifTrue: [ result nextPut: char ] ].\r\t^ result contents',			#stamp : 'lr 6/12/2010 08:37',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '522' ],		#self : OmReference [ '523' ],		#time : DateAndTime [ '2020-01-07T02:12:43.277626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testCr,			#protocol : #testing-chars,			#sourceCode : 'testCr\r\t| parser |\r\tparser := #cr asParser.\r\tself assertCharacterSets: parser.\r\tself assert: parser parse: (String with: (Character codePoint: 13)) to: (Character codePoint: 13)',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testCr,			#protocol : #testing-chars,			#sourceCode : 'testCr\r\t| parser |\r\tparser := #cr asParser.\r\tself assertCharacterSets: parser.\r\tself assert: parser parse: (String with: Character cr) to: Character cr',			#stamp : 'lr 11/29/2009 09:32',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '523' ],		#self : OmReference [ '524' ],		#time : DateAndTime [ '2020-01-07T02:12:43.279626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testOnMessage,			#protocol : #testing,			#sourceCode : 'testOnMessage\r\t| block parser |\r\tblock := [ :char | char = $* ].\r\tparser := PPPredicateObjectParser on: block message: \'starlet\'.\r\tself assert: parser block equals: block.\r\tself assert: parser message equals: \'starlet\'.\r\tself assertCharacterSets: parser.\r\tself assert: parser parse: \'*\' to: $*.\r\tself\r\t\tassert: parser\r\t\tparse: \'**\'\r\t\tto: $*\r\t\tend: 1.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'1\'.\r\tself assert: parser fail: \'a\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testOnMessage,			#protocol : #testing,			#sourceCode : 'testOnMessage\r\t| block parser |\r\tblock := [ :char | char = $* ].\r\tparser := PPPredicateObjectParser on: block message: \'starlet\'.\r\tself assert: parser block = block.\r\tself assert: parser message = \'starlet\'.\r\t\r\tself assertCharacterSets: parser.\r\tself assert: parser parse: \'*\' to: $*.\r\tself assert: parser parse: \'**\' to: $* end: 1.\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \'1\'.\r\tself assert: parser fail: \'a\'',			#stamp : 'lr 6/12/2010 09:17',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '524' ],		#self : OmReference [ '525' ],		#time : DateAndTime [ '2020-01-07T02:12:43.280626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testSequenceParser,			#protocol : #testing-sequence,			#sourceCode : 'testSequenceParser\r\t| parser |\r\tparser := PPPredicateSequenceParser\r\t\ton: [ :value | value first isUppercase ]\r\t\tmessage: \'uppercase 3 letter words\'\r\t\tsize: 3.\r\tself assert: parser size equals: 3.\r\tself assert: parser parse: \'Abc\'.\r\tself assert: parser parse: \'ABc\'.\r\tself assert: parser parse: \'ABC\'.\r\tself assert: parser fail: \'abc\'.\r\tself assert: parser fail: \'aBC\'.\r\tself assert: parser fail: \'Ab\'.\r\tparser := parser negate.\r\tself assert: parser size equals: 3.\r\tself assert: parser fail: \'Abc\'.\r\tself assert: parser fail: \'ABc\'.\r\tself assert: parser fail: \'ABC\'.\r\tself assert: parser parse: \'abc\'.\r\tself assert: parser parse: \'aBC\'.\r\tself assert: parser fail: \'Ab\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPPredicateTest,				#isMetaSide : false			},			#name : #testSequenceParser,			#protocol : #testing-sequence,			#sourceCode : 'testSequenceParser\r\t| parser |\r\tparser := PPPredicateSequenceParser \r\t\ton: [ :value | value first isUppercase ] \r\t\tmessage: \'uppercase 3 letter words\'\r\t\tsize: 3.\r\tself assert: parser size = 3.\r\tself assert: parser parse: \'Abc\'.\r\tself assert: parser parse: \'ABc\'.\r\tself assert: parser parse: \'ABC\'.\r\tself assert: parser fail: \'abc\'.\r\tself assert: parser fail: \'aBC\'.\r\tself assert: parser fail: \'Ab\'.\r\t\r\tparser := parser negate.\r\tself assert: parser size = 3.\r\tself assert: parser fail: \'Abc\'.\r\tself assert: parser fail: \'ABc\'.\r\tself assert: parser fail: \'ABC\'.\r\tself assert: parser parse: \'abc\'.\r\tself assert: parser parse: \'aBC\'.\r\tself assert: parser fail: \'Ab\'',			#stamp : 'lr 6/12/2010 09:27',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '525' ],		#self : OmReference [ '526' ],		#time : DateAndTime [ '2020-01-07T02:12:43.282626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testAnd,			#protocol : #testing-curch,			#sourceCode : 'testAnd\r\tself assert: self parserClass and equals: #(\'p\' #(\'q\' #(#(\'p\' \'q\') \'p\')))',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testAnd,			#protocol : #testing-curch,			#sourceCode : 'testAnd\r\tself assert: self parserClass and = #(\'p\' (\'q\' ((\'p\' \'q\') \'p\')))',			#stamp : 'FirstnameLastname 11/26/2009 21:53',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '526' ],		#self : OmReference [ '527' ],		#time : DateAndTime [ '2020-01-07T02:12:43.284626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testFalse,			#protocol : #testing-curch,			#sourceCode : 'testFalse\r\tself assert: self parserClass false equals: #(\'x\' #(\'y\' \'y\'))',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testFalse,			#protocol : #testing-curch,			#sourceCode : 'testFalse\r\tself assert: self parserClass false = #(\'x\' (\'y\' \'y\'))',			#stamp : 'FirstnameLastname 11/26/2009 21:53',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '527' ],		#self : OmReference [ '528' ],		#time : DateAndTime [ '2020-01-07T02:12:43.287626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testIfThenElse,			#protocol : #testing-curch,			#sourceCode : 'testIfThenElse\r\tself assert: self parserClass ifthenelse equals: #(\'p\' \'p\')',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testIfThenElse,			#protocol : #testing-curch,			#sourceCode : 'testIfThenElse\r\tself assert: self parserClass ifthenelse = #(\'p\' \'p\')',			#stamp : 'FirstnameLastname 11/26/2009 21:53',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '528' ],		#self : OmReference [ '529' ],		#time : DateAndTime [ '2020-01-07T02:12:43.288626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testNot,			#protocol : #testing-curch,			#sourceCode : 'testNot\r\tself assert: self parserClass not equals: #(\'p\' #(\'a\' #(\'b\' #(#(\'p\' \'b\') \'a\'))))',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testNot,			#protocol : #testing-curch,			#sourceCode : 'testNot\r\tself assert: self parserClass not = #(\'p\' (\'a\' (\'b\' ((\'p\' \'b\') \'a\'))))',			#stamp : 'FirstnameLastname 11/26/2009 21:53',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '529' ],		#self : OmReference [ '530' ],		#time : DateAndTime [ '2020-01-07T02:12:43.290626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testOr,			#protocol : #testing-curch,			#sourceCode : 'testOr\r\tself assert: self parserClass or equals: #(\'p\' #(\'q\' #(#(\'p\' \'p\') \'q\')))',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testOr,			#protocol : #testing-curch,			#sourceCode : 'testOr\r\tself assert: self parserClass or = #(\'p\' (\'q\' ((\'p\' \'p\') \'q\')))',			#stamp : 'FirstnameLastname 11/26/2009 21:53',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '530' ],		#self : OmReference [ '531' ],		#time : DateAndTime [ '2020-01-07T02:12:43.292626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testParseOnError,			#protocol : #testing-utilities,			#sourceCode : 'testParseOnError\r\t| beenHere |\r\tresult := self parserClass parse: \'\\x. y\' onError: [ self fail ].\r\tself assert: result equals: #(\'x\' \'y\').\r\tbeenHere := false.\r\tresult := self parserClass parse: \'\\x.\' onError: [ beenHere := true ].\r\tself assert: beenHere.\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\x. \'\r\t\tonError: [ :fail | \r\t\t\tbeenHere := true.\r\t\t\tfail ].\r\tself assert: beenHere.\r\tself assert: result message includesSubstring: \'letter\'.\r\tself assert: result message includesSubstring: \'expected\'.\r\tself assert: result position equals: 4.\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\x. \'\r\t\tonError: [ :msg :pos | \r\t\t\tself assert: msg includesSubstring: \'letter\'.\r\t\t\tself assert: msg includesSubstring: \'expected\'.\r\t\t\tself assert: pos equals: 4.\r\t\t\tbeenHere := true ].\r\tself assert: result.\r\tself assert: beenHere\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testParseOnError,			#protocol : #testing-utilities,			#sourceCode : 'testParseOnError\r\t| beenHere |\r\tresult := self parserClass\r\t\tparse: \'\\x.y\'\r\t\tonError: [ self fail ].\r\tself assert: result = #(\'x\' \'y\').\r\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\x.\'\r\t\tonError: [ beenHere := true ].\r\tself assert: beenHere.\r\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\x.\'\r\t\tonError: [ :fail | beenHere := true. fail ].\r\tself assert: beenHere.\r\tself assert: (result message findString: \'$(\') > 0.\r\tself assert: (result message findString: \'expected\') > 0.\r\tself assert: (result position = 0).\r\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\x.\'\r\t\tonError: [ :msg :pos | \r\t\t\tself assert: (msg findString: \'$(\') > 0.\r\t\t\tself assert: (msg findString: \'expected\') > 0.\r\t\t\tself assert: (pos = 0).\r\t\t\tbeenHere := true ].\r\tself assert: result.\r\tself assert: beenHere',			#stamp : 'lr 3/17/2013 08:58',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '531' ],		#self : OmReference [ '532' ],		#time : DateAndTime [ '2020-01-07T02:12:43.294626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testParseStartingAtOnError,			#protocol : #testing-utilities,			#sourceCode : 'testParseStartingAtOnError\r\t| beenHere |\r\tresult := self parserClass parse: \'x\' startingAt: #variable onError: [ self fail ].\r\tself assert: result equals: \'x\'.\r\tbeenHere := false.\r\tresult := self parserClass parse: \'\\\' startingAt: #variable onError: [ beenHere := true ].\r\tself assert: beenHere.\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\ \'\r\t\tstartingAt: #variable\r\t\tonError: [ :fail | \r\t\t\tbeenHere := true.\r\t\t\tfail ].\r\tself assert: beenHere.\r\tself assert: result message equals: \'letter expected\'.\r\tself assert: result position equals: 0.\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\ \'\r\t\tstartingAt: #variable\r\t\tonError: [ :msg :pos | \r\t\t\tself assert: msg equals: \'letter expected\'.\r\t\t\tself assert: pos equals: 0.\r\t\t\tbeenHere := true ].\r\tself assert: beenHere\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testParseStartingAtOnError,			#protocol : #testing-utilities,			#sourceCode : 'testParseStartingAtOnError\r\t| beenHere |\r\tresult := self parserClass\r\t\tparse: \'x\'\r\t\tstartingAt: #variable\r\t\tonError: [ self fail ].\r\tself assert: result = \'x\'.\r\t\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\\'\r\t\tstartingAt: #variable\r\t\tonError: [ beenHere := true ].\r\tself assert: beenHere.\r\t\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\\'\r\t\tstartingAt: #variable\r\t\tonError: [ :fail | beenHere := true. fail ].\r\tself assert: beenHere.\r\tself assert: result message = \'letter expected\'.\r\tself assert: result position = 0.\r\r\tbeenHere := false.\r\tresult := self parserClass\r\t\tparse: \'\\\'\r\t\tstartingAt: #variable\r\t\tonError: [ :msg :pos | \r\t\t\tself assert: msg = \'letter expected\'.\r\t\t\tself assert: pos = 0.\r\t\t\tbeenHere := true ].\r\tself assert: beenHere',			#stamp : 'lr 3/17/2013 08:56',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '532' ],		#self : OmReference [ '533' ],		#time : DateAndTime [ '2020-01-07T02:12:43.296626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testTrue,			#protocol : #testing-curch,			#sourceCode : 'testTrue\r\tself assert: self parserClass true equals: #(\'x\' #(\'y\' \'x\'))',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLambdaParserTest,				#isMetaSide : false			},			#name : #testTrue,			#protocol : #testing-curch,			#sourceCode : 'testTrue\r\tself assert: self parserClass true = #(\'x\' (\'y\' \'x\'))',			#stamp : 'FirstnameLastname 11/26/2009 21:53',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '533' ],		#self : OmReference [ '534' ],		#time : DateAndTime [ '2020-01-07T02:12:43.299626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPComposedTest,				#isMetaSide : false			},			#name : #testEvenNumber,			#protocol : #testing,			#sourceCode : 'testEvenNumber\r\t"Create a grammar that parses an even number of a\'s and b\'s."\r\t\r\t| a as b bs s |\r\ta := $a asParser ==> [ :char | as := as + 1 ].\r\tb := $b asParser ==> [ :char | bs := bs + 1 ].\r\ts := (a / b) star >=> [ :stream :cc |\r\t\tas := bs := 0.\r\t\tcc value.\r\t\t(as even and: [ bs even ])\r\t\t\tifFalse: [ PPFailure message: \'Even number of a and b expected\' context: stream at: 0 ] ].\r\r\tself assert: s fail: \'a\' end: 1.\r\tself assert: s fail: \'b\' end: 1.\r\tself assert: s fail: \'ab\' end: 2.\r\tself assert: s fail: \'ba\' end: 2.\r\tself assert: s fail: \'aaa\' end: 3.\r\tself assert: s fail: \'bbb\' end: 3.\r\tself assert: s fail: \'aab\' end: 3.\r\tself assert: s fail: \'abb\' end: 3.\r\t\r\tself assert: s parse: \'\'.\r\tself assert: s parse: \'aa\'.\r\tself assert: s parse: \'bb\'.\r\tself assert: s parse: \'aaaa\'.\r\tself assert: s parse: \'aabb\'.\r\tself assert: s parse: \'abab\'.\r\tself assert: s parse: \'baba\'.\r\tself assert: s parse: \'bbaa\'.\r\tself assert: s parse: \'bbbb\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPComposedTest,				#isMetaSide : false			},			#name : #testEvenNumber,			#protocol : #testing,			#sourceCode : 'testEvenNumber\r\t"Create a grammar that parses an even number of a\'s and b\'s."\r\t\r\t| a as b bs s |\r\ta := $a asParser ==> [ :char | as := as + 1 ].\r\tb := $b asParser ==> [ :char | bs := bs + 1 ].\r\ts := (a / b) star >=> [ :stream :cc |\r\t\tas := bs := 0.\r\t\tcc value.\r\t\t(as even and: [ bs even ])\r\t\t\tifFalse: [ PPFailure message: \'Even number of a and b expected\' at: 0 ] ].\r\r\tself assert: s fail: \'a\' end: 1.\r\tself assert: s fail: \'b\' end: 1.\r\tself assert: s fail: \'ab\' end: 2.\r\tself assert: s fail: \'ba\' end: 2.\r\tself assert: s fail: \'aaa\' end: 3.\r\tself assert: s fail: \'bbb\' end: 3.\r\tself assert: s fail: \'aab\' end: 3.\r\tself assert: s fail: \'abb\' end: 3.\r\t\r\tself assert: s parse: \'\'.\r\tself assert: s parse: \'aa\'.\r\tself assert: s parse: \'bb\'.\r\tself assert: s parse: \'aaaa\'.\r\tself assert: s parse: \'aabb\'.\r\tself assert: s parse: \'abab\'.\r\tself assert: s parse: \'baba\'.\r\tself assert: s parse: \'bbaa\'.\r\tself assert: s parse: \'bbbb\'',			#stamp : 'lr 12/5/2010 14:25',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '534' ],		#self : OmReference [ '535' ],		#time : DateAndTime [ '2020-01-07T02:12:43.301626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPComposedTest,				#isMetaSide : false			},			#name : #testListOfIntegers,			#protocol : #testing,			#sourceCode : 'testListOfIntegers\r\t"S ::= S , number | number"\r\t\r\t| number list parser |\r\tnumber := #digit asParser plus flatten trim\r\t\t==> [ :node | node asInteger ].\r\tlist := (number separatedBy: $, asParser token trim)\r\t\t==> [ :node | node select: [ :each | each isKindOf: Integer ] ].\r\tparser := list end.\r\r\tself assert: parser parse: \'1\' to: (1 to: 1) asArray.\r\tself assert: parser parse: \'1,2\' to: (1 to: 2) asArray.\r\tself assert: parser parse: \'1,2,3\' to: (1 to: 3) asArray.\r\tself assert: parser parse: \'1,2,3,4\' to: (1 to: 4) asArray.\r\tself assert: parser parse: \'1,2,3,4,5\' to: (1 to: 5) asArray.\r\r\tself assert: parser parse: \'1\' to: (1 to: 1) asArray.\r\tself assert: parser parse: \'1, 2\' to: (1 to: 2) asArray.\r\tself assert: parser parse: \'1, 2, 3\' to: (1 to: 3) asArray.\r\tself assert: parser parse: \'1, 2, 3, 4\' to: (1 to: 4) asArray.\r\tself assert: parser parse: \'1, 2, 3, 4, 5\' to: (1 to: 5) asArray.\r\r\tself assert: parser parse: \'1\' to: (1 to: 1) asArray.\r\tself assert: parser parse: \'1 ,2\' to: (1 to: 2) asArray.\r\tself assert: parser parse: \'1 ,2 ,3\' to: (1 to: 3) asArray.\r\tself assert: parser parse: \'1 ,2 ,3 ,4\' to: (1 to: 4) asArray.\r\tself assert: parser parse: \'1 ,2 ,3 ,4 ,5\' to: (1 to: 5) asArray.\r\t\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \',\'.\r\tself assert: parser fail: \'1,\'.\r\tself assert: parser fail: \'1,,2\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPComposedTest,				#isMetaSide : false			},			#name : #testListOfIntegers,			#protocol : #testing,			#sourceCode : 'testListOfIntegers\r\t"S ::= S , number | number"\r\t\r\t| number list parser |\r\tnumber := #digit asParser plus flatten trim\r\t\t==> [ :node | node asInteger ].\r\tlist := (number separatedBy: $, asParser token trim)\r\t\t==> [ :node | node select: [ :each | each isInteger ] ].\r\tparser := list end.\r\r\tself assert: parser parse: \'1\' to: (1 to: 1) asArray.\r\tself assert: parser parse: \'1,2\' to: (1 to: 2) asArray.\r\tself assert: parser parse: \'1,2,3\' to: (1 to: 3) asArray.\r\tself assert: parser parse: \'1,2,3,4\' to: (1 to: 4) asArray.\r\tself assert: parser parse: \'1,2,3,4,5\' to: (1 to: 5) asArray.\r\r\tself assert: parser parse: \'1\' to: (1 to: 1) asArray.\r\tself assert: parser parse: \'1, 2\' to: (1 to: 2) asArray.\r\tself assert: parser parse: \'1, 2, 3\' to: (1 to: 3) asArray.\r\tself assert: parser parse: \'1, 2, 3, 4\' to: (1 to: 4) asArray.\r\tself assert: parser parse: \'1, 2, 3, 4, 5\' to: (1 to: 5) asArray.\r\r\tself assert: parser parse: \'1\' to: (1 to: 1) asArray.\r\tself assert: parser parse: \'1 ,2\' to: (1 to: 2) asArray.\r\tself assert: parser parse: \'1 ,2 ,3\' to: (1 to: 3) asArray.\r\tself assert: parser parse: \'1 ,2 ,3 ,4\' to: (1 to: 4) asArray.\r\tself assert: parser parse: \'1 ,2 ,3 ,4 ,5\' to: (1 to: 5) asArray.\r\t\r\tself assert: parser fail: \'\'.\r\tself assert: parser fail: \',\'.\r\tself assert: parser fail: \'1,\'.\r\tself assert: parser fail: \'1,,2\'',			#stamp : 'lr 2/25/2013 23:50',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '535' ],		#self : OmReference [ '536' ],		#time : DateAndTime [ '2020-01-07T02:12:43.302626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPEndOfInputParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| memento result |\r\tmemento := aPPContext remember.\r\tresult := parser parseOn: aPPContext.\r\t(result isPetitFailure or: [ aPPContext stream atEnd ])\r\t\tifTrue: [ ^ result ].\r\tresult := PPFailure\r\t\tmessage: \'end of input expected\'\r\t\tcontext: aPPContext.\r\taPPContext restore: memento.\r\t^ result',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPEndOfInputParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| position result |\r\tposition := aStream position.\r\tresult := parser parseOn: aStream.\r\t(result isPetitFailure or: [ aStream atEnd ])\r\t\tifTrue: [ ^ result ].\r\tresult := PPFailure\r\t\tmessage: \'end of input expected\'\r\t\tat: aStream position.\r\taStream position: position.\r\t^ result',			#stamp : 'lr 8/1/2010 17:10',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '536' ],		#self : OmReference [ '537' ],		#time : DateAndTime [ '2020-01-07T02:12:43.304626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedRepeatingParser,				#isMetaSide : false			},			#name : #'matchesLimitOn:',			#protocol : #private,			#sourceCode : 'matchesLimitOn: aPPContext\r\t| element position |\r\tposition := aPPContext remember.\r\telement := limit parseOn: aPPContext.\r\taPPContext restore: position.\r\t^ element isPetitFailure not',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedRepeatingParser,				#isMetaSide : false			},			#name : #'matchesLimitOn:',			#protocol : #private,			#sourceCode : 'matchesLimitOn: aStream\r\t| element position |\r\tposition := aStream position.\r\telement := limit parseOn: aStream.\r\taStream position: position.\r\t^ element isPetitFailure not',			#stamp : 'lr 4/2/2011 10:10',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '537' ],		#self : OmReference [ '538' ],		#time : DateAndTime [ '2020-01-07T02:12:43.305626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedRepeatingParser,				#isMetaSide : false			},			#name : #'matchesLimitOn:',			#protocol : #parsing,			#sourceCode : 'matchesLimitOn: aStream\r\t| element position |\r\tposition := aStream position.\r\telement := limit parseOn: aStream.\r\taStream position: position.\r\t^ element isPetitFailure not',			#stamp : 'lr 4/2/2011 10:10',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPLimitedRepeatingParser,				#isMetaSide : false			},			#name : #'matchesLimitOn:',			#protocol : #private,			#sourceCode : 'matchesLimitOn: aStream\r\t| element position |\r\tposition := aStream position.\r\telement := limit parseOn: aStream.\r\taStream position: position.\r\t^ element isPetitFailure not',			#stamp : 'lr 4/2/2011 10:10',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '538' ],		#self : OmReference [ '539' ],		#time : DateAndTime [ '2020-01-07T02:12:43.307626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SequenceableCollection,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asPetitStream\r\t^ PPStream on: self',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SequenceableCollection,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asPetitStream\r\t^ PPStream on: self',			#stamp : 'lr 2/7/2010 20:53',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '539' ],		#self : OmReference [ '540' ],		#time : DateAndTime [ '2020-01-07T02:12:43.313626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SequenceableCollection,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*PetitParser',			#sourceCode : 'asPetitStream\r\t^ PPStream on: self',			#stamp : 'lr 2/7/2010 20:53',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SequenceableCollection,				#isMetaSide : false			},			#name : #asPetitStream,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asPetitStream\r\t^ PPStream on: self',			#stamp : 'lr 2/7/2010 20:53',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '540' ],		#self : OmReference [ '541' ],		#time : DateAndTime [ '2020-01-07T02:12:43.314626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UndefinedObject,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-converting',			#sourceCode : 'asParser\r\t"Answer a parser that succeeds and does not consume anything."\r\t\r\t^ PPEpsilonParser new',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UndefinedObject,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-converting',			#sourceCode : 'asParser\r\t"Answer a parser that succeeds and does not consume anything."\r\t\r\t^ PPEpsilonParser new',			#stamp : 'lr 11/29/2011 20:49',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '541' ],		#self : OmReference [ '542' ],		#time : DateAndTime [ '2020-01-07T02:12:43.319626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UndefinedObject,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser\r\t"Answer a parser that succeeds and does not consume anything."\r\t\r\t^ PPEpsilonParser new',			#stamp : 'lr 11/29/2011 20:49',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UndefinedObject,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-converting',			#sourceCode : 'asParser\r\t"Answer a parser that succeeds and does not consume anything."\r\t\r\t^ PPEpsilonParser new',			#stamp : 'lr 11/29/2011 20:49',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '542' ],		#self : OmReference [ '543' ],		#time : DateAndTime [ '2020-01-07T02:12:43.320626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #'assert:fail:end:',			#protocol : #utilities,			#sourceCode : 'assert: aParser fail: aCollection end: anInteger\r\t| stream result context |\r\tself \r\t\tassert: aParser isPetitParser\r\t\tdescription: \'Parser invalid\'.\r\tstream := aCollection asPetitStream.\r\tcontext := self context.\r\t\r\t\r\tresult := aParser parse: stream withContext: context.\r\tself \r\t\tassert: result isPetitFailure\r\t\tdescription: \'Parser did not fail\'.\r\tself\r\t\tassert: context position = anInteger\r\t\tdescription: \'Parser failed at wrong position\'.\r\t^ result',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #'assert:fail:end:',			#protocol : #utilities,			#sourceCode : 'assert: aParser fail: aCollection end: anInteger\r\t| stream result |\r\tself \r\t\tassert: aParser isPetitParser\r\t\tdescription: \'Parser invalid\'.\r\tstream := aCollection asPetitStream.\r\tresult := aParser parse: stream.\r\tself \r\t\tassert: result isPetitFailure\r\t\tdescription: \'Parser did not fail\'.\r\tself\r\t\tassert: stream position = anInteger\r\t\tdescription: \'Parser failed at wrong position\'.\r\t^ result',			#stamp : 'DamienPollet 8/11/2011 01:49',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '543' ],		#self : OmReference [ '544' ],		#time : DateAndTime [ '2020-01-07T02:12:43.322626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #'assert:parse:to:end:',			#protocol : #utilities,			#sourceCode : 'assert: aParser parse: aCollection to: aTargetObject end: anInteger\r\t| stream result context |\r\r\tself assert: aParser isPetitParser description: \'Parser invalid\'.\r\tstream := aCollection asPetitStream.\r\tcontext := self context.\r\t\r\tresult := aParser parse: stream withContext: context.\r\taTargetObject isNil\r\t\tifTrue: [ self deny: result isPetitFailure ]\r\t\tifFalse: [ self assert: result equals: aTargetObject ].\r\tself assert: context position = anInteger description: \'Parser accepted at wrong position\'.\r\t^ result',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #'assert:parse:to:end:',			#protocol : #utilities,			#sourceCode : 'assert: aParser parse: aCollection to: aTargetObject end: anInteger\r\t| stream result |\r\tself \r\t\tassert: aParser isPetitParser\r\t\tdescription: \'Parser invalid\'.\r\tstream := aCollection asPetitStream.\r\tresult := aParser parse: stream.\r\taTargetObject isNil\r\t\tifTrue: [ self deny: result isPetitFailure ]\r\t\tifFalse: [ self assert: result = aTargetObject ].\r\tself \r\t\tassert: stream position = anInteger\r\t\tdescription: \'Parser accepted at wrong position\'.\r\t^ result',			#stamp : 'lr 2/26/2013 00:43',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '544' ],		#self : OmReference [ '545' ],		#time : DateAndTime [ '2020-01-07T02:12:43.324626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #'assert:parse:toToken:stop:end:',			#protocol : #utilities,			#sourceCode : 'assert: aParser parse: aParserObject toToken: aStartInteger stop: aStopInteger end: anEndInteger\r\t| token |\r\ttoken := self\r\t\tassert: aParser\r\t\tparse: aParserObject\r\t\tto: nil\r\t\tend: anEndInteger.\r\tself assert: (token isKindOf: PPToken).\r\tself assert: token start equals: aStartInteger.\r\tself assert: token stop equals: aStopInteger.\r\t^ token',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPAbstractParserTest,				#isMetaSide : false			},			#name : #'assert:parse:toToken:stop:end:',			#protocol : #utilities,			#sourceCode : 'assert: aParser parse: aParserObject toToken: aStartInteger stop: aStopInteger end: anEndInteger\r\t| token |\r\ttoken := self assert: aParser parse: aParserObject to: nil end: anEndInteger.\r\tself assert: (token isKindOf: PPToken).\r\tself assert: (token start = aStartInteger).\r\tself assert: (token stop = aStopInteger).\r\t^ token',			#stamp : 'lr 2/26/2013 00:42',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '545' ],		#self : OmReference [ '546' ],		#time : DateAndTime [ '2020-01-07T02:12:43.326626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'fail:rule:',			#protocol : #parsing,			#sourceCode : 'fail: aString rule: aSymbol \r\t| production context |\r\tproduction := self parserInstanceFor: aSymbol.\r\tcontext := self context.\r\t\r\tresult := production end parse: aString withContext: context.\r\t\r\tself\r\t\tassert: result isPetitFailure\r\t\tdescription: \'Able to parse \' , aString printString.\r\t^ result',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'fail:rule:',			#protocol : #parsing,			#sourceCode : 'fail: aString rule: aSymbol \r\t| production |\r\tproduction := self parserInstanceFor: aSymbol.\r\tresult := production end parse: aString.\r\tself\r\t\tassert: result isPetitFailure\r\t\tdescription: \'Able to parse \' , aString printString.\r\t^ result',			#stamp : 'lr 11/18/2011 19:45',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '546' ],		#self : OmReference [ '547' ],		#time : DateAndTime [ '2020-01-07T02:12:43.328626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'parse:rule:',			#protocol : #parsing,			#sourceCode : 'parse: aString rule: aSymbol\r\t| production context |\r\tproduction := self parserInstanceFor: aSymbol.\r\tcontext := self context.\r\t\r\tresult := production end parse: aString withContext: context.\r\tself\r\t\tdeny: result isPetitFailure\r\t\tdescription: \'Unable to parse \' , aString printString.\r\t^ result',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #'parse:rule:',			#protocol : #parsing,			#sourceCode : 'parse: aString rule: aSymbol\r\t| production |\r\tproduction := self parserInstanceFor: aSymbol.\r\tresult := production end parse: aString.\r\tself\r\t\tdeny: result isPetitFailure\r\t\tdescription: \'Unable to parse \' , aString printString.\r\t^ result',			#stamp : 'lr 11/18/2011 19:45',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '547' ],		#self : OmReference [ '548' ],		#time : DateAndTime [ '2020-01-07T02:12:43.329626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #tearDown,			#protocol : #running,			#sourceCode : 'tearDown\r\tparser := result := nil.\r\tsuper tearDown.\r',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPCompositeParserTest,				#isMetaSide : false			},			#name : #tearDown,			#protocol : #running,			#sourceCode : 'tearDown\r\tsuper tearDown.\r\tparser := result := nil',			#stamp : 'lr 11/29/2010 11:19',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '548' ],		#self : OmReference [ '549' ],		#time : DateAndTime [ '2020-01-07T02:12:43.331626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPObjectTest,				#isMetaSide : false			},			#name : #integer,			#protocol : #parsers,			#sourceCode : 'integer\r\t^ PPPredicateObjectParser\r\t\ton: [ :each | each isKindOf: Integer ]\r\t\tmessage: \'integer expected\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPObjectTest,				#isMetaSide : false			},			#name : #integer,			#protocol : #parsers,			#sourceCode : 'integer\r\t^ PPPredicateObjectParser\r\t\ton: [ :each | each isInteger ]\r\t\tmessage: \'integer expected\'',			#stamp : 'lr 12/9/2010 10:25',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '549' ],		#self : OmReference [ '550' ],		#time : DateAndTime [ '2020-01-07T02:12:43.333626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPObjectTest,				#isMetaSide : false			},			#name : #string,			#protocol : #parsers,			#sourceCode : 'string\r\t^ PPPredicateObjectParser\r\t\ton: [ :each | each isKindOf: String ]\r\t\tmessage: \'string expected\'',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPObjectTest,				#isMetaSide : false			},			#name : #string,			#protocol : #parsers,			#sourceCode : 'string\r\t^ PPPredicateObjectParser\r\t\ton: [ :each | each isString ]\r\t\tmessage: \'string expected\'',			#stamp : 'lr 10/30/2010 12:45',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '550' ],		#self : OmReference [ '551' ],		#time : DateAndTime [ '2020-01-07T02:12:43.335626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPObjectTest,				#isMetaSide : false			},			#name : #testFibonacci,			#protocol : #testing-fancy,			#sourceCode : 'testFibonacci\r\t"This parser accepts fibonacci sequences with arbitrary start pairs."\r\t\r\t| parser |\r\tparser := ((self integer , self integer) end ==> [ :pair | pair first + pair last ])\r\t\t/ (self integer , (self integer , self integer) and >=> [ :stream :continuation |\r\t\t\t| result |\r\t\t\tresult := continuation value.\r\t\t\t(result isPetitFailure or: [ result first + result last first ~= result last last ])\r\t\t\t\tifFalse: [ parser parseOn: stream ]\r\t\t\t\tifTrue: [ PPFailure message: \'invalid fibonacci sequence\' context: stream ] ]).\r\tself assert: parser parse: #(1 1) to: 2.\r\tself assert: parser parse: #(1 1 2) to: 3.\r\tself assert: parser parse: #(1 1 2 3) to: 5.\r\tself assert: parser parse: #(1 1 2 3 5) to: 8.\r\tself assert: parser parse: #(1 1 2 3 5 8) to: 13.\r\tself assert: parser parse: #(1 1 2 3 5 8 13) to: 21.\r\tself assert: parser fail: #().\r\tself assert: parser fail: #(1).\r\tself assert: parser fail: #(1 2 3 4) end: 2\r\t',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPObjectTest,				#isMetaSide : false			},			#name : #testFibonacci,			#protocol : #testing-fancy,			#sourceCode : 'testFibonacci\r\t"This parser accepts fibonacci sequences with arbitrary start pairs."\r\t\r\t| parser |\r\tparser := ((self integer , self integer) end ==> [ :pair | pair first + pair last ])\r\t\t/ (self integer , (self integer , self integer) and >=> [ :stream :continuation |\r\t\t\t| result |\r\t\t\tresult := continuation value.\r\t\t\t(result isPetitFailure or: [ result first + result last first ~= result last last ])\r\t\t\t\tifFalse: [ parser parseOn: stream ]\r\t\t\t\tifTrue: [ PPFailure message: \'invalid fibonacci sequence\' at: stream position ] ]).\r\tself assert: parser parse: #(1 1) to: 2.\r\tself assert: parser parse: #(1 1 2) to: 3.\r\tself assert: parser parse: #(1 1 2 3) to: 5.\r\tself assert: parser parse: #(1 1 2 3 5) to: 8.\r\tself assert: parser parse: #(1 1 2 3 5 8) to: 13.\r\tself assert: parser parse: #(1 1 2 3 5 8 13) to: 21.\r\tself assert: parser fail: #().\r\tself assert: parser fail: #(1).\r\tself assert: parser fail: #(1 2 3 4) end: 2\r\t',			#stamp : 'lr 12/9/2010 10:25',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '551' ],		#self : OmReference [ '552' ],		#time : DateAndTime [ '2020-01-07T02:12:43.336626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPArithmeticParser,				#isMetaSide : false			},			#name : #parentheses,			#protocol : #grammar,			#sourceCode : 'parentheses\r\t^ $( asParser trim , terms , $) asParser trim\r\t\t==> [ :nodes | nodes at: 2 ]',			#stamp : '',			#package : #PetitTests		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPArithmeticParser,				#isMetaSide : false			},			#name : #parentheses,			#protocol : #grammar,			#sourceCode : 'parentheses\r\t^ $( asParser trim , terms , $) asParser trim\r\t\t==> [ :nodes | nodes second ]',			#stamp : 'lr 2/25/2013 23:49',			#package : #PetitTests		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '552' ],		#self : OmReference [ '553' ],		#time : DateAndTime [ '2020-01-07T02:12:43.338626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BlockClosure,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser implemented in the receiving one-argument block."\r\r\t^ PPPluggableParser on: self',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BlockClosure,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser implemented in the receiving one-argument block."\r\r\t^ PPPluggableParser on: self',			#stamp : 'lr 11/29/2011 20:48',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '553' ],		#self : OmReference [ '554' ],		#time : DateAndTime [ '2020-01-07T02:12:43.344626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BlockClosure,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*PetitParser',			#sourceCode : 'asParser\r\t"Answer a parser implemented in the receiving one-argument block."\r\r\t^ PPPluggableParser on: self',			#stamp : 'lr 11/29/2011 20:48',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BlockClosure,				#isMetaSide : false			},			#name : #asParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asParser\r\t"Answer a parser implemented in the receiving one-argument block."\r\r\t^ PPPluggableParser on: self',			#stamp : 'lr 11/29/2011 20:48',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '554' ],		#self : OmReference [ '555' ],		#time : DateAndTime [ '2020-01-07T02:12:43.345626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPOptionalParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aPPContext\r\t| element |\r\telement := parser parseOn: aPPContext.\r\t^ element isPetitFailure ifFalse: [ element ]',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #PPOptionalParser,				#isMetaSide : false			},			#name : #'parseOn:',			#protocol : #parsing,			#sourceCode : 'parseOn: aStream\r\t| element |\r\telement := parser parseOn: aStream.\r\t^ element isPetitFailure ifFalse: [ element ]',			#stamp : 'lr 8/14/2011 11:47',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '555' ],		#self : OmReference [ '556' ],		#time : DateAndTime [ '2020-01-07T02:12:43.346626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asChoiceParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asChoiceParser\r\t^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asChoiceParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asChoiceParser\r\t^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])',			#stamp : 'lr 11/29/2011 20:38',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '556' ],		#self : OmReference [ '557' ],		#time : DateAndTime [ '2020-01-07T02:12:43.352626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asChoiceParser,			#protocol : #'*PetitParser',			#sourceCode : 'asChoiceParser\r\t^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])',			#stamp : 'lr 11/29/2011 20:38',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asChoiceParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asChoiceParser\r\t^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])',			#stamp : 'lr 11/29/2011 20:38',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '557' ],		#self : OmReference [ '558' ],		#time : DateAndTime [ '2020-01-07T02:12:43.353626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asSequenceParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asSequenceParser\r\t^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])',			#stamp : '',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asSequenceParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asSequenceParser\r\t^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])',			#stamp : 'lr 11/29/2011 20:38',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '558' ],		#self : OmReference [ '559' ],		#time : DateAndTime [ '2020-01-07T02:12:43.358626+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asSequenceParser,			#protocol : #'*PetitParser',			#sourceCode : 'asSequenceParser\r\t^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])',			#stamp : 'lr 11/29/2011 20:38',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Collection,				#isMetaSide : false			},			#name : #asSequenceParser,			#protocol : #'*petitparser-core-converting',			#sourceCode : 'asSequenceParser\r\t^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])',			#stamp : 'lr 11/29/2011 20:38',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2020-01-07T02:15:41.480626+01:00' ],		#prior : OmReference [ '559' ],		#self : OmReference [ '560' ]	},	#content : EpCategoryAddition {		#classCategoryName : #PetitParser,		#affectedPackageName : #PetitParser	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2020-01-07T02:15:41.484626+01:00' ],		#prior : OmReference [ '560' ],		#self : OmReference [ '561' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestPetitParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestPetitParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestPetitParser class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestPetitParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestPetitParser,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2020-01-07T02:15:41.486626+01:00' ],		#prior : OmReference [ '561' ],		#self : OmReference [ '562' ]	},	#content : EpCategoryAddition {		#classCategoryName : #PetitParser-Manifest,		#affectedPackageName : #PetitParser	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2020-01-07T02:15:41.489626+01:00' ],		#prior : OmReference [ '562' ],		#self : OmReference [ '563' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #PetitParser,		#newCategory : #PetitParser-Manifest,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestPetitParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Manifest\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestPetitParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestPetitParser class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestPetitParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestPetitParser,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Manifest,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2020-01-07T02:15:41.492626+01:00' ],		#prior : OmReference [ '563' ],		#self : OmReference [ '564' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestPetitParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Manifest\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestPetitParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestPetitParser class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestPetitParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestPetitParser,					#isMetaSide : false				},				#parent : @7,				#content : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Manifest,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:15:46.731626+01:00' ],		#prior : OmReference [ '564' ],		#self : OmReference [ '565' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestPetitParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Manifest\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestPetitParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestPetitParser class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestPetitParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestPetitParser,					#isMetaSide : false				},				#parent : @7,				#content : 'Please comment package here!',				#stamp : 'testerTester 1/7/2020 02:15'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Manifest,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',		#newComment : 'Please comment package here!',		#oldStamp : '<historical>',		#newStamp : 'testerTester 1/7/2020 02:15'	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:16:01.676626+01:00' ],		#prior : OmReference [ '565' ],		#self : OmReference [ '566' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #PPCharSetPredicate\r\tinstanceVariableNames: \'block classification\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Tools\'',				#superclassName : 'Object'			},			#name : #PPCharSetPredicate,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPCharSetPredicate,						#isMetaSide : false					},					#name : #block,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #PPCharSetPredicate,						#isMetaSide : false					},					#name : #classification,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'PPCharSetPredicate class\r\tinstanceVariableNames: \'\''				},				#name : #'PPCharSetPredicate class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #PPCharSetPredicate,					#isMetaSide : false				},				#parent : @7,				#content : 'now there is a comment',				#stamp : 'testerTester 1/7/2020 02:16'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Tools,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'now there is a comment',		#newStamp : 'testerTester 1/7/2020 02:16'	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:18:18.879626+01:00' ],		#prior : OmReference [ '566' ],		#self : OmReference [ '567' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParser subclass: #KdPGrammer\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Tools\'',				#superclassName : 'PPCompositeParser'			},			#name : #KdPGrammer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'KdPGrammer class\r\tinstanceVariableNames: \'\''				},				#name : #'KdPGrammer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #KdPGrammer,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Tools,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:18:41.097626+01:00' ],		#prior : OmReference [ '567' ],		#self : OmReference [ '568' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #number,			#protocol : #'as yet unclassified',			#sourceCode : 'number\r^ #digit asParser plus flatten trim ==> [ :str | str asNumber ]',			#stamp : 'testerTester 1/7/2020 02:18',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:18:41.122626+01:00' ],		#prior : OmReference [ '568' ],		#self : OmReference [ '569' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #number,			#protocol : #'as yet unclassified',			#sourceCode : 'number\r^ #digit asParser plus flatten trim ==> [ :str | str asNumber ]',			#stamp : 'testerTester 1/7/2020 02:18',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #number,			#protocol : #accessing,			#sourceCode : 'number\r^ #digit asParser plus flatten trim ==> [ :str | str asNumber ]',			#stamp : 'testerTester 1/7/2020 02:18',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:19:08.390626+01:00' ],		#prior : OmReference [ '569' ],		#self : OmReference [ '570' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParser subclass: #KdPGrammer\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Tools\'',				#superclassName : 'PPCompositeParser'			},			#name : #KdPGrammer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'KdPGrammer class\r\tinstanceVariableNames: \'\''				},				#name : #'KdPGrammer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #KdPGrammer,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Tools,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParser subclass: #KdPGrammer\r\tinstanceVariableNames: \'add prod term mul prim parens number\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Tools\'',				#superclassName : 'PPCompositeParser'			},			#name : #KdPGrammer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #add,					#parent : @21				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #prod,					#parent : @21				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #term,					#parent : @21				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #mul,					#parent : @21				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #prim,					#parent : @21				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #parens,					#parent : @21				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #number,					#parent : @21				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'KdPGrammer class\r\tinstanceVariableNames: \'\''				},				#name : #'KdPGrammer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #KdPGrammer,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Tools,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:19:28.997626+01:00' ],		#prior : OmReference [ '570' ],		#self : OmReference [ '571' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #term,			#protocol : #'as yet unclassified',			#sourceCode : 'term\r^ add / prod',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:19:29.003626+01:00' ],		#prior : OmReference [ '571' ],		#self : OmReference [ '572' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #term,			#protocol : #'as yet unclassified',			#sourceCode : 'term\r^ add / prod',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #term,			#protocol : #accessing,			#sourceCode : 'term\r^ add / prod',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:19:35.285626+01:00' ],		#prior : OmReference [ '572' ],		#self : OmReference [ '573' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #add,			#protocol : #'as yet unclassified',			#sourceCode : 'add\r^ prod , $+ asParser trim , term',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:19:35.291626+01:00' ],		#prior : OmReference [ '573' ],		#self : OmReference [ '574' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #add,			#protocol : #'as yet unclassified',			#sourceCode : 'add\r^ prod , $+ asParser trim , term',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #add,			#protocol : #accessing,			#sourceCode : 'add\r^ prod , $+ asParser trim , term',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:19:44.079626+01:00' ],		#prior : OmReference [ '574' ],		#self : OmReference [ '575' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #prod,			#protocol : #'as yet unclassified',			#sourceCode : 'prod\r^ mul / prim',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:19:44.085626+01:00' ],		#prior : OmReference [ '575' ],		#self : OmReference [ '576' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #prod,			#protocol : #'as yet unclassified',			#sourceCode : 'prod\r^ mul / prim',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #prod,			#protocol : #accessing,			#sourceCode : 'prod\r^ mul / prim',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:19:52.100626+01:00' ],		#prior : OmReference [ '576' ],		#self : OmReference [ '577' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #mul,			#protocol : #'as yet unclassified',			#sourceCode : 'mul\r^ prim , $* asParser trim , prod',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:19:52.110626+01:00' ],		#prior : OmReference [ '577' ],		#self : OmReference [ '578' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #mul,			#protocol : #'as yet unclassified',			#sourceCode : 'mul\r^ prim , $* asParser trim , prod',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #mul,			#protocol : #accessing,			#sourceCode : 'mul\r^ prim , $* asParser trim , prod',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:20:01.565626+01:00' ],		#prior : OmReference [ '578' ],		#self : OmReference [ '579' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #prim,			#protocol : #'as yet unclassified',			#sourceCode : 'prim\r^ parens / number',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:20:01.571626+01:00' ],		#prior : OmReference [ '579' ],		#self : OmReference [ '580' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #prim,			#protocol : #'as yet unclassified',			#sourceCode : 'prim\r^ parens / number',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #prim,			#protocol : #accessing,			#sourceCode : 'prim\r^ parens / number',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:20:08.420626+01:00' ],		#prior : OmReference [ '580' ],		#self : OmReference [ '581' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #parens,			#protocol : #'as yet unclassified',			#sourceCode : 'parens\r^ $( asParser trim , term , $) asParser trim',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:20:08.426626+01:00' ],		#prior : OmReference [ '581' ],		#self : OmReference [ '582' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #parens,			#protocol : #'as yet unclassified',			#sourceCode : 'parens\r^ $( asParser trim , term , $) asParser trim',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #parens,			#protocol : #accessing,			#sourceCode : 'parens\r^ $( asParser trim , term , $) asParser trim',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:20:21.676626+01:00' ],		#prior : OmReference [ '582' ],		#self : OmReference [ '583' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #start,			#protocol : #'as yet unclassified',			#sourceCode : 'start\r^ term end',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:20:21.681626+01:00' ],		#prior : OmReference [ '583' ],		#self : OmReference [ '584' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #start,			#protocol : #'as yet unclassified',			#sourceCode : 'start\r^ term end',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #start,			#protocol : #accessing,			#sourceCode : 'start\r^ term end',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:21:01.049626+01:00' ],		#prior : OmReference [ '584' ],		#self : OmReference [ '585' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestPetitParser\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Manifest\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestPetitParser,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestPetitParser class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestPetitParser class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestPetitParser,					#isMetaSide : false				},				#parent : @7,				#content : 'by Markus Kaleta\rCreated for Konzepte der Programmiersprache.',				#stamp : 'testerTester 1/7/2020 02:21'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Manifest,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Please comment package here!',		#newComment : 'by Markus Kaleta\rCreated for Konzepte der Programmiersprache.',		#oldStamp : 'testerTester 1/7/2020 02:15',		#newStamp : 'testerTester 1/7/2020 02:21'	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T02:21:21.787626+01:00' ],		#prior : OmReference [ '585' ],		#self : OmReference [ '586' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParser subclass: #KdPGrammer\r\tinstanceVariableNames: \'add prod term mul prim parens number\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Tools\'',				#superclassName : 'PPCompositeParser'			},			#name : #KdPGrammer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #add,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #prod,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #term,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #mul,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #prim,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #parens,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #number,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'KdPGrammer class\r\tinstanceVariableNames: \'\''				},				#name : #'KdPGrammer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #KdPGrammer,					#isMetaSide : false				},				#parent : @7,				#content : 'by Markus Kaleta\rCreated for Konzepte der Programmiersprache.',				#stamp : 'testerTester 1/7/2020 02:21'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Tools,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'by Markus Kaleta\rCreated for Konzepte der Programmiersprache.',		#newStamp : 'testerTester 1/7/2020 02:21'	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:05:56.772626+01:00' ],		#prior : OmReference [ '586' ],		#self : OmReference [ '587' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #term,		#newSelector : #term1,		#affectedClassName : 'KdPGrammer>>#term'	}}OmEntry {	#tags : {		#author : 'testerTester',		#prior : OmReference [ '587' ],		#self : OmReference [ '588' ],		#time : DateAndTime [ '2020-01-07T16:05:56.784626+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCPostfixTermNode,				#isMetaSide : false			},			#name : #term1,			#protocol : #generated,			#sourceCode : 'term1\r\t^ term',			#stamp : 'testerTester 1/7/2020 16:05',			#package : #SmaCC_Grammar_Parser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#prior : OmReference [ '588' ],		#self : OmReference [ '589' ],		#time : DateAndTime [ '2020-01-07T16:05:56.791626+01:00' ],		#trigger : OmReference [ '587' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #term1,			#protocol : #accessing,			#sourceCode : 'term1\r^ add / prod',			#stamp : 'testerTester 1/7/2020 16:05',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#prior : OmReference [ '589' ],		#self : OmReference [ '590' ],		#time : DateAndTime [ '2020-01-07T16:05:56.801626+01:00' ],		#trigger : OmReference [ '587' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCGrammarCreator,				#isMetaSide : false			},			#name : #'visitPostfixTerm:',			#protocol : #visiting,			#sourceCode : 'visitPostfixTerm: aPostfixTerm\r\t| operator expression symbol rhs varNameToken hasOne hasMany addBlock |\r\toperator := aPostfixTerm operator value.\r\texpression := self acceptNode: aPostfixTerm term.\r\tsymbol := grammar nonTerminalSymbolNamed: aPostfixTerm source.\r\tsymbol size = 0\r\t\tifTrue: [ symbol position: aPostfixTerm startPosition.\r\t\t\thasOne := operator = \'+\'.\r\t\t\thasMany := operator ~= \'?\'.\r\t\t\tvarNameToken := (aPostfixTerm term isKindOf: SmaCCSymbolNode)\r\t\t\t\tifTrue: [ aPostfixTerm term variableNameToken ].\r\t\t\trhs := grammar newRHS.\r\t\t\taddBlock := [ rhs add: expression.\r\t\t\tvarNameToken notNil\r\t\t\t\tifTrue: [ rhs nameLastItem: (varNameToken value copyFrom: 2 to: varNameToken value size - 1) ] ].\r\t\t\thasOne\r\t\t\t\tifTrue: [ addBlock value ].\r\t\t\tsymbol addProduction: rhs.\r\t\t\trhs := grammar newRHS.\r\t\t\thasMany\r\t\t\t\tifTrue: [ rhs add: symbol ].\r\t\t\taddBlock value.\r\t\t\tsymbol addProduction: rhs ].\r\t^ symbol',			#stamp : '',			#package : #SmaCC_Development		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCGrammarCreator,				#isMetaSide : false			},			#name : #'visitPostfixTerm:',			#protocol : #visiting,			#sourceCode : 'visitPostfixTerm: aPostfixTerm\r\t| operator expression symbol rhs varNameToken hasOne hasMany addBlock |\r\toperator := aPostfixTerm operator value.\r\texpression := self acceptNode: aPostfixTerm term1.\r\tsymbol := grammar nonTerminalSymbolNamed: aPostfixTerm source.\r\tsymbol size = 0\r\t\tifTrue: [ symbol position: aPostfixTerm startPosition.\r\t\t\thasOne := operator = \'+\'.\r\t\t\thasMany := operator ~= \'?\'.\r\t\t\tvarNameToken := (aPostfixTerm term1 isKindOf: SmaCCSymbolNode)\r\t\t\t\tifTrue: [ aPostfixTerm term1 variableNameToken ].\r\t\t\trhs := grammar newRHS.\r\t\t\taddBlock := [ rhs add: expression.\r\t\t\tvarNameToken notNil\r\t\t\t\tifTrue: [ rhs nameLastItem: (varNameToken value copyFrom: 2 to: varNameToken value size - 1) ] ].\r\t\t\thasOne\r\t\t\t\tifTrue: [ addBlock value ].\r\t\t\tsymbol addProduction: rhs.\r\t\t\trhs := grammar newRHS.\r\t\t\thasMany\r\t\t\t\tifTrue: [ rhs add: symbol ].\r\t\t\taddBlock value.\r\t\t\tsymbol addProduction: rhs ].\r\t^ symbol',			#stamp : 'testerTester 1/7/2020 16:05',			#package : #SmaCC_Development		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#prior : OmReference [ '590' ],		#self : OmReference [ '591' ],		#time : DateAndTime [ '2020-01-07T16:05:56.807626+01:00' ],		#trigger : OmReference [ '587' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCPostfixTermNode,				#isMetaSide : false			},			#name : #nodeVariables,			#protocol : #generated,			#sourceCode : 'nodeVariables\r\t^ #(#term)',			#stamp : '',			#package : #SmaCC_Grammar_Parser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCPostfixTermNode,				#isMetaSide : false			},			#name : #nodeVariables,			#protocol : #generated,			#sourceCode : 'nodeVariables\r\t^ #(#term1)',			#stamp : 'testerTester 1/7/2020 16:05',			#package : #SmaCC_Grammar_Parser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#prior : OmReference [ '591' ],		#self : OmReference [ '592' ],		#time : DateAndTime [ '2020-01-07T16:05:56.812626+01:00' ],		#trigger : OmReference [ '587' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCPostfixTermNode,				#isMetaSide : false			},			#name : #'term:',			#protocol : #generated,			#sourceCode : 'term: aSmaCCDefinitionNode\r\tself term notNil\r\t\tifTrue: [ self term parent: nil ].\r\tterm := aSmaCCDefinitionNode.\r\tself term notNil\r\t\tifTrue: [ self term parent: self ]',			#stamp : '',			#package : #SmaCC_Grammar_Parser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCPostfixTermNode,				#isMetaSide : false			},			#name : #'term:',			#protocol : #generated,			#sourceCode : 'term: aSmaCCDefinitionNode\r\tself term1 notNil\r\t\tifTrue: [ self term1 parent: nil ].\r\tterm := aSmaCCDefinitionNode.\r\tself term1 notNil\r\t\tifTrue: [ self term1 parent: self ]',			#stamp : 'testerTester 1/7/2020 16:05',			#package : #SmaCC_Grammar_Parser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#prior : OmReference [ '592' ],		#self : OmReference [ '593' ],		#time : DateAndTime [ '2020-01-07T16:05:56.814626+01:00' ],		#trigger : OmReference [ '587' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCPostfixTermNode,				#isMetaSide : false			},			#name : #term,			#protocol : #generated,			#sourceCode : 'term\r\t^ term',			#stamp : '',			#package : #SmaCC_Grammar_Parser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCPostfixTermNode,				#isMetaSide : false			},			#name : #term,			#protocol : #'as yet unclassified',			#sourceCode : 'term\r\t^ term',			#stamp : '',			#package : #SmaCC_Grammar_Parser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#prior : OmReference [ '593' ],		#self : OmReference [ '594' ],		#time : DateAndTime [ '2020-01-07T16:05:56.815626+01:00' ],		#trigger : OmReference [ '587' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SmaCCPostfixTermNode,				#isMetaSide : false			},			#name : #term,			#protocol : #generated,			#sourceCode : 'term\r\t^ term',			#stamp : '',			#package : #SmaCC_Grammar_Parser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#prior : OmReference [ '594' ],		#self : OmReference [ '595' ],		#time : DateAndTime [ '2020-01-07T16:05:56.850626+01:00' ],		#trigger : OmReference [ '587' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #term,			#protocol : #accessing,			#sourceCode : 'term\r^ add / prod',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #term,			#protocol : #'as yet unclassified',			#sourceCode : 'term\r^ add / prod',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#prior : OmReference [ '595' ],		#self : OmReference [ '596' ],		#time : DateAndTime [ '2020-01-07T16:05:56.851626+01:00' ],		#trigger : OmReference [ '587' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #term,			#protocol : #accessing,			#sourceCode : 'term\r^ add / prod',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:06:27.610626+01:00' ],		#prior : OmReference [ '596' ],		#self : OmReference [ '597' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #term2,			#protocol : #'as yet unclassified',			#sourceCode : 'term2\r^ prod / add',			#stamp : 'testerTester 1/7/2020 16:06',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:08:24.189626+01:00' ],		#prior : OmReference [ '597' ],		#self : OmReference [ '598' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParser subclass: #KdPGrammer\r\tinstanceVariableNames: \'add prod term mul prim parens number\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Tools\'',				#superclassName : 'PPCompositeParser'			},			#name : #KdPGrammer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #add,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #prod,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #term,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #mul,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #prim,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #parens,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #number,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'KdPGrammer class\r\tinstanceVariableNames: \'\''				},				#name : #'KdPGrammer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #KdPGrammer,					#isMetaSide : false				},				#parent : @7,				#content : 'by Markus Kaleta\rCreated for Konzepte der Programmiersprache.',				#stamp : 'testerTester 1/7/2020 02:21'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Tools,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PPCompositeParser subclass: #KdPGrammer\r\tinstanceVariableNames: \'add prod term1 term2 mul prim parens number expr\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'PetitParser-Tools\'',				#superclassName : 'PPCompositeParser'			},			#name : #KdPGrammer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #add,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #prod,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #term1,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #term2,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #mul,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #prim,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #parens,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #number,					#parent : @35				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #KdPGrammer,						#isMetaSide : false					},					#name : #expr,					#parent : @35				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'KdPGrammer class\r\tinstanceVariableNames: \'\''				},				#name : #'KdPGrammer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @35			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #KdPGrammer,					#isMetaSide : false				},				#parent : @35,				#content : 'by Markus Kaleta\rCreated for Konzepte der Programmiersprache.',				#stamp : 'testerTester 1/7/2020 02:21'			},			#classVariables : OrderedCollection [ ],			#category : #PetitParser-Tools,			#package : #PetitParser,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:08:27.206626+01:00' ],		#prior : OmReference [ '598' ],		#self : OmReference [ '599' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #'as yet unclassified',			#sourceCode : 'expr\r^ term1 + term2',			#stamp : 'testerTester 1/7/2020 16:08',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:08:27.209626+01:00' ],		#prior : OmReference [ '599' ],		#self : OmReference [ '600' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #'as yet unclassified',			#sourceCode : 'expr\r^ term1 + term2',			#stamp : 'testerTester 1/7/2020 16:08',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #accessing,			#sourceCode : 'expr\r^ term1 + term2',			#stamp : 'testerTester 1/7/2020 16:08',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:08:35.751626+01:00' ],		#prior : OmReference [ '600' ],		#self : OmReference [ '601' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #accessing,			#sourceCode : 'expr\r^ term1 + term2',			#stamp : 'testerTester 1/7/2020 16:08',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #accessing,			#sourceCode : 'expr\r^ term1 | term2',			#stamp : 'testerTester 1/7/2020 16:08',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:08:51.004626+01:00' ],		#prior : OmReference [ '601' ],		#self : OmReference [ '602' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #start,			#protocol : #accessing,			#sourceCode : 'start\r^ term end',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #start,			#protocol : #accessing,			#sourceCode : 'start\r^ expr end',			#stamp : 'testerTester 1/7/2020 16:08',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:08:58.734626+01:00' ],		#prior : OmReference [ '602' ],		#self : OmReference [ '603' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #parens,			#protocol : #accessing,			#sourceCode : 'parens\r^ $( asParser trim , term , $) asParser trim',			#stamp : 'testerTester 1/7/2020 02:20',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #parens,			#protocol : #accessing,			#sourceCode : 'parens\r^ $( asParser trim , expr , $) asParser trim',			#stamp : 'testerTester 1/7/2020 16:08',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:09:04.638626+01:00' ],		#prior : OmReference [ '603' ],		#self : OmReference [ '604' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #add,			#protocol : #accessing,			#sourceCode : 'add\r^ prod , $+ asParser trim , term',			#stamp : 'testerTester 1/7/2020 02:19',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #add,			#protocol : #accessing,			#sourceCode : 'add\r^ prod , $+ asParser trim , expr',			#stamp : 'testerTester 1/7/2020 16:09',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:16:06.737626+01:00' ],		#prior : OmReference [ '604' ],		#self : OmReference [ '605' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #accessing,			#sourceCode : 'expr\r^ term1 | term2',			#stamp : 'testerTester 1/7/2020 16:13',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #accessing,			#sourceCode : 'expr\r^ term1 == term2',			#stamp : 'testerTester 1/7/2020 16:16',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:23:50.149626+01:00' ],		#prior : OmReference [ '605' ],		#self : OmReference [ '606' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #accessing,			#sourceCode : 'expr\r^ term1, term2',			#stamp : 'testerTester 1/7/2020 16:23',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #grammar,			#sourceCode : 'expr\r^ term1, term2',			#stamp : 'testerTester 1/7/2020 16:23',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:23:50.152626+01:00' ],		#prior : OmReference [ '606' ],		#self : OmReference [ '607' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #grammar,			#sourceCode : 'expr\r^ term1 == term2',			#stamp : 'testerTester 1/7/2020 16:16',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #grammar,			#sourceCode : 'expr\r^ term1, term2',			#stamp : 'testerTester 1/7/2020 16:23',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:24:01.147626+01:00' ],		#prior : OmReference [ '607' ],		#self : OmReference [ '608' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #grammar,			#sourceCode : 'expr\r^ term1, term2',			#stamp : 'testerTester 1/7/2020 16:23',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #grammar,			#sourceCode : 'expr\r^ term1 == term2',			#stamp : 'testerTester 1/7/2020 16:24',			#package : #PetitParser		}	}}OmEntry {	#tags : {		#author : 'testerTester',		#time : DateAndTime [ '2020-01-07T16:38:39.072626+01:00' ],		#prior : OmReference [ '608' ],		#self : OmReference [ '609' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #grammar,			#sourceCode : 'expr\r^ term1 == term2',			#stamp : 'testerTester 1/7/2020 16:24',			#package : #PetitParser		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #KdPGrammer,				#isMetaSide : false			},			#name : #expr,			#protocol : #grammar,			#sourceCode : 'expr\r^ term1 / term2',			#stamp : 'testerTester 1/7/2020 16:38',			#package : #PetitParser		}	}}